<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quinoa: RNGTest: Random number generator test suite</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="quinoa.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RNGTest: Random number generator test suite </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<object type="image/svg+xml" data="https://quinoacomputing.github.io/rngtest.svg" align="right" width="40%" background="transparent"></object>
</div>
<p>RNGTest is a fully asynchronous distributed-memory-parallel test harness to subject random number generators to stringent statistical tests enabling quantitative ranking with respect to generator quality and computational cost.</p>
<p>The test suite uses the <a href="http://charm.cs.illinois.edu">Charm++</a> runtime system to run the tests concurrently, either on a single machine or a networked set of computers. The software design is fully asynchronous, yielding 100% CPU utilization at all times, independent of the time taken by the individual tests.</p>
<h2>Examples </h2>
<p><a class="el" href="examples.html#rngtest_examples">RNGTest examples</a></p>
<h2>Help on command-line parameters </h2>
<p>As usual, use the <em>-h</em> command-line parameter to get on-screen help from an executable. Example output, excluding Charm++ command-line parameters: </p><div class="fragment"><div class="line">$ rngtest -h</div><div class="line">rngtest Command-line Parameters:</div><div class="line">       -c, --control     string Specify the control file name [REQUIRED]</div><div class="line">          -h, --help            Display one-liner help on all command-line arguments</div><div class="line">       -f, --helpctr            Display one-liner help on all control file keywords</div><div class="line">        -H, --helpkw     string Display verbose help on a single keyword</div><div class="line">       -v, --verbose            Select verbose screen output</div></div><!-- fragment --><h2>Requirements, features </h2>
<ol type="1">
<li><p class="startli"><b>Works with current and future libraries of RNGs:</b> Currently Intel's MKL's vector statistical library (VSL) RNGs, RNGSSE's RNGs, and a couple of Random123 RNGs are interfaced. References:</p><ul>
<li>MKL: <a href="https://software.intel.com/en-us/intel-mkl">https://software.intel.com/en-us/intel-mkl</a></li>
<li>RNGSSE: <a href="https://doi.org/10.1016/j.cpc.2011.03.022">https://doi.org/10.1016/j.cpc.2011.03.022</a> and <a href="https://doi.org/10.1016/j.cpc.2013.04.007">https://doi.org/10.1016/j.cpc.2013.04.007</a></li>
<li>Random123: <a href="http://www.thesalmons.org/john/random123/releases/latest/docs/index.html">http://www.thesalmons.org/john/random123/releases/latest/docs/index.html</a></li>
</ul>
<p class="startli">Note that MKL and RNGSSE2 are entirely optional. If unavailable, all features of Quinoa can be used via Random123.</p>
<p class="startli">All of these libraries implement a variety of different pseudo random number generators and importantly, all support concurrent sampling from random number streams: MKL supports both block splitting and leap frogging, RNGSSE supports block splitting (jumping ahead and initialization of a large number of independent streams), and Random123 RNGs are counter-based so counters can be initialized and incremented differently on each rank/thread.</p>
</li>
<li><b>Works with different libraries of statistical tests:</b> Currently TestU01's SmallCrush, Crush, and BigCrush batteries are supported and the design allows for other libraries of statistical tests. Reference for TestU01: <a href="http://www.iro.umontreal.ca/~simardr/testu01/tu01.html">http://www.iro.umontreal.ca/~simardr/testu01/tu01.html</a></li>
<li><b>The batteries work in parallel:</b> The user selects a number of RNGs (with optionally specifying parameters for each, e.g., seed, sequence length, etc.) as well as a battery of statistical tests. The tests are then run concurrently. RNGs from all RNG libraries can be tested (and thus compared to each other) at the same time.</li>
<li><b>Generator quality and computational cost:</b> As the tests of the battery are run, the various RNGs are timed separately, providing a 'generator cost' ranking. The number of passed and failed tests provide a 'generator quality' ranking (if more than one RNGs are tested).</li>
</ol>
<h2>Concurrency </h2>
<p>An arbitrary number of RNGs can be subjected to a single battery at a time. The tests are run concurrently using <a href="http://charm.cs.illinois.edu">Charm++</a> on a single machine or across a set of machines distributed over the network. The software design fully asynchronous yielding 100% CPU utilization at all times, independnt of the time taken by the individual tests.</p>
<p>Concurrency via Charm++ requires serializable objects. Charm++ discourages pointers, function pointers, references, while encourages stateless objects (or objects with as little and simple state as possible).</p>
<h2>Inheritance and runtime polymorphism </h2>
<p>While Charm++ supports migratable objects (chares) that inherit from a pure base class to implement runtime polymorphism via reference semantics, the current design of RNGTest does not rely on Charm++ to do this. Instead we use Sean Parent's <a href="https://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations">concept-based polymorphism</a> which achieves polymorphism without client-side inheritance and enables value semantics. In concept-based polymorphism inheritance in confined to the internals of a "base" class, which, at instantiation, is initialized via a templated constructor by a "derived"-class object. This locality enables an easier reasoning about the code, eliminates the need for client-side heap-allocation, client-side indirection, and in general, leads to tighter and more readable, simpler client-code.</p>
<p>Battery <em><a class="el" href="classrngtest_1_1_test_u01_suite.html" title="TestU01 random number generator test suite used polymorphically with Battery. ">rngtest::TestU01Suite</a></em> is thus used polymorphically with <em><a class="el" href="classrngtest_1_1_battery.html" title="Battery. ">rngtest::Battery</a></em>. All polymorphism (in a classical OOP sense) is confined to the internals of class <em>Battery</em>. A client still uses <em><a class="el" href="classrngtest_1_1_test_u01_suite.html" title="TestU01 random number generator test suite used polymorphically with Battery. ">rngtest::TestU01Suite</a></em> polymorphically as a <em><a class="el" href="classrngtest_1_1_battery.html" title="Battery. ">rngtest::Battery</a></em>.</p>
<p>Analogous to the relationship between classes <em><a class="el" href="classrngtest_1_1_battery.html" title="Battery. ">rngtest::Battery</a></em> and <em><a class="el" href="classrngtest_1_1_test_u01_suite.html" title="TestU01 random number generator test suite used polymorphically with Battery. ">rngtest::TestU01Suite</a></em>, the random number generators, available from the MKL, RNGSSSE, and Random123 libraries, are also used polymorphically with class <em><a class="el" href="classtk_1_1_r_n_g.html" title="Random number generator. ">tk::RNG</a></em> via concept-base polymorphism.</p>
<p>Analogous to the relationship between <em><a class="el" href="classrngtest_1_1_battery.html" title="Battery. ">rngtest::Battery</a></em> and <em><a class="el" href="classrngtest_1_1_test_u01_suite.html" title="TestU01 random number generator test suite used polymorphically with Battery. ">rngtest::TestU01Suite</a></em>, individual statistical tests of TestU01 are also used polymorphically with the "base" class <em><a class="el" href="classrngtest_1_1_stat_test.html" title="Random number generator statistical test. ">rngtest::StatTest</a></em>.</p>
<p>For more information on concept-based polymorphism, see for example <a href="https://github.com/sean-parent/sean-parent.github.com/wiki/presentations/2013-09-24-value-semantics/value-semantics.pdf">https://github.com/sean-parent/sean-parent.github.com/wiki/presentations/2013-09-24-value-semantics/value-semantics.pdf</a></p>
<h2>Test suite and test configuration </h2>
<p><em><a class="el" href="classrngtest_1_1_test_u01_suite.html" title="TestU01 random number generator test suite used polymorphically with Battery. ">rngtest::TestU01Suite</a></em> is configured at instantiation by selecting a TestU01 suite, one of <em><a class="el" href="classrngtest_1_1_small_crush.html" title="Class registering the TestU01 library&#39;s SmallCrush battery. ">rngtest::SmallCrush</a></em>, <em><a class="el" href="classrngtest_1_1_crush.html" title="Class registering the TestU01 library&#39;s Crush battery. ">rngtest::Crush</a></em>, or <em><a class="el" href="classrngtest_1_1_big_crush.html" title="Class registering the TestU01 library&#39;s BigCrush battery. ">rngtest::BigCrush</a></em>.</p>
<p>Since the individual statistical tests of TestU01 are very similar in structure, but have some differences, e.g., the C library function used to create the results struct, the number and type of parameters, etc., which require non-trivial initialization, i.e., function pointers and variable number of test parameters, and <em><a class="el" href="classrngtest_1_1_test_u01.html" title="TestU01 statistical test used polymorphically with rngtest::StatTest. ">rngtest::TestU01</a></em> is a Charm++ chare, the structure <em><a class="el" href="classrngtest_1_1_test_u01.html" title="TestU01 statistical test used polymorphically with rngtest::StatTest. ">rngtest::TestU01</a></em> is kept minimal, simple, and generic. This is facilitated by templating on the properties class, <em><a class="el" href="classrngtest_1_1_test_u01_props.html" title="TestU01 properties used to initialize TestU01 tests. ">rngtest::TestU01Props</a></em>, containing the configuration for a given test. Since there is a large number of tests in each <em><a class="el" href="classrngtest_1_1_test_u01.html" title="TestU01 statistical test used polymorphically with rngtest::StatTest. ">rngtest::TestU01</a></em> battery, a great amount of code can be reused by templating <em><a class="el" href="classrngtest_1_1_test_u01.html" title="TestU01 statistical test used polymorphically with rngtest::StatTest. ">rngtest::TestU01</a></em> which still inherits (in a concept-based polymorphism sense) from <em><a class="el" href="classrngtest_1_1_stat_test.html" title="Random number generator statistical test. ">rngtest::StatTest</a></em>.</p>
<p>As discussed above, there are three different dimensions of runtime polymorphism in RNGTest: (1) the RNGs, (2) the statistical tests, and (3) the test suites, all exercising concept-based polymorphism.</p>
<h2>Instantiation using factories </h2>
<p>In those cases where the instantiation of the object (i.e., which object to instantiate) depends on user input (RNGs and test suites), polymorphism is facilitated by factories. Factories are std::maps (associative containers) that hold function objects and enable lookup based on a key, e.g., an enum based on user input. Function objects are essentially smart function pointers, holding various derived-class constructors and their constructor arguments. These function pointers and their arguments (i.e., how to invoke them) are stored by std::function, but the object is not instantiated at the time it is registered into the factory. The object is instantiated after a lookup (based on a key), after which the constructor is called thereby instantiating the derived object. For RNGs this map is <em><a class="el" href="namespacetk.html#a74de56fa53c55c0a8f35b764729cdf20" title="Random number generator factory: keys associated to their constructors. ">tk::RNGFactory</a></em>, for test suites it is <em><a class="el" href="namespacerngtest.html#a27f5b52643c9bffce647cde2438d33c1" title="Battery factory type. ">rngtest::BatteryFactory</a></em>.</p>
<p>The factories are implemented using maps via either reference or value semantics. Since concept-based polymorphism enables value semantics, value semantics is used in factories whenever possible. For more information on Boost.factory, see <a href="http://www.boost.org/doc/libs/release/libs/functional/factory">http://www.boost.org/doc/libs/release/libs/functional/factory</a>.</p>
<h2>Instantiation without factories </h2>
<p>In the case when all registered objects have to be instantiated, there is no need for a factory, and the base class pointers are initialized by instantiating derived objects held in a vector. This is the case for statistical tests held by, e.g., <em>TestU01Suite</em>.</p>
<h2>Charm++ design </h2>
<p>Before porting to Charm++ RNGTest used OpenMP for concurrency. The last commit before porting to Charm++ is <a href="https://github.com/quinoacomputing/quinoa/commit/bfcab8f5">bfcab8f5</a> and the commit where the Charm++ port is fully functional is <a href="https://github.com/quinoacomputing/quinoa/commit/c504a51b">c504a51b</a>. Note that during Charm++ port of rngtest target quinoa does not fully build.</p>
<p>The discussion below details only <em>some</em> of the details encountered during the Charm++ port of RNGTest. More documentation can be found in the source code itself as well as the individual (sometimes rather lenghty) commit messages between the two commits mentioned above.</p>
<h2>Porting to Charm++ &ndash; preliminary considerations </h2>
<p>The above features, facilitating polymorphism, code reuse, e.g., factories, etc., are certainly desirable to keep in a <a href="http://charm.cs.illinois.edu">Charm++</a> port of rngtest. However, the Charm++ implementation imposes additional challenges, especially in the view of the constrains on the global-scope wrappers (used as library-external calls). Some of the following challenges have been identified <em>before</em> porting to Charm++.</p>
<ul>
<li>Global-scope trickery, especially with the polymorphic base class RNG pointers, is a challenge as any global-scope object in Charm++ must be initialized in the main chare and must be serializable so that the Charm++ runtime system can migrate them across the network. This means that the vector of base RNG pointers should be re-creatable after migration. This may also mean that its factory must also be in global scope and migratable. How to migrate std::function is a question. As it turns out Sean Parent's concept-based polymorphism (discussed above) significantly simplifies runtime polymorphism using Charm++: since polymorphism is kept internal to a non-chare class, e.g., <em><a class="el" href="classrngtest_1_1_stat_test.html" title="Random number generator statistical test. ">rngtest::StatTest</a></em>, and the client-code can use value-semantics, the "derived" class <em><a class="el" href="classrngtest_1_1_test_u01.html" title="TestU01 statistical test used polymorphically with rngtest::StatTest. ">rngtest::TestU01</a></em> chare does not need Charm++'s machinery facilitating runtime polymorphism using the PUP::able framework. Though in the final design Charm++'s runtime polymorphism is not used, a working example is in commit <a href="https://github.com/quinoacomputing/quinoa/commit/56bdcf73">56bdcf73</a>.</li>
<li>Conveniently holding references to Base is hardly an option with Charm++ objects that should be migratable. Making Base migratable is not a viable option and seems wasteful when only a small part of the data is needed by a class. Passing and storing only what's needed certainly seems like a more walkable route.</li>
<li>All migratable objects must have as little state as possible. This is for reasons of code complexity (less <a class="el" href="namespace_p_u_p.html" title="Extensions to Charm++&#39;s Pack/Unpack routines. ">PUP</a> routines to write and maintain), as well as computational cost (less data to migrate).</li>
<li>Runtime polymophism among migratable objects is possible in Charm++ via abstract classes deriving from PUP::able and wrapper chares, however, as mentioned above, this is not needed by the final design.</li>
<li>Converting each statistical test in a suite seems like the most straightforward to start with when porting to Charm++. However, class <em><a class="el" href="classrngtest_1_1_test_u01.html" title="TestU01 statistical test used polymorphically with rngtest::StatTest. ">rngtest::TestU01</a></em> currently holds some nontrivial state which requires custom <a class="el" href="namespace_p_u_p.html" title="Extensions to Charm++&#39;s Pack/Unpack routines. ">PUP</a> routines and is also polymorphic with base <em><a class="el" href="classrngtest_1_1_stat_test.html" title="Random number generator statistical test. ">rngtest::StatTest</a></em>. Furthermore, once a test was finished there should be a way to pass the control flow back to the invoking suite to evaluate the just-finished test. Does this require the suite be a chare object as well? (That is also polymorphic and holds some nontrivially migratable state.) How much does Charm++ help already with these issues? E.g., <a class="el" href="namespace_p_u_p.html" title="Extensions to Charm++&#39;s Pack/Unpack routines. ">PUP</a> routines for STL containers exist, but some are not optimal and don't use the latest C++ standard. As described below, most of these issues are eliminated by a careful design of classes with as little state as possible.</li>
</ul>
<h2>Charm++ design &ndash; overview </h2>
<p>The Charm++ design of RNGTest relies on three interacting Charm++ modules:</p>
<ol type="1">
<li><b>rngtest</b> &ndash; This is rngtest's main Charm++ module, whose interface is defined in <a class="el" href="rngtest_8ci.html">Main/rngtest.ci</a>. Beside global-scope data, this file describes the mainchare <em><a class="el" href="class_main.html" title="Charm++ main chare for the file converter executable, fileconv. ">Main</a></em> and a small helper chare, <em>execute</em>, both defined in <a class="el" href="_r_n_g_test_8_c.html" title="RNGTest&#39;s random number generator test suite&#39;s Charm++ main chare. ">Main/RNGTest.C</a>.</li>
<li><b>testu01suite</b> &ndash; This is rngtest's second Charm++ module, whose interface is defined in <a class="el" href="testu01suite_8ci.html">RNGTest/testu01suite.ci</a>. This file describes the chare <em><a class="el" href="classrngtest_1_1_test_u01_suite.html" title="TestU01 random number generator test suite used polymorphically with Battery. ">rngtest::TestU01Suite</a></em>.</li>
<li><b>testu01</b> &ndash; This is rngtest's third Charm++ module, whose interface is defined in <a class="el" href="testu01_8ci.html">RNGTest/testu01.ci</a>. This file describes the chare <em><a class="el" href="classrngtest_1_1_test_u01.html" title="TestU01 statistical test used polymorphically with rngtest::StatTest. ">rngtest::TestU01</a></em>, which is templated on the test properties, and thus lists all possible template specializations, corresponding to the various statistical tests available in the TestU01 library.</li>
</ol>
<h2>Charm++ design &ndash; Global-scope data </h2>
<p><b>Background.</b> In RNGTest both the RNGs and the statistical test suites are provided by third-party libraries. In other words, rngtest is only a glue-code that ties together the RNGs and the statistical tests. Note that neither third-party libraries (neither the test suites nor the RNGs) are aware of Charm++'s fully asynchronous nature. This constrains how the RNGs must be called by the batteries as the RNGs must be passed, as external generators, to the statistical test suites. Since the currently only supported set of batteries (TestU01) are a C library, this is done through global-scope wrappers.</p>
<p><b>Global-scope wrappers.</b> The RNGs, wrapped through the base <em><a class="el" href="classtk_1_1_r_n_g.html" title="Random number generator. ">tk::RNG</a></em> and children <em><a class="el" href="classtk_1_1_m_k_l_r_n_g.html" title="MKL-based random number generator used polymorphically with tk::RNG. ">tk::MKLRNG</a></em>, <em>tk::RNGSSERNG</em>, <em><a class="el" href="classtk_1_1_random123.html" title="Random123-based random number generator used polymorphically with tk::RNG. ">tk::Random123</a></em>, are invoked via concept-based runtime polymorphism (discussed above). While the RNGs are instantiated via <em><a class="el" href="namespacetk.html#a74de56fa53c55c0a8f35b764729cdf20" title="Random number generator factory: keys associated to their constructors. ">tk::RNGFactory</a></em> (discussed above), to be able to call any (or all) of the instantiated RNGs at the same time (to facilitate concurrency), we need as many wrappers as the maximum number of RNGs &ndash; currently 25. In principle, this requires 25 global-scope almost identical wrappers so that we can pass them into TestU01. Note that the function signature TestU01 accepts for an external generator is the same for all RNGs. Templating the global-scope wrappers on an integer, however, allows to write the wrapper only once and let the compiler generate the 25 slightly different wrappers, differing only in which polymorphic RNG needs to be called by TestU01. This requires the global-scope wrappers to rely on a global-scope vector (or map, see below) of polymorphic RNGs and a global-scope id, as the function signature TestU01 accepts does not allow this information (which RNG I want it to call from some list and which parallel stream I want the next number from). The current solution thus holds a global-scope std::map of polymorphic <em><a class="el" href="classtk_1_1_r_n_g.html" title="Random number generator. ">tk::RNG</a></em> objects (using value semantics) into which the global-scope wrappers index into (using an std::map::find) based on a C-style enum (integer) template argument. This works well enabling code-reuse. See <a class="el" href="_test_u01_wrappers_8h.html" title="TestU01 global-scope wrappers. ">RNGTest/TestU01Wrappers.h</a>. For more information on why some of this (and other) data is global-scope, see the in-code documentation in <a class="el" href="_r_n_g_test_8_c.html" title="RNGTest&#39;s random number generator test suite&#39;s Charm++ main chare. ">Main/RNGTest.C</a>.</p>
<hr/>
 <div><small> <em>Page last updated:</em> Thu 06 Apr 2017 10:43:25 AM MDT <em>Copyright 2012-2015, J. Bakosi, 2016-2018, Los Alamos National Security, LLC.</em> </small></div> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 30 2018 21:46:19 for Quinoa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
