<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>How to add a new PDE type to Inciter | Quinoa docs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="quinoa.m-dark-noindent+doxygen.compiled.css" />
  <link rel="icon" href="quinoa_sum.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Quinoa <span class="m-thin">docs</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="why.html">Why</a></li>
            <li>
              <a href="build.html">Build</a>
              <ol>
                <li><a href="git_submodules_subtrees.html">Modules</a></li>
                <li><a href="licenses.html">Libraries</a></li>
                <li><a href="build_system.html">Internals</a></li>
              </ol>
            </li>
            <li>
              <a href="https://quinoacomputing.github.io/index.html#mainpage_tools">Tools</a>
              <ol>
                <li><a href="inciter_main.html">Inciter (Compressible flow solver)</a></li>
                <li><a href="meshconv_main.html">MeshConv (Mesh format converter)</a></li>
                <li><a href="unittest_main.html">UnitTest</a></li>
              </ol>
            </li>
            <li><a href="namespaces.html">Namespaces</a></li>
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="7">
            <li>
              <a href="resources.html">Resources</a>
              <ol>
                <li><a href="https://github.com/quinoacomputing/quinoa">GitHub</a></li>
                <li><a href="papers.html">Publications</a></li>
                <li><a href="https://github.com/quinoacomputing/quinoa/blob/master/LICENSE">License</a></li>
                <li><a href="roadmap.html">Roadmap</a></li>
                <li><a href="contributing.html">Contributing</a></li>
                <li><a href="coverage.html">Coverage</a></li>
                <li><a href="https://github.com/quinoacomputing/quinoa/releases">Tarballs</a></li>
                <li><a href="https://bestpractices.coreinfrastructure.org/projects/2120">Practices</a></li>
              </ol>
            </li>
            <li class="m-show-m"><a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          How to add a new PDE type to Inciter
        </h1>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li><a href="#inciter_newpde_rationale">Rationale and plan</a></li>
            <li><a href="#inciter_newpde_input">1. Specification of a PDE in the input file</a></li>
            <li>
              <a href="#inciter_newpde_keyword">2. Add new keywords</a>
              <ul>
                <li><a href="#inciter_newpde_keyword_Keywords">Control/Keywords.hpp</a></li>
                <li><a href="#inciter_newpde_keyword_InputDeck">Control/Inciter/InputDeck/InputDeck.hpp</a></li>

              </ul>
            </li>
            <li>
              <a href="#inciter_newpde_option">3. Add new option switches</a>
              <ul>
                <li><a href="#inciter_newpde_keyword_PDEOptions">Control/Inciter/Options/PDE.hpp</a></li>
                <li><a href="#inciter_newpde_keyword_PhysicsOptions">Control/Inciter/Options/Physics.hpp</a></li>
                <li><a href="#inciter_newpde_keyword_ProblemOptions">Control/Inciter/Options/Problem.hpp</a></li>

              </ul>
            </li>
            <li>
              <a href="#inciter_newpde_grammar">4. Add parsing/grammar for the new keywords</a>
              <ul>
                <li><a href="#inciter_newpde_grammar_components">Control/Inciter/Components.hpp</a></li>
                <li><a href="#inciter_newpde_grammar_types">Control/Inciter/Types.hpp</a></li>
                <li><a href="#inciter_newpde_grammar_tags">Control/Tags.hpp</a></li>
                <li><a href="#inciter_newpde_grammar_grammar">Control/Inciter/InputDeck/Grammar.hpp</a></li>
                <li><a href="#inciter_newpde_grammar_common">Control/CommonGrammar.hpp</a></li>

              </ul>
            </li>
            <li>
              <a href="#inciter_newpde_pdestack">5. Augment the PDE stack</a>
              <ul>
                <li><a href="#inciter_newpde_pdestack_pdestack">PDE/PDEStack.cpp</a></li>

              </ul>
            </li>
            <li>
              <a href="#inciter_newpde_buildsystem">6. Augment the PDE build object</a>
              <ul>
                <li><a href="#inciter_newpde_cmake">PDE/CMakeLists.txt</a></li>

              </ul>
            </li>
            <li><a href="#inciter_newpde_skeletons">7. New skeleton PDE classes</a></li>
          </ul>
        </div>
<p>This page describes how to add a new PDE type to <a href="inciter_main.html" class="m-dox">Inciter (Compressible flow solver)</a>.</p><p><a href="inciter_main.html" class="m-dox">Inciter (Compressible flow solver)</a> supports multiple partial differential equation (PDE) types. At the time this was written, there were two PDE types: <code>Transport</code> and <code>CompFlow</code>. The former is specialized to solving transport equations of single or multiple independent scalars, governed by a set of independent advection-diffusion equations, while the latter is specialized to solving the Euler and Navier-Stokes equations for single-material compressible ideal gases. The simplest way to learn about the currently implemented PDE types and how their source is organized into directories and files is to do</p><pre class="m-code"><span class="n">cd</span> <span class="o">&lt;</span><span class="n">quinoa</span><span class="o">&gt;/</span><span class="n">src</span><span class="o">/</span><span class="n">PDE</span>
<span class="n">tree</span></pre><p>which at this time gives</p><pre class="m-console">.
├── CGPDE.hpp
├── CMakeLists.txt
├── CompFlow
│   ├── CGCompFlow.hpp
│   ├── DGCompFlow.hpp
│   ├── Physics
│   │   ├── CGEuler.hpp
│   │   ├── CG.hpp
│   │   ├── CGNavierStokes.hpp
│   │   ├── DGEuler.hpp
│   │   ├── DG.hpp
│   │   └── DGNavierStokes.hpp
│   ├── Problem
│   │   ├── NLEnergyGrowth.hpp
│   │   ├── RayleighTaylor.hpp
│   │   ├── SedovBlastwave.hpp
│   │   ├── SodShocktube.hpp
│   │   ├── TaylorGreen.hpp
│   │   ├── UserDefined.hpp
│   │   └── VorticalFlow.hpp
│   └── Problem.hpp
├── ConfigureCompFlow.cpp
├── ConfigureCompFlow.hpp
├── ConfigureTransport.cpp
├── ConfigureTransport.hpp
├── DGPDE.hpp
├── FunctionPrototypes.hpp
├── Integrate
│   ├── Boundary.cpp
│   ├── Boundary.hpp
│   ├── Initialize.cpp
│   ├── Initialize.hpp
│   ├── Mass.cpp
│   ├── Mass.hpp
│   ├── Quadrature.cpp
│   ├── Quadrature.hpp
│   ├── Riemann
│   │   ├── HLLC.hpp
│   │   ├── LaxFriedrichs.hpp
│   │   ├── RiemannFactory.cpp
│   │   ├── RiemannFactory.hpp
│   │   ├── RiemannSolver.hpp
│   │   └── Upwind.hpp
│   ├── Source.cpp
│   ├── Source.hpp
│   ├── Surface.cpp
│   ├── Surface.hpp
│   ├── Volume.cpp
│   └── Volume.hpp
├── Limiter.cpp
├── Limiter.hpp
├── PDEFactory.hpp
├── PDEStack.cpp
├── PDEStack.hpp
└── Transport
    ├── CGTransport.hpp
    ├── DGTransport.hpp
    ├── Physics
    │   ├── CGAdvDiff.hpp
    │   ├── CGAdvection.hpp
    │   ├── CG.hpp
    │   ├── DGAdvection.hpp
    │   └── DG.hpp
    ├── Problem
    │   ├── CylAdvect.hpp
    │   ├── GaussHump.hpp
    │   ├── ShearDiff.hpp
    │   └── SlotCyl.hpp
    └── Problem.hpp

8 directories, 61 files</pre><p>Once can see separate directories for <code>CompFlow</code> and <code>Transport</code>, each with subdirectories <code>Physics</code> and <code>Problem</code>. For example, two PDE classes are implemented under <code>CompFlow</code>: <code>CGCompFlow</code> and <code>DGCompFlow</code>, using continuous and discoontinuous Galerkin finite element (<code>CG</code>, <code><a href="classinciter_1_1_d_g.html" class="m-dox">DG</a></code>) discretizations, respectively,</p><p>This page describes how to add a new PDE, such as <code>Transport</code> or <code>CompFlow</code>.</p><section id="inciter_newpde_rationale"><h2><a href="#inciter_newpde_rationale">Rationale and plan</a></h2><p>This page will discuss how to add a new PDE type by adding one for multi-material compressible flow using a <code><a href="classinciter_1_1_d_g.html" class="m-dox">DG</a></code> finite element discretization. We will explain how and where to create the new files for the PDE class, its <code>Physics</code> and <code>Problem</code> policy classes, and how to define these so that the existing discontinuous Galerkin integration driver class, <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a>, can drive it , potentially coupled to other existing and future <code><a href="classinciter_1_1_d_g.html" class="m-dox">DG</a></code> systems. The new PDE type will be instantiated from a factory based on user input, similar to the existing PDE types. What will <em>not</em> be described are the details of the implementation of the discretization of the newly added equation system and its algoritm. We describe how to create a skeleton PDE type in the existing framework and how to build on the existing software infrastructure that supports such a new algorithm, e.g., user input, mesh I/O, partitioning using over-decomposition, automatic load balancing via migration, etc.</p></section><section id="inciter_newpde_input"><h2><a href="#inciter_newpde_input">1. Specification of a PDE in the input file</a></h2><p>A PDE type, or more precisely, a PDE <em>system</em> is selected by the user via specifying a PDE-block in the <a href="inciter_main.html" class="m-dox">Inciter (Compressible flow solver)</a> input file. An example, configuring the existing <code>CompFlow</code> PDE is given by a <code>compflow...end</code> block,</p><pre class="m-code">inciter
  ...
  scheme dg
  ...
  compflow
    depvar u    <span class="c1"># assign dependent variable &#39;u&#39; to this PDE</span>
    physics euler       <span class="c1"># select &#39;euler&#39; as compressible flow physics policy</span>
    problem vortical_flow  <span class="c1"># select &#39;vortical_flow` as problem policy</span>
    ...
  end
  ...
end</pre><p>This is a snippet, configuring inciter to compute a single PDE system governing compressible flow. Every PDE type is configured via a physics and a problem policy. Here the physics is <code>euler</code>, configuring the solution of the Euler equations for inviscid flow, and the problem is <code>vortical_flow</code>. Since the analytical solution is known for this specific case, it can be used to verify the correctness of the implementation of the algorithm and the order of accuracy of the numerical method.</p><p>The important parts of this specification are the following.</p><ol><li>A new block configures a particular PDE system, such as <code>compflow...end</code>. There can be multiple such PDE-blocks specified, which then will be integrated together in an unsplit strongly-coupled fashion, e.g, <code>compflow</code> + <code>transport</code> with, say, 12 scalar components, which then together will comprise a system of 17 coupled scalar equations.</li><li>The PDE must be specialized with a selected <code>physics</code> type. In the example above this is <code>euler</code>, but this is only the simplest choice. Every PDE has a default physics which is selected if no physics is specified.</li><li>The PDE must be specialized with a selected <code>problem</code> type. In the example above this is <code>vortical_flow</code>, but this is only one choice. Every PDE has a default problem which is selected if no problem is specified.</li><li>The <code>depvar</code> keyword specifies the dependent variable by a single character that is used within the input file to refer to a particular PDE system. Note that there can be multiple PDE blocks specified with the same or different types, but their <code>depvar</code> must be unique. This <code>depvar</code> then may be used downstream of its specification to configure a scalar component of a given PDE to be used as a <em>refinement variable</em> as error indicator for adaptive refinement.</li></ol></section><section id="inciter_newpde_keyword"><h2><a href="#inciter_newpde_keyword">2. Add new keywords</a></h2><p>To add a new PDE type, we start by adding a new keyword that will be used to designate it in the input file. Since the new PDE is for methods specifialized for multi-material compressible flow, we add a new keyword <code>multimat</code>. We also add a new keyword for a new <code>physics</code> policy, <code>veleq</code>, to designate an important feature of the new method to be implemented, <em>velocity equilibrium</em>, assuming a single velocity field for all materials, while solving for separate material fields for mass and internal energy. Another new keyword we add is <code>nmat</code> which will be used to specify the number of materials for a multi-material flow. We also a new keyword for a problem type, <code>interface_advection</code>. New keyword definitions with their documentation go to src/Control/Keywords.h.pp</p><section id="inciter_newpde_keyword_Keywords"><h3><a href="#inciter_newpde_keyword_Keywords">Control/Keywords.hpp</a></h3><pre class="m-code">git diff src/Control/Keywords.hpp
<span class="gh">diff --git a/src/Control/Keywords.hpp b/src/Control/Keywords.hpp</span>
<span class="gh">index b3fbcebd..c57c65ce 100644</span>
<span class="gd">--- a/src/Control/Keywords.hpp</span>
<span class="gi">+++ b/src/Control/Keywords.hpp</span>
<span class="gu">@@ -1727,6 +1727,23 @@ struct ncomp_info {</span>
 };
 using ncomp = keyword&lt; ncomp_info,  TAOCPP_PEGTL_STRING(&quot;ncomp&quot;) &gt;;
 
<span class="gi">+struct nmat_info {</span>
<span class="gi">+  static std::string name() { return &quot;nmat&quot;; }</span>
<span class="gi">+  static std::string shortDescription() { return</span>
<span class="gi">+    &quot;Set number of materials for a system of differential equations&quot;; }</span>
<span class="gi">+  static std::string longDescription() { return</span>
<span class="gi">+    R&quot;(This keyword is used to specify the number of materials, e.g., for</span>
<span class="gi">+    multi-material flow, see also the keyword &#39;multimat&#39; and &#39;veleq&#39;.)&quot;;</span>
<span class="gi">+  }</span>
<span class="gi">+  struct expect {</span>
<span class="gi">+    using type = std::size_t;</span>
<span class="gi">+    static constexpr type lower = 1;</span>
<span class="gi">+    static std::string description() { return &quot;uint&quot;; }</span>
<span class="gi">+  };</span>
<span class="gi">+};</span>
<span class="gi">+using nmat = keyword&lt; nmat_info,  TAOCPP_PEGTL_STRING(&quot;nmat&quot;) &gt;;</span>
<span class="gi">+</span>
 struct ttyi_info {
   static std::string name() { return &quot;ttyi&quot;; }
   static std::string shortDescription() { return
<span class="gu">@@ -3769,6 +3786,23 @@ struct euler_info {</span>
 };
 using euler = keyword&lt; euler_info, TAOCPP_PEGTL_STRING(&quot;euler&quot;) &gt;;
 
<span class="gi">+struct veleq_info {</span>
<span class="gi">+  using code = Code&lt; V &gt;;</span>
<span class="gi">+  static std::string name() { return &quot;Velocity equilibrium&quot;; }</span>
<span class="gi">+  static std::string shortDescription() { return &quot;Specify the multi-material &quot;</span>
<span class="gi">+    &quot; compressible flow with velocity equilibrium as physics configuration&quot;; }</span>
<span class="gi">+  static std::string longDescription() { return</span>
<span class="gi">+    R&quot;(This keyword is used to select a compressible flow algorithm as physics</span>
<span class="gi">+    configuration designed for multiple materials assuming velocity equailibrium</span>
<span class="gi">+    (single velocity). Example: &quot;multimat physics veleq end&quot;)&quot;;</span>
<span class="gi">+    }</span>
<span class="gi">+  struct expect {</span>
<span class="gi">+    static std::string description() { return &quot;string&quot;; }</span>
<span class="gi">+  };</span>
<span class="gi">+};</span>
<span class="gi">+using veleq = keyword&lt; veleq_info, TAOCPP_PEGTL_STRING(&quot;veleq&quot;) &gt;;</span>
<span class="gi">+</span>
 struct advection_info {
   using code = Code&lt; A &gt;;
   static std::string name() { return &quot;Advection&quot;; }
<span class="gu">@@ -4368,6 +4402,41 @@ struct compflow_info {</span>
 };
 using compflow = keyword&lt; compflow_info, TAOCPP_PEGTL_STRING(&quot;compflow&quot;) &gt;;
 
<span class="gi">+struct multimat_info {</span>
<span class="gi">+  static std::string name() { return &quot;Compressible multi-material flow&quot;; }</span>
<span class="gi">+  static std::string shortDescription() { return &quot;Start configuration block &quot;</span>
<span class="gi">+    &quot;for the multi-material compressible flow equations&quot;; }</span>
<span class="gi">+  static std::string longDescription() { return</span>
<span class="gi">+    R&quot;(This keyword is used to introduce the multimat ... end block,</span>
<span class="gi">+    used to specify the configuration for a system of partial differential</span>
<span class="gi">+    equations, governing multi-material compressible fluid flow. Keywords</span>
<span class="gi">+    allowed in a multimat ... end block: )&quot; + std::string(&quot;\&#39;&quot;)</span>
<span class="gi">+    + depvar::string()+ &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + physics::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + problem::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + material::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + nmat::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + pde_alpha::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + pde_p0::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + pde_betax::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + pde_betay::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + pde_betaz::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + pde_beta::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + pde_r0::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + pde_ce::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + pde_kappa::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + bc_dirichlet::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + bc_sym::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + bc_inlet::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + bc_outlet::string() + &quot;\&#39;, \&#39;&quot;</span>
<span class="gi">+    + bc_extrapolate::string() + &quot;\&#39;. &quot;</span>
<span class="gi">+    + R&quot;(For an example multimat ... end block, see</span>
<span class="gi">+      doc/html/inicter_example_multimat.html.)&quot;;</span>
<span class="gi">+  }</span>
<span class="gi">+};</span>
<span class="gi">+using multimat = keyword&lt; multimat_info, TAOCPP_PEGTL_STRING(&quot;multimat&quot;) &gt;;</span>
<span class="gi">+</span>
<span class="gi">+struct interface_advection_info {</span>
<span class="gi">+  using code = Code&lt; I &gt;;</span>
<span class="gi">+  static std::string name() { return &quot;Interface advection&quot;; }</span>
<span class="gi">+  static std::string shortDescription() { return</span>
<span class="gi">+    &quot;Select the interface advection test problem &quot;; }</span>
<span class="gi">+  static std::string longDescription() { return</span>
<span class="gi">+    R&quot;(This keyword is used to select the interface advection test problem. The</span>
<span class="gi">+    purpose of this test problem is to test the well-balancedness of the</span>
<span class="gi">+    multi-material discretization and its interface capturing</span>
<span class="gi">+    capabilities. Example: &quot;problem interface_advection&quot;.)&quot;; }</span>
<span class="gi">+  struct expect {</span>
<span class="gi">+    static std::string description() { return &quot;string&quot;; }</span>
<span class="gi">+  };</span>
<span class="gi">+};</span>
<span class="gi">+using interface_advection =</span>
<span class="gi">+  keyword&lt; interface_advection_info,</span>
<span class="gi">+           TAOCPP_PEGTL_STRING(&quot;interface_advection&quot;) &gt;;</span>
<span class="gi">+</span>
 struct rcb_info {
   static std::string name() { return &quot;recursive coordinate bisection&quot;; }
   static std::string shortDescription() { return</pre><p>For more details on the various (mandatory and optional) fields of a keyword specification struct see the documentation in <a href="_keywords_8hpp.html" class="m-dox">src/<wbr />Control/<wbr />Keywords.hpp</a>.</p><p>We also add the new keywords to inciter&#x27;s grammar&#x27;s keywords pool:</p></section><section id="inciter_newpde_keyword_InputDeck"><h3><a href="#inciter_newpde_keyword_InputDeck">Control/Inciter/InputDeck/InputDeck.hpp</a></h3><pre class="m-code">git diff src/Control/Inciter/InputDeck/InputDeck.hpp 
<span class="gh">diff --git a/src/Control/Inciter/InputDeck/InputDeck.hpp b/src/Control/Inciter/InputDeck/InputDeck.hpp</span>
<span class="gh">index 39eff786..155c47dc 100644</span>
<span class="gd">--- a/src/Control/Inciter/InputDeck/InputDeck.hpp</span>
<span class="gi">+++ b/src/Control/Inciter/InputDeck/InputDeck.hpp</span>
<span class="gu">@@ -70,12 +70,14 @@ class InputDeck :</span>
                                    kw::phg,
                                    kw::inciter,
                                    kw::ncomp,
<span class="gi">+                                   kw::nmat,</span>
                                    kw::pde_diffusivity,
                                    kw::pde_lambda,
                                    kw::pde_u0,
                                    kw::bc_dirichlet,
                                    kw::sideset,
                                    kw::compflow,
<span class="gi">+                                   kw::multimat,</span>
                                    kw::ic,
                                    kw::txt_float_format,
                                    kw::txt_float_default,
<span class="gu">@@ -95,6 +97,7 @@ class InputDeck :</span>
                                    kw::advdiff,
                                    kw::navierstokes,
                                    kw::euler,
<span class="gi">+                                   kw::veleq,</span>
                                    kw::user_defined,
                                    kw::vortical_flow,
<span class="gi">+                                   kw::interface_advection,</span>
                                    kw::pde_alpha,</pre><p>This is required so that the compiler can generate a database containing the help for all the keywords in the grammar understood by inciter&#x27;s control file parser. The above changes not only add the keyword but also some documentation that gets displayed when passing the <code>-C</code> or <code>-H</code> command line arguments to the inciter executable, so quick help is available at the user&#x27;s fingertips:</p><pre class="m-console">$ inciter -C
inciter Control File Keywords:
...
   multimat              Start configuration block for the multi-material compressible flow equations
        navierstokes     string Specify the Navier-Stokes (viscous) compressible flow physics configuration
               ncomp       uint Set number of scalar components for a system of differential equations
    nl_energy_growth     string Select the nonlinear energy growth test problem 
                nmat       uint Set number of materials for a system of differential equations
...
$ inciter -H multimat
inciter control file keyword &#39;multimat&#39;

   Start configuration block for the multi-material compressible flow equations

   This keyword is used to introduce the multimat ... end block, used to specify
   the configuration for a system of partial differential equations, governing
   multi-material compressible fluid flow. Keywords allowed in a multimat ... end
   block: &#39;depvar&#39;, &#39;physics&#39;, &#39;problem&#39;, &#39;material&#39;, &#39;nmat&#39;, &#39;alpha&#39;, &#39;p0&#39;,
   &#39;betax&#39;, &#39;betay&#39;, &#39;betaz&#39;, &#39;beta&#39;, &#39;r0&#39;, &#39;ce&#39;, &#39;kappa&#39;, &#39;bc_dirichlet&#39;,
   &#39;bc_sym&#39;, &#39;bc_inlet&#39;, &#39;bc_outlet&#39;, &#39;bc_extrapolate&#39;.For an example multimat ...
   end block, see doc/html/inicter_example_multimat.html.</pre></section></section><section id="inciter_newpde_option"><h2><a href="#inciter_newpde_option">3. Add new option switches</a></h2><p>Next is to add a new state to the existing PDE option switch, <a href="classinciter_1_1ctr_1_1_p_d_e.html" class="m-dox">ctr::<wbr />PDE</a>. This &quot;option switch&quot; is really only a fancy enum, used to store the user&#x27;s choice of the PDE type in a type-safe manner, after parsing a PDE-block, e.g., <code>compflow ... end</code>, in the control file. This fancy enum is an option switch because it inherits from <a href="classtk_1_1_toggle.html" class="m-dox">tk::<wbr />Toggle</a>, defined in <a href="_toggle_8hpp.html" class="m-dox">Control/<wbr />Toggle.hpp</a>, which is a generic switch (or option), that helps associating enum values to keywords and querying one based on the other. Extending the existing PDE option switch is done by extending the list of PDE types in <code><a href="_p_d_e_8hpp.html" class="m-dox">src/<wbr />Control/<wbr />Inciter/<wbr />Options/<wbr />PDE.hpp</a></code>:</p><section id="inciter_newpde_keyword_PDEOptions"><h3><a href="#inciter_newpde_keyword_PDEOptions">Control/Inciter/Options/PDE.hpp</a></h3><pre class="m-code">git diff src/Control/Inciter/Options/PDE.hpp
<span class="gh">diff --git a/src/Control/Inciter/Options/PDE.hpp b/src/Control/Inciter/Options/PDE.hpp</span>
<span class="gh">index 2b4af067..84b6d3ff 100644</span>
<span class="gd">--- a/src/Control/Inciter/Options/PDE.hpp</span>
<span class="gi">+++ b/src/Control/Inciter/Options/PDE.hpp</span>
<span class="gu">@@ -22,7 +22,8 @@ namespace ctr {</span>
 
 //! Differential equation types
 enum class PDEType : uint8_t { TRANSPORT=0,
<span class="gd">-                               COMPFLOW };</span>
<span class="gi">+                               COMPFLOW,</span>
<span class="gi">+                               MULTIMAT };</span>
 
 //! Pack/Unpack: forward overload to generic enum class packer
 inline void operator|( PUP::er&amp; p, PDEType&amp; e ) { PUP::pup( p, e ); }
<span class="gu">@@ -40,6 +41,7 @@ class PDE : public tk::Toggle&lt; PDEType &gt; {</span>
     // List valid expected choices to make them also available at compile-time
     using keywords = brigand::list&lt; kw::transport
                                   , kw::compflow
<span class="gi">+                                  , kw::multimat</span>
                                   &gt;;
 
     //! Constructor: pass associations references to base, which will handle
<span class="gu">@@ -48,10 +50,12 @@ class PDE : public tk::Toggle&lt; PDEType &gt; {</span>
       tk::Toggle&lt; PDEType &gt;( &quot;Partial differential equation&quot;,
         //! Enums -&gt; names
         { { PDEType::TRANSPORT, kw::transport::name() },
<span class="gd">-          { PDEType::COMPFLOW, kw::compflow::name() } },</span>
<span class="gi">+          { PDEType::COMPFLOW, kw::compflow::name() },</span>
<span class="gi">+          { PDEType::MULTIMAT, kw::multimat::name() } },</span>
         //! keywords -&gt; Enums
         { { kw::transport::string(), PDEType::TRANSPORT },
<span class="gd">-          { kw::compflow::string(), PDEType::COMPFLOW } } ) {}</span>
<span class="gi">+          { kw::compflow::string(), PDEType::COMPFLOW },</span>
<span class="gi">+          { kw::multimat::string(), PDEType::MULTIMAT } } ) {}</span>
 };
 
 } // ctr::</pre><p>We also augment the switch used for selecting the physics policy and problem list:</p></section><section id="inciter_newpde_keyword_PhysicsOptions"><h3><a href="#inciter_newpde_keyword_PhysicsOptions">Control/Inciter/Options/Physics.hpp</a></h3><pre class="m-code">git diff src/Control/Inciter/Options/Physics.hpp
<span class="gh">diff --git a/src/Control/Inciter/Options/Physics.hpp b/src/Control/Inciter/Options/Physics.hpp</span>
<span class="gh">index d24ccf1d..f59e85c1 100644</span>
<span class="gd">--- a/src/Control/Inciter/Options/Physics.hpp</span>
<span class="gi">+++ b/src/Control/Inciter/Options/Physics.hpp</span>
<span class="gu">@@ -23,7 +23,8 @@ namespace ctr {</span>
 enum class PhysicsType : uint8_t { ADVECTION=0,
                                    ADVDIFF,
                                    EULER,
<span class="gd">-                                   NAVIERSTOKES };</span>
<span class="gi">+                                   NAVIERSTOKES,</span>
<span class="gi">+                                   VELEQ };</span>
 
 //! Pack/Unpack PhysicsType: forward overload to generic enum class packer
 inline void operator|( PUP::er&amp; p, PhysicsType&amp; e ) { PUP::pup( p, e ); }
<span class="gu">@@ -35,8 +36,9 @@ class Physics : public tk::Toggle&lt; PhysicsType &gt; {</span>
     //! Valid expected choices to make them also available at compile-time
     using keywords = brigand::list&lt; kw::advection
                                   , kw::advdiff
<span class="gd">-                                  , kw::navierstokes</span>
                                   , kw::euler
<span class="gi">+                                  , kw::navierstokes</span>
<span class="gi">+                                  , kw::veleq</span>
                                   &gt;;
 
     //! \brief Options constructor
<span class="gu">@@ -50,12 +52,16 @@ class Physics : public tk::Toggle&lt; PhysicsType &gt; {</span>
         { { PhysicsType::ADVECTION, kw::advection::name() },
           { PhysicsType::ADVDIFF, kw::advdiff::name() },
           { PhysicsType::EULER, kw::euler::name() },
<span class="gd">-          { PhysicsType::NAVIERSTOKES, kw::navierstokes::name() } },</span>
<span class="gi">+          { PhysicsType::NAVIERSTOKES, kw::navierstokes::name() },</span>
<span class="gi">+          { PhysicsType::VELEQ, kw::veleq::name() }</span>
<span class="gi">+        },</span>
         //! keywords -&gt; Enums
         { { kw::advection::string(), PhysicsType::ADVECTION },
           { kw::advdiff::string(), PhysicsType::ADVDIFF },
           { kw::euler::string(), PhysicsType::EULER },
<span class="gd">-          { kw::navierstokes::string(), PhysicsType::NAVIERSTOKES } } )</span>
<span class="gi">+          { kw::navierstokes::string(), PhysicsType::NAVIERSTOKES },</span>
<span class="gi">+          { kw::veleq::string(), PhysicsType::VELEQ } } )</span>
     {
        brigand::for_each&lt; keywords &gt;( assertPolicyCodes() );
     }
<span class="gu">@@ -89,6 +95,7 @@ class Physics : public tk::Toggle&lt; PhysicsType &gt; {</span>
       , { PhysicsType::ADVDIFF, *kw::advdiff::code() }
       , { PhysicsType::EULER, *kw::euler::code() }
       , { PhysicsType::NAVIERSTOKES, *kw::navierstokes::code() }
<span class="gi">+      , { PhysicsType::VELEQ, *kw::veleq::code() }</span>
     };
 };</pre></section><section id="inciter_newpde_keyword_ProblemOptions"><h3><a href="#inciter_newpde_keyword_ProblemOptions">Control/Inciter/Options/Problem.hpp</a></h3><pre class="m-code"><span class="gh">diff --git a/src/Control/Inciter/Options/Problem.hpp b/src/Control/Inciter/Options/Problem.hpp</span>
<span class="gh">index c953f28f0..b21e2c891 100644</span>
<span class="gd">--- a/src/Control/Inciter/Options/Problem.hpp</span>
<span class="gi">+++ b/src/Control/Inciter/Options/Problem.hpp</span>
<span class="gu">@@ -34,7 +34,8 @@ enum class ProblemType : uint8_t { USER_DEFINED,</span>
                                    CYL_ADVECT,
                                    SOD_SHOCKTUBE,
                                    ROTATED_SOD_SHOCKTUBE,
<span class="gd">-                                   SEDOV_BLASTWAVE };</span>
<span class="gi">+                                   SEDOV_BLASTWAVE,</span>
<span class="gi">+                                   INTERFACE_ADVECTION };</span>
 
 //! Pack/Unpack ProblemType: forward overload to generic enum class packer
 inline void operator|( PUP::er&amp; p, ProblemType&amp; e ) { PUP::pup( p, e ); }
<span class="gu">@@ -56,6 +57,7 @@ class Problem : public tk::Toggle&lt; ProblemType &gt; {</span>
                                   , kw::sod_shocktube
                                   , kw::rotated_sod_shocktube
                                   , kw::sedov_blastwave
<span class="gi">+                                  , kw::interface_advection</span>
                                   &gt;;
 
     //! \brief Options constructor
<span class="gu">@@ -78,7 +80,9 @@ class Problem : public tk::Toggle&lt; ProblemType &gt; {</span>
           { ProblemType::SOD_SHOCKTUBE, kw::sod_shocktube::name() },
           { ProblemType::ROTATED_SOD_SHOCKTUBE,
             kw::rotated_sod_shocktube::name() },
<span class="gd">-          { ProblemType::SEDOV_BLASTWAVE, kw::sedov_blastwave::name() } },</span>
<span class="gi">+          { ProblemType::SEDOV_BLASTWAVE, kw::sedov_blastwave::name() },</span>
<span class="gi">+          { ProblemType::INTERFACE_ADVECTION,</span>
<span class="gi">+            kw::interface_advection::name() } },</span>
         //! keywords -&gt; Enums
         { { kw::user_defined::string(), ProblemType::USER_DEFINED },
           { kw::shear_diff::string(), ProblemType::SHEAR_DIFF },
<span class="gu">@@ -93,7 +97,9 @@ class Problem : public tk::Toggle&lt; ProblemType &gt; {</span>
           { kw::rotated_sod_shocktube::string(),
             ProblemType::ROTATED_SOD_SHOCKTUBE },
           { kw::sod_shocktube::string(), ProblemType::SOD_SHOCKTUBE },
<span class="gd">-          { kw::sedov_blastwave::string(), ProblemType::SEDOV_BLASTWAVE } } )</span>
<span class="gi">+          { kw::sedov_blastwave::string(), ProblemType::SEDOV_BLASTWAVE },</span>
<span class="gi">+          { kw::interface_advection::string(),</span>
<span class="gi">+            ProblemType::INTERFACE_ADVECTION } } )</span>
     {
        brigand::for_each&lt; keywords &gt;( assertPolicyCodes() );
     }
<span class="gu">@@ -136,6 +142,7 @@ class Problem : public tk::Toggle&lt; ProblemType &gt; {</span>
       , { ProblemType::ROTATED_SOD_SHOCKTUBE,
           *kw::rotated_sod_shocktube::code() }
       , { ProblemType::SEDOV_BLASTWAVE, *kw::sedov_blastwave::code() }
<span class="gi">+      , { ProblemType::INTERFACE_ADVECTION, *kw::interface_advection::code() }</span>
     };
 };</pre></section></section><section id="inciter_newpde_grammar"><h2><a href="#inciter_newpde_grammar">4. Add parsing/grammar for the new keywords</a></h2><p>After adding the new keywords <code>multimat</code>, <code>nmat</code>, and <code>veleq</code>, we have to teach the input file parser to recognize them.</p><p>First we augment the data structures that store data parsed associated with the new keywords. First is the number of scalar components for each PDE type:</p><section id="inciter_newpde_grammar_components"><h3><a href="#inciter_newpde_grammar_components">Control/Inciter/Components.hpp</a></h3><pre class="m-code">git diff src/Control/Inciter/Components.hpp
<span class="gh">diff --git a/src/Control/Inciter/Components.hpp b/src/Control/Inciter/Components.hpp</span>
<span class="gh">index 64f0696f..ef51a9e9 100644</span>
<span class="gd">--- a/src/Control/Inciter/Components.hpp</span>
<span class="gi">+++ b/src/Control/Inciter/Components.hpp</span>
<span class="gu">@@ -17,8 +17,9 @@ namespace ctr {</span>
 
 //! Number of components of partial differential equations
 using ncomps = tk::ctr::ncomponents&lt;
<span class="gd">-  tag::compflow,     std::vector&lt; tk::ctr::ncomp_type &gt;</span>
<span class="gi">+  tag::compflow,     std::vector&lt; tk::ctr::ncomp_type &gt;,</span>
<span class="gi">+  tag::multimat,     std::vector&lt; tk::ctr::ncomp_type &gt;</span>
 &gt;;
 
 } // ctr::</pre><p><a href="classtk_1_1ctr_1_1ncomponents.html" class="m-dox">tk::<wbr />ctr::<wbr />ncomponents</a> is a tuple of vectors that stores the number of scalar components for each PDE type parsed. It is a vector for each PDE type because there can be multiple PDE systems of each type.</p><p>We also create a new tuple to store data during parsing the <code>multimat...end</code> block:</p></section><section id="inciter_newpde_grammar_types"><h3><a href="#inciter_newpde_grammar_types">Control/Inciter/Types.hpp</a></h3><pre class="m-code">git diff src/Control/Inciter/Types.hpp
<span class="gh">index 4bc3bf64..65a3235f 100644</span>
<span class="gd">--- a/src/Control/Inciter/Types.hpp</span>
<span class="gi">+++ b/src/Control/Inciter/Types.hpp</span>
<span class="gu">@@ -184,10 +184,46 @@ using CompFlowPDEParameters = tk::tuple::tagged_tuple&lt;</span>
   tag::npar,          std::vector&lt; kw::npar::info::expect::type &gt;
 &gt;;
 
<span class="gi">+//! Compressible flow equation parameters storage</span>
<span class="gi">+using MultiMatPDEParameters = tk::tuple::tagged_tuple&lt;</span>
<span class="gi">+  tag::depvar,        std::vector&lt; char &gt;,</span>
<span class="gi">+  tag::physics,       std::vector&lt; PhysicsType &gt;,</span>
<span class="gi">+  tag::problem,       std::vector&lt; ProblemType &gt;,</span>
<span class="gi">+  tag::bcdir,         std::vector&lt; std::vector&lt;</span>
<span class="gi">+                       kw::sideset::info::expect::type &gt; &gt;,</span>
<span class="gi">+  tag::bcsym,         std::vector&lt; std::vector&lt;</span>
<span class="gi">+                       kw::sideset::info::expect::type &gt; &gt;,</span>
<span class="gi">+  tag::bcinlet,       std::vector&lt; std::vector&lt;</span>
<span class="gi">+                        kw::sideset::info::expect::type &gt; &gt;,</span>
<span class="gi">+  tag::bcoutlet,      std::vector&lt; std::vector&lt;</span>
<span class="gi">+                        kw::sideset::info::expect::type &gt; &gt;,</span>
<span class="gi">+  tag::bcextrapolate, std::vector&lt; std::vector&lt;</span>
<span class="gi">+                         kw::sideset::info::expect::type &gt; &gt;,</span>
<span class="gi">+  //! Parameter vector (for specific, e.g., verification problems)</span>
<span class="gi">+  tag::alpha,         std::vector&lt; kw::pde_alpha::info::expect::type &gt;,</span>
<span class="gi">+  //! Parameter vector (for specific, e.g., verification problems)</span>
<span class="gi">+  tag::beta,          std::vector&lt; kw::pde_beta::info::expect::type &gt;,</span>
<span class="gi">+  //! Parameter vector (for specific, e.g., verification problems)</span>
<span class="gi">+  tag::p0,            std::vector&lt; kw::pde_p0::info::expect::type &gt;,</span>
<span class="gi">+  //! Material ID</span>
<span class="gi">+  tag::id,            std::vector&lt; kw::id::info::expect::type &gt;,</span>
<span class="gi">+  //! Ratio of spec heats</span>
<span class="gi">+  tag::gamma,         std::vector&lt; kw::mat_gamma::info::expect::type &gt;,</span>
<span class="gi">+  //! Dynamic viscosity</span>
<span class="gi">+  tag::mu,            std::vector&lt; kw::mat_mu::info::expect::type &gt;,</span>
<span class="gi">+  //! Spec. heat at const vol.</span>
<span class="gi">+  tag::cv,            std::vector&lt; kw::mat_cv::info::expect::type &gt;,</span>
<span class="gi">+  //! Heat conductivity</span>
<span class="gi">+  tag::k,             std::vector&lt; kw::mat_k::info::expect::type &gt;,</span>
<span class="gi">+  //! number of materials</span>
<span class="gi">+  tag::nmat,          std::vector&lt; kw::nmat::info::expect::type &gt;</span>
<span class="gi">+&gt;;</span>
<span class="gi">+</span>
 //! Parameters storage
 using parameters = tk::tuple::tagged_tuple&lt;
<span class="gd">-  tag::compflow,    CompFlowPDEParameters</span>
<span class="gi">+  tag::compflow,    CompFlowPDEParameters,</span>
<span class="gi">+  tag::multimat,    MultiMatPDEParameters</span>
 &gt;;</pre><p>Note that in <a href="namespaceinciter_1_1ctr.html#abb209e74707fa84eac59e95bc986108f" class="m-dox">ctr::<wbr />MultiMatPDEParameters</a> every field is a vector, since multiple systems of this PDE type can be configured. Also note that this is where the dependent variable, physics policy (<a href="namespaceinciter_1_1ctr.html#a05792aa346ef778c24407416c5560d14" class="m-dox">ctr::<wbr />PhysicsType</a> enum), the problem policy (<a href="namespaceinciter_1_1ctr.html#a6233f49244094f9b305675039fe62482" class="m-dox">ctr::<wbr />ProblemType</a> enum), boundary conditions, problem-configuration-specific parameters, and the number of materials are all stored. This is data that is either parsed from the user or can be computed immediately after and based on user input.</p><p>Next we add a couple of new tags (empty structs used as compile-time labels), <code><a href="structtag_1_1nmat.html" class="m-dox">tag::<wbr />nmat</a></code> and <code><a href="structtag_1_1multimat.html" class="m-dox">tag::<wbr />multimat</a></code>, behind which the parser stores the tuple <a href="namespaceinciter_1_1ctr.html#abb209e74707fa84eac59e95bc986108f" class="m-dox">ctr::<wbr />MultiMatPDEParameters</a>, and the number of materials, respectively,</p></section><section id="inciter_newpde_grammar_tags"><h3><a href="#inciter_newpde_grammar_tags">Control/Tags.hpp</a></h3><pre class="m-code">git diff src/Control/Tags.hpp
<span class="gh">diff --git a/src/Control/Tags.hpp b/src/Control/Tags.hpp</span>
<span class="gh">index 188a86d0..9c0b7ec6 100644</span>
<span class="gd">--- a/src/Control/Tags.hpp</span>
<span class="gi">+++ b/src/Control/Tags.hpp</span>
<span class="gu">@@ -102,6 +102,7 @@ struct matched {};</span>
 struct part {};
 struct centroid {};
 struct ncomp {};
<span class="gi">+struct nmat {};</span>
 struct tty {};
 struct dump {};
 struct plot {};
<span class="gu">@@ -176,6 +177,7 @@ struct gid {};</span>
 struct transport {};
 struct advection {};
 struct compflow {};
<span class="gi">+struct multimat {};</span>
 struct problem {};
 struct physics {};
 struct diffusivity {};</pre><p>We are now ready to augment the grammar itself:</p></section><section id="inciter_newpde_grammar_grammar"><h3><a href="#inciter_newpde_grammar_grammar">Control/Inciter/InputDeck/Grammar.hpp</a></h3><pre class="m-code">git diff src/Control/Inciter/InputDeck/Grammar.hpp
<span class="gh">diff --git a/src/Control/Inciter/InputDeck/Grammar.hpp b/src/Control/Inciter/InputDeck/Grammar.hpp</span>
<span class="gh">index 6b16b623..43a9bba7 100644</span>
<span class="gd">--- a/src/Control/Inciter/InputDeck/Grammar.hpp</span>
<span class="gi">+++ b/src/Control/Inciter/InputDeck/Grammar.hpp</span>
<span class="gu">@@ -35,8 +35,9 @@ namespace deck {</span>
 
   //! \brief Number of registered equations
   //! \details Counts the number of parsed equation blocks during parsing.
<span class="gd">-  static tk::tuple::tagged_tuple&lt; tag::transport, std::size_t,</span>
<span class="gd">-                                  tag::compflow,  std::size_t &gt; neq;</span>
<span class="gi">+  static tk::tuple::tagged_tuple&lt; tag::transport, std::size_t,</span>
<span class="gi">+                                  tag::compflow,  std::size_t,</span>
<span class="gi">+                                  tag::multimat,  std::size_t &gt; neq;</span>
 
 } // ::deck
 } // ::inciter
<span class="gu">@@ -201,6 +202,70 @@ namespace grm {</span>
     }
   };</pre><p>The above tagged tuple, <a href="namespaceinciter_1_1deck.html#a6d53ee5b99d40c4a6d3d2e2d6d8dac21" class="m-dox">deck::<wbr />neq</a>, stores the number of equations <em>during</em> parsing the inciter&#x27;s input file. Since this is part of the state of inciter&#x27;s parser, it is static and thus only visible locally to inciter&#x27;s grammar and not the rest of the code. <a href="namespaceinciter_1_1deck.html#a6d53ee5b99d40c4a6d3d2e2d6d8dac21" class="m-dox">deck::<wbr />neq</a> is used to count the number of PDE systems parsed.</p><p>The following code is run immediately after the <code>multimat...end</code> block finished parsing, thus it is designed to do error checking and set/verify defaults for this particular PDE system.</p><pre class="m-code"><span class="gi">+  //! Rule used to trigger action</span>
<span class="gi">+  template&lt; class eq &gt; struct check_multimat : pegtl::success {};</span>
<span class="gi">+  //! \brief Set defaults and do error checking on the multimaterial</span>
<span class="gi">+  //!    compressible flow equation block</span>
<span class="gi">+  //! \details This is error checking that only the multimaterial compressible</span>
<span class="gi">+  //!   flow equation block must satisfy. Besides error checking we also set</span>
<span class="gi">+  //!   defaults here as this block is called when parsing of a</span>
<span class="gi">+  //!   multimat...end block has just finished.</span>
<span class="gi">+  template&lt; class eq &gt;</span>
<span class="gi">+  struct action&lt; check_multimat&lt; eq &gt; &gt; {</span>
<span class="gi">+    template&lt; typename Input, typename Stack &gt;</span>
<span class="gi">+    static void apply( const Input&amp; in, Stack&amp; stack ) {</span>
<span class="gi">+      using inciter::deck::neq;</span>
<span class="gi">+</span>
<span class="gi">+      // Error out if no dependent variable has been selected</span>
<span class="gi">+      auto&amp; depvar = stack.template get&lt; tag::param, eq, tag::depvar &gt;();</span>
<span class="gi">+      if (depvar.empty() || depvar.size() != neq.get&lt; eq &gt;())</span>
<span class="gi">+        Message&lt; Stack, ERROR, MsgKey::NODEPVAR &gt;( stack, in );</span>
<span class="gi">+</span></pre><p>First we ensure that a dependent variable has been associated. This is mandatory, as this identifies the PDE system during parsing. If <code>depvar</code> is not specified in this equation block or the vector that stores the dependent variables for this equation block does not have the same number of entries as many PDEs have been configured so far, that means the dependent variable has not been specified, so the parser will issue an error when all parsing has been finished.</p><pre class="m-code"><span class="gi">+      // If physics type is not given, default to &#39;veleq&#39;</span>
<span class="gi">+      auto&amp; physics = stack.template get&lt; tag::param, eq, tag::physics &gt;();</span>
<span class="gi">+      if (physics.empty() || physics.size() != neq.get&lt; eq &gt;())</span>
<span class="gi">+        physics.push_back( inciter::ctr::PhysicsType::VELEQ );</span>
<span class="gi">+</span></pre><p>We also ensure that a mandatory physics policy has been selected. If the user did not select one, the default is the new <code>veleq</code> we are adding.</p><pre class="m-code"><span class="gi">+      // Set number of scalar components based on number of materials</span>
<span class="gi">+      auto&amp; nmat = stack.template get&lt; tag::param, eq, tag::nmat &gt;();</span>
<span class="gi">+      auto&amp; ncomp = stack.template get&lt; tag::component, eq &gt;();</span>
<span class="gi">+      if (physics.back() == inciter::ctr::PhysicsType::VELEQ) {</span>
<span class="gi">+        // physics = veleq: m-material compressible flow</span>
<span class="gi">+        // scalar components: volfrac:m-1 + mass:m + momentum:3 + energy:m</span>
<span class="gi">+        // if nmat is unspecified, configure it be 2</span>
<span class="gi">+        if (nmat.empty() || nmat.size() != neq.get&lt; eq &gt;()) {</span>
<span class="gi">+          Message&lt; Stack, WARNING, MsgKey::NONMAT &gt;( stack, in );</span>
<span class="gi">+          nmat.push_back( 2 );</span>
<span class="gi">+        }</span>
<span class="gi">+        // set ncomp based on nmat</span>
<span class="gi">+        auto m = nmat.back();</span>
<span class="gi">+        ncomp.push_back( m-1 + m + 3 + m );</span>
<span class="gi">+      }</span>
<span class="gi">+</span></pre><p>The number of materials is processed above. If the physics selected is the newly added velocity equilibrium <em>and</em> the user did not specify the number of materials, first we issue a warning, then we set the number of materials equal to 2. If the user has configured the number materials, we use it, and compute the number of scalar components, <code>ncomp</code>, for this PDE system, as appropriate for the algorithm.</p><pre class="m-code"><span class="gi">+      // If problem type is not given, default to &#39;user_defined&#39;</span>
<span class="gi">+      auto&amp; problem = stack.template get&lt; tag::param, eq, tag::problem &gt;();</span>
<span class="gi">+      if (problem.empty() || problem.size() != neq.get&lt; eq &gt;())</span>
<span class="gi">+        problem.push_back( inciter::ctr::ProblemType::USER_DEFINED );</span>
<span class="gi">+      else if (problem.back() == inciter::ctr::ProblemType::VORTICAL_FLOW) {</span>
<span class="gi">+        const auto&amp; alpha = stack.template get&lt; tag::param, eq, tag::alpha &gt;();</span>
<span class="gi">+        const auto&amp; beta = stack.template get&lt; tag::param, eq, tag::beta &gt;();</span>
<span class="gi">+        const auto&amp; p0 = stack.template get&lt; tag::param, eq, tag::p0 &gt;();</span>
<span class="gi">+        if ( alpha.size() != problem.size() ||</span>
<span class="gi">+             beta.size() != problem.size() ||</span>
<span class="gi">+             p0.size() != problem.size() )</span>
<span class="gi">+          Message&lt; Stack, ERROR, MsgKey::VORTICAL_UNFINISHED &gt;( stack, in );</span>
<span class="gi">+      }</span>
<span class="gi">+</span></pre><p>The above is some basic sanity checking on the problem policy selected.</p><pre class="m-code"><span class="gi">+      // Error check Dirichlet boundary condition block for all multimat</span>
<span class="gi">+      // configurations</span>
<span class="gi">+      for (const auto&amp; s : stack.template get&lt; tag::param, eq, tag::bcdir &gt;())</span>
<span class="gi">+        if (s.empty())</span>
<span class="gi">+          Message&lt; Stack, ERROR, MsgKey::BC_EMPTY &gt;( stack, in );</span></pre><p>Followed by some error checking for Dirichlet boundary conditions. Obviously, this section can and will grow in the future as more defaults and error checking will be added.</p><pre class="m-code"><span class="gi">+    }</span>
<span class="gi">+  };</span>
<span class="gi">+</span>
   //! Rule used to trigger action
   template&lt; class Option, typename...tags &gt;
   struct store_inciter_option : pegtl::success {};
<span class="gu">@@ -565,6 +630,55 @@ namespace deck {</span>
                                tag::bcextrapolate &gt; &gt;,
            check_errors&lt; tag::compflow, tk::grm::check_compflow &gt; &gt; {};
 
<span class="gi">+  //! compressible multi-material flow</span>
<span class="gi">+  struct multimat :</span>
<span class="gi">+         pegtl::if_must&lt;</span>
<span class="gi">+           scan_eq&lt; use&lt; kw::multimat &gt;, tag::multimat &gt;,</span>
<span class="gi">+           tk::grm::block&lt; use&lt; kw::end &gt;,</span>
<span class="gi">+                           tk::grm::policy&lt; use,</span>
<span class="gi">+                                            use&lt; kw::physics &gt;,</span>
<span class="gi">+                                            ctr::Physics,</span>
<span class="gi">+                                            tag::multimat,</span>
<span class="gi">+                                            tag::physics &gt;,</span>
<span class="gi">+                           tk::grm::policy&lt; use,</span>
<span class="gi">+                                            use&lt; kw::problem &gt;,</span>
<span class="gi">+                                            ctr::Problem,</span>
<span class="gi">+                                            tag::multimat,</span>
<span class="gi">+                                            tag::problem &gt;,</span>
<span class="gi">+                           tk::grm::depvar&lt; use,</span>
<span class="gi">+                                            tag::multimat,</span>
<span class="gi">+                                            tag::depvar &gt;,</span>
<span class="gi">+                           parameter&lt; tag::multimat,</span>
<span class="gi">+                                      kw::nmat,</span>
<span class="gi">+                                      tag::nmat &gt;,</span>
<span class="gi">+                           material_properties&lt; tag::multimat &gt;,</span>
<span class="gi">+                           parameter&lt; tag::multimat,</span>
<span class="gi">+                                      kw::pde_alpha,</span>
<span class="gi">+                                      tag::alpha &gt;,</span>
<span class="gi">+                           parameter&lt; tag::multimat,</span>
<span class="gi">+                                      kw::pde_p0,</span>
<span class="gi">+                                      tag::p0 &gt;,</span>
<span class="gi">+                           parameter&lt; tag::multimat,</span>
<span class="gi">+                                      kw::pde_beta,</span>
<span class="gi">+                                      tag::beta &gt;,</span>
<span class="gi">+                           bc&lt; kw::bc_dirichlet,</span>
<span class="gi">+                               tag::multimat,</span>
<span class="gi">+                               tag::bcdir &gt;,</span>
<span class="gi">+                           bc&lt; kw::bc_sym,</span>
<span class="gi">+                               tag::multimat,</span>
<span class="gi">+                               tag::bcsym &gt;,</span>
<span class="gi">+                           bc&lt; kw::bc_inlet,</span>
<span class="gi">+                               tag::multimat,</span>
<span class="gi">+                               tag::bcinlet &gt;,</span>
<span class="gi">+                           bc&lt; kw::bc_outlet,</span>
<span class="gi">+                               tag::multimat,</span>
<span class="gi">+                               tag::bcoutlet &gt;,</span>
<span class="gi">+                           bc&lt; kw::bc_extrapolate,</span>
<span class="gi">+                               tag::multimat,</span>
<span class="gi">+                               tag::bcextrapolate &gt; &gt;,</span>
<span class="gi">+           check_errors&lt; tag::multimat,</span>
<span class="gi">+                         tk::grm::check_multimat &gt; &gt; {};</span>
<span class="gi">+</span></pre><p>The above is the code block that augments inciter&#x27;s input file grammar with the <code>multimat</code> block. The rules of PEGTL (our parser library) are out of scope here, but even without knowing the details of <em>how</em> the parsing is done, one can surely infer <em>what</em> is (and what is <em>not</em>) parsed in this block. Examples of what are parsed: physics and problem policies, depvar, etc., and what is <em>NOT</em> parsed: number of (scalar) components, c.f., the definition of the transport equation grammar block, <a href="structinciter_1_1deck_1_1transport.html" class="m-dox">deck::<wbr />transport</a>, not listed, in <a href="_inciter_2_input_deck_2_grammar_8hpp.html" class="m-dox">Control/<wbr />Inciter/<wbr />InputDeck/<wbr />Grammar.hpp</a>.</p><pre class="m-code">   //! partitioning ... end block
   struct partitioning :
          pegtl::if_must&lt;
<span class="gu">@@ -580,7 +694,7 @@ namespace deck {</span>
 
   //! equation types
   struct equations :
<span class="gd">-         pegtl::sor&lt; transport, compflow &gt; {};</span>
<span class="gi">+         pegtl::sor&lt; transport, compflow, multimat &gt; {};</span>
 
   //! refinement variable(s) (refvar) ... end block
   struct refvars :</pre><p>We finally include (above) the new <code>multimat</code> grammar block among the equations recognized by the parser.</p><p>One last item is to augment the grammar messages data store to include our new warning on unspecified number of materials:</p></section><section id="inciter_newpde_grammar_common"><h3><a href="#inciter_newpde_grammar_common">Control/CommonGrammar.hpp</a></h3><pre class="m-code">git diff src/Control/CommonGrammar.hpp
<span class="gh">diff --git a/src/Control/CommonGrammar.hpp b/src/Control/CommonGrammar.hpp</span>
<span class="gh">index 40c0b71d..c2de296e 100644</span>
<span class="gd">--- a/src/Control/CommonGrammar.hpp</span>
<span class="gi">+++ b/src/Control/CommonGrammar.hpp</span>
<span class="gu">@@ -98,6 +98,7 @@ namespace grm {</span>
     WRONGGAUSSIAN,      //!&lt; Wrong number of parameters configuring a PDF
     NEGATIVEPARAM,      //!&lt; Negative variance given configuring a Gaussian
     NONCOMP,            //!&lt; No number of components selected
<span class="gi">+    NONMAT,             //!&lt; No number of materials selected</span>
     NORNG,              //!&lt; No RNG selected
     NODT,               //!&lt; No time-step-size policy selected
     MULDT,              //!&lt; Multiple time-step-size policies selected
<span class="gu">@@ -187,7 +188,10 @@ namespace grm {</span>
       &quot;variable to solve for.&quot; },
     { MsgKey::NONCOMP, &quot;The number of components has not been specified in the &quot;
       &quot;block preceding this position. This is mandatory for the preceding &quot;
       &quot;block. Use the keyword &#39;ncomp&#39; to specify the number of components.&quot; },
<span class="gi">+    { MsgKey::NONMAT, &quot;The number of materials has not been specified in the &quot;</span>
<span class="gi">+      &quot;block preceding this position. This is mandatory for the preceding &quot;</span>
<span class="gi">+      &quot;block. Use the keyword &#39;nmat&#39; to specify the number of materials.&quot; },</span>
     { MsgKey::NORNG, &quot;The random number generator has not been specified in &quot;
       &quot;the block preceding this position. This is mandatory for the preceding &quot;
       &quot;block. Use the keyword &#39;rng&#39; to specify the random number generator.&quot; },</pre><p>With the above changes, inciter&#x27;s parser can now recognize the following:</p><pre class="m-code">inciter
  ...
  scheme dg
  ...
  multimat    <span class="c1"># configure our new PDE block for compressible multi-material flow</span>
    depvar u    <span class="c1"># assign dependent variable &#39;u&#39; to this PDE</span>
    physics veleq       <span class="c1"># select &#39;euler&#39; as compressible flow physics policy</span>
    problem interface_advection  <span class="c1"># select &#39;interface_advection` as problem policy</span>
    nmat <span class="m">3</span>      <span class="c1"># configure 3 materials</span>
    ...
  end
  ...
end</pre></section></section><section id="inciter_newpde_pdestack"><h2><a href="#inciter_newpde_pdestack">5. Augment the PDE stack</a></h2><p>Next is to augment inciter&#x27;s <code><a href="classinciter_1_1_p_d_e_stack.html" class="m-dox">PDEStack</a></code>, a factory from which the PDEs are instantiated according to user configuration.</p><p>Class <a href="classinciter_1_1_p_d_e_stack.html" class="m-dox">PDEStack</a> helps with configuring and instantiating PDE class objects from factories. There are separate factories for PDEs with continuous Galerkin (CG) and discontinuous Galerkin (<a href="classinciter_1_1_d_g.html" class="m-dox">DG</a>) finite element discretizations, declared in <a href="_p_d_e_factory_8hpp.html" class="m-dox">PDE/<wbr />PDEFactory.hpp</a>: <code>CGFactory</code> and <code>DGFactory</code>. These factories are associative containers that assign PDE class constructors to a key that uniquely identifies a given PDE system configured to a given physics and problem policy.</p><p>First the constructors of all PDEs with all possible combinations of their valid policies are registered into their factory. This is done by <a href="classinciter_1_1_p_d_e_stack.html" class="m-dox">PDEStack</a>&#x27;s constructor. Then when user input is known at runtime, i.e., we know what and how many PDE systems, with what discretizations, and with what policies the user wants to use, we instantiate the selected ones in <a href="classinciter_1_1_p_d_e_stack.html#afbfc75df861f066b1ede2f1f3ae58dc2" class="m-dox">PDEStack::<wbr />selectedCG()</a> and <a href="classinciter_1_1_p_d_e_stack.html#ab70171a7495c8a9b37f3317d507122cd" class="m-dox">PDEStack::<wbr />selectedDG()</a>.</p><aside class="m-note m-info"><h4>Note</h4><p>All PDE types are polymorphic and must adhere to the concepts defined within <a href="classinciter_1_1_c_g_p_d_e.html" class="m-dox">CGPDE</a> and <a href="classinciter_1_1_d_g_p_d_e.html" class="m-dox">DGPDE</a>. This concept is nothing else but the requirement on defining certain member functions with given name, return value, and input arguments (function signature). All &quot;child&quot; PDE classes must conform to these concepts so they can be used from client code that is uniform, such as in <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a>. For more details, see also the discussion in <a href="classinciter_1_1_p_d_e_stack.html" class="m-dox">PDEStack</a>&#x27;s constructor.</p></aside><p>The following diff augments <a href="classinciter_1_1_p_d_e_stack.html" class="m-dox">PDEStack</a> with our newly added PDE type.</p><section id="inciter_newpde_pdestack_pdestack"><h3><a href="#inciter_newpde_pdestack_pdestack">PDE/PDEStack.cpp</a></h3><pre class="m-code">git diff src/PDE/PDEStack.cpp
<span class="gh">diff --git a/src/PDE/PDEStack.cpp b/src/PDE/PDEStack.cpp</span>
<span class="gh">index 70036aad..af1a2de7 100644</span>
<span class="gd">--- a/src/PDE/PDEStack.cpp</span>
<span class="gi">+++ b/src/PDE/PDEStack.cpp</span>
<span class="gu">@@ -17,6 +17,7 @@</span>
 
 #include &quot;ConfigureTransport.hpp&quot;
 #include &quot;ConfigureCompFlow.hpp&quot;
<span class="gi">+#include &quot;ConfigureMultiMat.hpp&quot;</span>
 
 using inciter::PDEStack;
 
<span class="gu">@@ -96,6 +97,7 @@ PDEStack::PDEStack() : m_cgfactory(), m_dgfactory(),</span>
 {
   registerTransport( m_cgfactory, m_dgfactory, m_cgEqTypes, m_dgEqTypes );
   registerCompFlow( m_cgfactory, m_dgfactory, m_cgEqTypes, m_dgEqTypes );
<span class="gi">+  registerMultiMat( m_dgfactory, m_dgEqTypes );</span>
 }
 
 std::vector&lt; inciter::CGPDE &gt;
<span class="gu">@@ -144,6 +146,8 @@ PDEStack::selectedDG() const</span>
         pdes.push_back( createDG&lt; tag::transport &gt;( d, cnt ) );
       else if (d == ctr::PDEType::COMPFLOW)
         pdes.push_back( createDG&lt; tag::compflow &gt;( d, cnt ) );
<span class="gi">+      else if (d == ctr::PDEType::MULTIMAT)</span>
<span class="gi">+        pdes.push_back( createDG&lt; tag::multimat &gt;( d, cnt ) );</span>
       else Throw( &quot;Can&#39;t find selected DGPDE&quot; );
     }
 
<span class="gu">@@ -169,6 +173,8 @@ PDEStack::info() const</span>
       nfo.emplace_back( infoTransport( cnt ) );
     else if (d == ctr::PDEType::COMPFLOW)
       nfo.emplace_back( infoCompFlow( cnt ) );
<span class="gi">+    else if (d == ctr::PDEType::MULTIMAT)</span>
<span class="gi">+      nfo.emplace_back( infoMultiMat( cnt ) );</span>
     else Throw( &quot;Can&#39;t find selected PDE&quot; );
   }</pre><p><a href="namespaceinciter.html#a4fb8f270aeb49096b0d6efff2b8fd7a1" class="m-dox">registerMultiMat()</a> will be defined in ConfigureMultiMat.[Ch].</p></section></section><section id="inciter_newpde_buildsystem"><h2><a href="#inciter_newpde_buildsystem">6. Augment the PDE build object</a></h2><p>Before adding the new (skeleton) files for the new PDE type (which will contain their actual implementation of the spatial discretization), we add a new object file to the PDE build object so that registration of the new PDE into <a href="classinciter_1_1_p_d_e_stack.html" class="m-dox">PDEStack</a> is complete:</p><section id="inciter_newpde_cmake"><h3><a href="#inciter_newpde_cmake">PDE/CMakeLists.txt</a></h3><pre class="m-code">git diff src/PDE/CMakeListst.txt
<span class="gh">diff --git a/src/PDE/CMakeLists.txt b/src/PDE/CMakeLists.txt</span>
<span class="gh">index c2ae8d9b..76562c52 100644</span>
<span class="gd">--- a/src/PDE/CMakeLists.txt</span>
<span class="gi">+++ b/src/PDE/CMakeLists.txt</span>
<span class="gu">@@ -14,7 +14,8 @@ add_library(PDE</span>
             Integrate/Riemann/RiemannFactory.cpp
             Limiter.cpp
             ConfigureTransport.cpp
<span class="gd">-            ConfigureCompFlow.cpp)</span>
<span class="gi">+            ConfigureCompFlow.cpp</span>
<span class="gi">+            ConfigureMultiMat.cpp)</span>
 
 target_include_directories(PDE PUBLIC
                            ${QUINOA_SOURCE_DIR}</pre></section></section><section id="inciter_newpde_skeletons"><h2><a href="#inciter_newpde_skeletons">7. New skeleton PDE classes</a></h2><p>Finally, we add a set of new files that will implement the new PDE using <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a>. As an example, we also add a new physics and a couple of new problem policy classes: one for a user-defined problem and another one for a verification problem using a interface advection.</p><p>Here are the new files and subdirectories under <code>src/PDE/</code>:</p><pre class="m-console">├── ConfigureMultiMat.cpp
├── ConfigureMultiMat.hpp
├── MultiMat
│   ├── DGMultiMat.hpp
│   ├── Physics
│   │   ├── DG.hpp
│   │   └── DGVelEq.hpp
│   ├── Problem
│   │   ├── UserDefined.hpp
│   │   └── InterfaceAdvection.hpp
│   └── Problem.h</pre><p>Click on the filenames for the sources:</p><p>For registration into <a href="classinciter_1_1_p_d_e_stack.html" class="m-dox">PDEStack</a> and DGFactory:</p><ul><li><a href="inciter_newpde_configuremultimat_h.html" class="m-dox">PDE/<wbr />ConfigureMultiMat.hpp</a></li><li><a href="inciter_newpde_configuremultimat_c.html" class="m-dox">PDE/<wbr />ConfigureMultiMat.cpp</a></li></ul><p>Implementation and calls to the discretization of <em>all</em> <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a> operators for multi-material compressible flow physics:</p><ul><li><a href="inciter_newpde_dgmultimat_h.html" class="m-dox">PDE/<wbr />MultiMat/<wbr />DGMultiMat.hpp</a></li></ul><p>Physics configuration:</p><ul><li><a href="inciter_newpde_dg_h.html" class="m-dox">PDE/<wbr />MultiMat/<wbr />Physics/<wbr />DG.hpp</a> - list of all MultiMat <a href="classinciter_1_1_d_g.html" class="m-dox">DG</a> physics policies</li><li><a href="inciter_newpde_dgeuler_h.html" class="m-dox">PDE/<wbr />MultiMat/<wbr />Physics/<wbr />DGEuler.hpp</a> - a new physics policy for inviscid multi-material policy</li></ul><p>Problem configuration:</p><ul><li><a href="inciter_newpde_userdefined_h.html" class="m-dox">PDE/<wbr />MultiMat/<wbr />Problem/<wbr />UserDefined.hpp</a> - a new problem policy for multi-material compflow</li><li><a href="inciter_newpde_interfaceadvection_h.html" class="m-dox">PDE/<wbr />MultiMat/<wbr />Problem/<wbr />InterfaceAdvection.hpp</a> - a new problem policy specialized for the interface advection verification problem</li><li><a href="inciter_newpde_problem_h.html" class="m-dox">PDE/<wbr />MultiMat/<wbr />Problem.hpp</a> - list of all MultiMat problem policies.</li></ul></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-dox-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-dox-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-dox-search-content">
          <input type="search" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" />
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript. Enable it or <a href="https://google.com/search?q=site:quinoacomputing.github.io+">use an external search engine</a>.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            Search for symbols, directories, files, pages or modules. You can omit any
            prefix from the symbol or file path; adding a <code>:</code> or <code>/</code>
            suffix lists all members of given symbol or directory. Navigate through the
            list using <span class="m-label m-dim">&darr;</span> and
            <span class="m-label m-dim">&uarr;</span>, press
            <span class="m-label m-dim">Enter</span> to go.
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.<br />Maybe try a full-text <a href="#" id="search-external" data-search-engine="https://google.com/search?q=site:quinoacomputing.github.io+{query}">search with external engine</a>?</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search.js"></script>
<script src="searchdata.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Quinoa docs, part of the <a href="http://quinoacomputing.github.io/">Quinoa project</a>. Copyright © J. Bakosi 2012&ndash;2015, Los Alamos National Security, LLC, 2016&ndash;2018, <a href="https://www.triadns.org/">Triad National Security, LLC,</a> 2019-2021. Generated on Monday, Nov 06, 2023 based on <a href="https://github.com/quinoacomputing/quinoa/commit/-128-NOTFOUND">-128-NOTFOUND</a> by <a href="http://doxygen.org/">Doxygen</a> and <a href="http://mcss.mosra.cz/">m.css</a>. Contact us via <a href="https://github.com/quinoacomputing/quinoa/issues">GitHub</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>