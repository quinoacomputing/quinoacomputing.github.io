<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>tk namespace | Quinoa docs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="quinoa.m-dark-noindent+doxygen.compiled.css" />
  <link rel="icon" href="quinoa_sum.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Quinoa <span class="m-thin">docs</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li>
              <a href="https://quinoacomputing.github.io/index.html#mainpage_tools">Tools</a>
              <ol>
                <li><a href="inciter_main.html">Inciter (Compressible flow solver)</a></li>
                <li><a href="meshconv_main.html">MeshConv (Mesh format converter)</a></li>
                <li><a href="unittest_main.html">UnitTest</a></li>
              </ol>
            </li>
            <li>
              <a href="easybuild.html">Build</a>
              <ol>
                <li><a href="build.html">Advanced build options</a></li>
                <li><a href="git_submodules_subtrees.html">Modules</a></li>
                <li><a href="licenses.html">Libraries</a></li>
                <li><a href="build_system.html">Internals</a></li>
              </ol>
            </li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li>
              <a href="resources.html">Resources</a>
              <ol>
                <li><a href="https://github.com/quinoacomputing/quinoa">GitHub</a></li>
                <li><a href="papers.html">Publications</a></li>
                <li><a href="https://github.com/quinoacomputing/quinoa/blob/master/LICENSE">License</a></li>
                <li><a href="roadmap.html">Roadmap</a></li>
                <li><a href="contributing.html">Contributing</a></li>
                <li><a href="coverage.html">Coverage</a></li>
                <li><a href="https://github.com/quinoacomputing/quinoa/releases">Tarballs</a></li>
                <li><a href="https://bestpractices.coreinfrastructure.org/projects/2120">Practices</a></li>
              </ol>
            </li>
            <li class="m-show-m"><a href="#search" class="m-dox-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <path d="m6 0c-3.3144 0-6 2.6856-6 6 0 3.3144 2.6856 6 6 6 1.4858 0 2.8463-0.54083 3.8945-1.4355-0.0164 0.33797 0.14734 0.75854 0.5 1.1504l3.2227 3.7891c0.55185 0.6139 1.4517 0.66544 2.002 0.11524 0.55022-0.55022 0.49866-1.4501-0.11524-2.002l-3.7891-3.2246c-0.39184-0.35266-0.81242-0.51469-1.1504-0.5 0.89472-1.0482 1.4355-2.4088 1.4355-3.8945 0-3.3128-2.6856-5.998-6-5.998zm0 1.5625a4.4375 4.4375 0 0 1 4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375 4.4375 4.4375 4.4375 0 0 1-4.4375-4.4375 4.4375 4.4375 0 0 1 4.4375-4.4375z"/>
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>tk <span class="m-thin">namespace</span></h1>
        <p>Toolkit declarations and definitions for general purpose utilities.</p>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              Reference
              <ul>
                <li><a href="#namespaces">Namespaces</a></li>
                <li><a href="#nested-classes">Classes</a></li>
                <li><a href="#enum-members">Enums</a></li>
                <li><a href="#typedef-members">Typedefs</a></li>
                <li><a href="#func-members">Functions</a></li>
                <li><a href="#var-members">Variables</a></li>
              </ul>
            </li>
          </ul>
        </div>
        <section id="namespaces">
          <h2><a href="#namespaces">Namespaces</a></h2>
          <dl class="m-dox">
            <dt>namespace <a href="namespacetk_1_1grm.html" class="m-dox">grm</a></dt>
            <dd>Toolkit general purpose grammar definition.</dd>
            <dt>namespace <a href="namespacetk_1_1zoltan.html" class="m-dox">zoltan</a></dt>
            <dd>Interoperation with the Zoltan library, used for static mesh partitioning.</dd>
          </dl>
        </section>
        <section id="nested-classes">
          <h2><a href="#nested-classes">Classes</a></h2>
          <dl class="m-dox">
            <dt>
              class <a href="classtk_1_1_chare_state_collector.html" class="m-dox">ChareStateCollector</a>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              class <a href="classtk_1_1_data.html" class="m-dox">Data</a>
            </dt>
            <dd>Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch.</dd>
            <dt>
              class <a href="classtk_1_1_exception.html" class="m-dox">Exception</a>
            </dt>
            <dd>Basic exception class for producing <a href="file:func:line">file:func:line</a> info + call trace.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename, typename = std::void_t&lt;&gt;&gt;</div>
              struct <a href="structtk_1_1_has_typedef__alias.html" class="m-dox">HasTypedef_alias</a>
            </dt>
            <dd>Detect if a type defines type &#x27;alias&#x27;.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename, typename = std::void_t&lt;&gt;&gt;</div>
              struct <a href="structtk_1_1_has_typedef__i__am__tagged__tuple.html" class="m-dox">HasTypedef_i_am_tagged_tuple</a>
            </dt>
            <dd>Detect if a type defines type &#x27;i_am_tagged_tuple&#x27;.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename, typename = std::void_t&lt;&gt;&gt;</div>
              struct <a href="structtk_1_1_has_function__expect__description.html" class="m-dox">HasFunction_expect_description</a>
            </dt>
            <dd>Detect if a type defines function &#x27;expect::description()&#x27;.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename, typename = std::void_t&lt;&gt;&gt;</div>
              struct <a href="structtk_1_1_has_var__expect__lower.html" class="m-dox">HasVar_expect_lower</a>
            </dt>
            <dd>Detect if a type defines variable &#x27;expect::lower&#x27;.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename, typename = std::void_t&lt;&gt;&gt;</div>
              struct <a href="structtk_1_1_has_var__expect__upper.html" class="m-dox">HasVar_expect_upper</a>
            </dt>
            <dd>Detect if a type defines variable &#x27;expect::upper&#x27;.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename, typename = std::void_t&lt;&gt;&gt;</div>
              struct <a href="structtk_1_1_has_function__expect__choices.html" class="m-dox">HasFunction_expect_choices</a>
            </dt>
            <dd>Detect if a type defines function &#x27;expect::choices()&#x27;.</dd>
            <dt>
              <div class="m-dox-template">template&lt;bool Condition, typename Then, typename Else = void&gt;</div>
              struct <a href="structtk_1_1if__.html" class="m-dox">if_</a>
            </dt>
            <dd>Type selection: <a href="structtk_1_1if__.html#a456b6172591b18a1bd516f30b653444d" class="m-dox">if_&lt; Condition, Then, Else &gt;::<wbr />type</a>.</dd>
            <dt>
              class <a href="classtk_1_1_print.html" class="m-dox">Print</a>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;std::size_t N&gt;</div>
              class <a href="classtk_1_1_progress.html" class="m-dox">Progress</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_reader.html" class="m-dox">Reader</a>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class List&gt;</div>
              class <a href="classtk_1_1_tagged_tuple.html" class="m-dox">TaggedTuple</a>
            </dt>
            <dd>Tagged tuple, allowing tag-based access.</dd>
            <dt>
              <div class="m-dox-template">template&lt;class List, class Ignore = brigand::set&lt;&gt;&gt;</div>
              struct <a href="structtk_1_1_deep_tuple_printer.html" class="m-dox">DeepTuplePrinter</a>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class List, class Ignore = brigand::set&lt;&gt;&gt;</div>
              struct <a href="structtk_1_1_tuple_printer.html" class="m-dox">TuplePrinter</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_timer.html" class="m-dox">Timer</a>
            </dt>
            <dd></dd>
            <dt>
              struct <a href="structtk_1_1info__t.html" class="m-dox">info_t</a>
            </dt>
            <dd>Struct for storing info.</dd>
            <dt>
              struct <a href="structtk_1_1entry__t.html" class="m-dox">entry_t</a>
            </dt>
            <dd>Struct for storing keyword in the input deck.</dd>
            <dt>
              class <a href="classtk_1_1_writer.html" class="m-dox">Writer</a>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename... T&gt;</div>
              class <a href="classtk_1_1cmd__keywords.html" class="m-dox">cmd_keywords</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_string_parser.html" class="m-dox">StringParser</a>
            </dt>
            <dd><a href="classtk_1_1_string_parser.html" class="m-dox">StringParser</a>.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename Enum&gt;</div>
              class <a href="classtk_1_1_toggle.html" class="m-dox">Toggle</a>
            </dt>
            <dd><a href="classtk_1_1_toggle.html" class="m-dox">Toggle</a> is the base for an Option, doing generic searches.</dd>
            <dt>
              class <a href="classtk_1_1_a_s_c_mesh_reader.html" class="m-dox">ASCMeshReader</a>
            </dt>
            <dd><a href="classtk_1_1_a_s_c_mesh_reader.html" class="m-dox">ASCMeshReader</a> : <a href="classtk_1_1_reader.html" class="m-dox">tk::<wbr />Reader</a>.</dd>
            <dt>
              class <a href="classtk_1_1_diag_writer.html" class="m-dox">DiagWriter</a>
            </dt>
            <dd><a href="classtk_1_1_diag_writer.html" class="m-dox">DiagWriter</a> : <a href="classtk_1_1_writer.html" class="m-dox">tk::<wbr />Writer</a>.</dd>
            <dt>
              class <a href="classtk_1_1_exodus_i_i_mesh_reader.html" class="m-dox">ExodusIIMeshReader</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_exodus_i_i_mesh_writer.html" class="m-dox">ExodusIIMeshWriter</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_gmsh_mesh_reader.html" class="m-dox">GmshMeshReader</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_gmsh_mesh_writer.html" class="m-dox">GmshMeshWriter</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_hyper_mesh_reader.html" class="m-dox">HyperMeshReader</a>
            </dt>
            <dd><a href="classtk_1_1_hyper_mesh_reader.html" class="m-dox">HyperMeshReader</a> : <a href="classtk_1_1_reader.html" class="m-dox">tk::<wbr />Reader</a>.</dd>
            <dt>
              class <a href="classtk_1_1_mesh_reader.html" class="m-dox">MeshReader</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_mesh_writer.html" class="m-dox">MeshWriter</a>
            </dt>
            <dd>Charm++ group used to output particle data to file in parallel.</dd>
            <dt>
              class <a href="classtk_1_1_netgen_mesh_reader.html" class="m-dox">NetgenMeshReader</a>
            </dt>
            <dd><a href="classtk_1_1_netgen_mesh_reader.html" class="m-dox">NetgenMeshReader</a> : <a href="classtk_1_1_reader.html" class="m-dox">tk::<wbr />Reader</a>.</dd>
            <dt>
              class <a href="classtk_1_1_netgen_mesh_writer.html" class="m-dox">NetgenMeshWriter</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_omega__h___mesh_reader.html" class="m-dox">Omega_h_MeshReader</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_p_d_f_writer.html" class="m-dox">PDFWriter</a>
            </dt>
            <dd><a href="classtk_1_1_p_d_f_writer.html" class="m-dox">PDFWriter</a> : <a href="classtk_1_1_writer.html" class="m-dox">Writer</a>.</dd>
            <dt>
              class <a href="classtk_1_1_r_d_g_f_l_o_mesh_reader.html" class="m-dox">RDGFLOMeshReader</a>
            </dt>
            <dd><a href="classtk_1_1_r_d_g_f_l_o_mesh_reader.html" class="m-dox">RDGFLOMeshReader</a> : <a href="classtk_1_1_reader.html" class="m-dox">tk::<wbr />Reader</a>.</dd>
            <dt>
              class <a href="classtk_1_1_silo_writer.html" class="m-dox">SiloWriter</a>
            </dt>
            <dd><a href="classtk_1_1_silo_writer.html" class="m-dox">SiloWriter</a>.</dd>
            <dt>
              class <a href="classtk_1_1_s_t_l_txt_mesh_reader.html" class="m-dox">STLTxtMeshReader</a>
            </dt>
            <dd><a href="classtk_1_1_s_t_l_txt_mesh_reader.html" class="m-dox">STLTxtMeshReader</a> : <a href="classtk_1_1_reader.html" class="m-dox">tk::<wbr />Reader</a>.</dd>
            <dt>
              class <a href="classtk_1_1_txt_stat_writer.html" class="m-dox">TxtStatWriter</a>
            </dt>
            <dd><a href="classtk_1_1_txt_stat_writer.html" class="m-dox">TxtStatWriter</a> : <a href="classtk_1_1_writer.html" class="m-dox">tk::<wbr />Writer</a>.</dd>
            <dt>
              class <a href="classtk_1_1_u_g_r_i_d_mesh_reader.html" class="m-dox">UGRIDMeshReader</a>
            </dt>
            <dd><a href="classtk_1_1_u_g_r_i_d_mesh_reader.html" class="m-dox">UGRIDMeshReader</a> : <a href="classtk_1_1_reader.html" class="m-dox">tk::<wbr />Reader</a>.</dd>
            <dt>
              class <a href="classtk_1_1_conjugate_gradients.html" class="m-dox">ConjugateGradients</a>
            </dt>
            <dd><a href="classtk_1_1_conjugate_gradients.html" class="m-dox">ConjugateGradients</a> Charm++ chare array used to perform a distributed linear solve with the conjugate gradients algorithm.</dd>
            <dt>
              class <a href="classtk_1_1_c_s_r.html" class="m-dox">CSR</a>
            </dt>
            <dd>Compressed sparse row (<a href="classtk_1_1_c_s_r.html" class="m-dox">CSR</a>) storage for a sparse matrix.</dd>
            <dt>
              class <a href="classtk_1_1_linear_map.html" class="m-dox">LinearMap</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_uns_mesh_map.html" class="m-dox">UnsMeshMap</a>
            </dt>
            <dd>Charm++ array map for initial placement of array elements using an unstructured grid.</dd>
            <dt>
              class <a href="classtk_1_1_l_b_switch.html" class="m-dox">LBSwitch</a>
            </dt>
            <dd></dd>
            <dt>
              class <a href="classtk_1_1_around.html" class="m-dox">Around</a>
            </dt>
            <dd>Helper class simplifying client code for iterating on entries surrounding entries via linked lists derived from unstructured mesh connectivity.</dd>
            <dt>
              class <a href="classtk_1_1_s_t_l_mesh.html" class="m-dox">STLMesh</a>
            </dt>
            <dd><a href="classtk_1_1_s_t_l_mesh.html" class="m-dox">STLMesh</a>.</dd>
            <dt>
              class <a href="classtk_1_1_uns_mesh.html" class="m-dox">UnsMesh</a>
            </dt>
            <dd>3D unstructured mesh class</dd>
            <dt>
              class <a href="classtk_1_1_bi_p_d_f.html" class="m-dox">BiPDF</a>
            </dt>
            <dd>Joint bivariate PDF estimator.</dd>
            <dt>
              class <a href="classtk_1_1_statistics.html" class="m-dox">Statistics</a>
            </dt>
            <dd><a href="classtk_1_1_statistics.html" class="m-dox">Statistics</a> estimator.</dd>
            <dt>
              class <a href="classtk_1_1_tri_p_d_f.html" class="m-dox">TriPDF</a>
            </dt>
            <dd>Joint trivariate PDF estimator.</dd>
            <dt>
              class <a href="classtk_1_1_uni_p_d_f.html" class="m-dox">UniPDF</a>
            </dt>
            <dd>Univariate PDF estimator.</dd>
            <dt>
              class <a href="classtk_1_1_quiet_cerr.html" class="m-dox">QuietCerr</a>
            </dt>
            <dd></dd>
          </dl>
        </section>
        <section id="enum-members">
          <h2><a href="#enum-members">Enums</a></h2>
          <dl class="m-dox">
            <dt>
              <span class="m-dox-wrap-bumper">enum <a href="#afcc275d91d4368505f221061b9ba822a" class="m-dox">ErrCode</a> { </span><span class="m-dox-wrap"><a href="#afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3" class="m-dox">SUCCESS</a> = EXIT_SUCCESS,
              <a href="#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1" class="m-dox">FAILURE</a> = EXIT_FAILURE }</span>
            </dt>
            <dd>Error codes for the OS (or whatever calls us)</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum <a href="#a1d172b64b84ff0554f0e87475f4541b4" class="m-dox-self" name="a1d172b64b84ff0554f0e87475f4541b4">Style</a> { </span><span class="m-dox-wrap"><a href="#a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e" class="m-dox">QUIET</a> =0,
              <a href="#a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2" class="m-dox">VERBOSE</a> =1 }</span>
            </dt>
            <dd>Output verbosity. C-style enum as this is used for template argument.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#a3781b50ef71ead8dd0bd286455c6030c" class="m-dox">ExoElemType</a>: int { </span><span class="m-dox-wrap"><a href="#a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170" class="m-dox">TET</a> = 0,
              <a href="#a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433" class="m-dox">TRI</a> = 1 }</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#aea4fb4c5b5f9f99675ec2f39d25a3482" class="m-dox-self" name="aea4fb4c5b5f9f99675ec2f39d25a3482">ExoWriter</a> { </span><span class="m-dox-wrap"><a href="#aea4fb4c5b5f9f99675ec2f39d25a3482a294ce20cdefa29be3be0735cb62e715d" class="m-dox">CREATE</a>,
              <a href="#aea4fb4c5b5f9f99675ec2f39d25a3482aa38bd5138bf35514df41a1795ebbf5c3" class="m-dox">OPEN</a> }</span>
            </dt>
            <dd>ExodusII writer constructor modes.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum <a href="#a85016961456a798f65e4e5a451e44242" class="m-dox-self" name="a85016961456a798f65e4e5a451e44242">GmshElemType</a> { </span><span class="m-dox-wrap"><a href="#a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d" class="m-dox">LIN</a> = 1,
              <a href="#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674" class="m-dox">TRI</a> = 2,
              <a href="#a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433" class="m-dox">TRI</a> = 1,
              <a href="#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1" class="m-dox">TET</a> = 4,
              <a href="#a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170" class="m-dox">TET</a> = 0,
              <a href="#a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125" class="m-dox">PNT</a> = 15 }</span>
            </dt>
            <dd>Identifiers of supported Gmsh elements.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#af910e1a2aff3119022dea29cf3d898c1" class="m-dox-self" name="af910e1a2aff3119022dea29cf3d898c1">GmshFileType</a> { </span><span class="m-dox-wrap"><a href="#af910e1a2aff3119022dea29cf3d898c1a0db45d2a4141101bdfe48e3314cfbca3" class="m-dox">UNDEFINED</a> = -1,
              <a href="#af910e1a2aff3119022dea29cf3d898c1ad2cd8253361a9c732d21ca1d336599cc" class="m-dox">ASCII</a> = 0,
              <a href="#af910e1a2aff3119022dea29cf3d898c1a98ad0e8750ae10ad556ed7a62affb452" class="m-dox">BINARY</a> = 1 }</span>
            </dt>
            <dd>Supported Gmsh mesh file types.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#a8e37e8d13562df3379a730217f735255" class="m-dox-self" name="a8e37e8d13562df3379a730217f735255">MeshReaderType</a>: uint8_t { </span><span class="m-dox-wrap"><a href="#a8e37e8d13562df3379a730217f735255ad8e85cdb6ef83caac7fa35c22dda2153" class="m-dox">GMSH</a> = 0,
              <a href="#a8e37e8d13562df3379a730217f735255a8d2dc7a7e41c392a0da416ec0626e676" class="m-dox">NETGEN</a>,
              <a href="#a8e37e8d13562df3379a730217f735255a834c8a77b335ad1c7bb2b632b6857339" class="m-dox">EXODUSII</a>,
              <a href="#a8e37e8d13562df3379a730217f735255a74f67c0302d5888253dce0a5e2462ade" class="m-dox">HYPER</a>,
              <a href="#a8e37e8d13562df3379a730217f735255ac6e421eaad140c1bc1a39980502df80c" class="m-dox">ASC</a>,
              <a href="#a8e37e8d13562df3379a730217f735255ae29e9370fcc76113c2afa7c1ab1289c2" class="m-dox">OMEGA_H</a>,
              <a href="#a8e37e8d13562df3379a730217f735255ae7ec95434eb07e6960bd2f3426045102" class="m-dox">UGRID</a>,
              <a href="#a8e37e8d13562df3379a730217f735255acdc80bba536a46df45f777905a5f377f" class="m-dox">RDGFLO</a> }</span>
            </dt>
            <dd>Supported mesh readers.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#ab4676f2ab442a552c4409d65b5d1b751" class="m-dox-self" name="ab4676f2ab442a552c4409d65b5d1b751">MeshWriterType</a>: uint8_t { </span><span class="m-dox-wrap"><a href="#ab4676f2ab442a552c4409d65b5d1b751ad8e85cdb6ef83caac7fa35c22dda2153" class="m-dox">GMSH</a> = 0,
              <a href="#ab4676f2ab442a552c4409d65b5d1b751a8d2dc7a7e41c392a0da416ec0626e676" class="m-dox">NETGEN</a>,
              <a href="#ab4676f2ab442a552c4409d65b5d1b751a834c8a77b335ad1c7bb2b632b6857339" class="m-dox">EXODUSII</a> }</span>
            </dt>
            <dd>Supported mesh writers.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#a3032aaeb67d38d01181590cd7f0acc7d" class="m-dox-self" name="a3032aaeb67d38d01181590cd7f0acc7d">HeaderType</a>: uint8_t { </span><span class="m-dox-wrap"><a href="#a3032aaeb67d38d01181590cd7f0acc7da0086b9196365933536bdfd5c618264bd" class="m-dox">INCITER</a> =0,
              <a href="#a3032aaeb67d38d01181590cd7f0acc7da1da36e94317447fef2b931d5e54de247" class="m-dox">UNITTEST</a>,
              <a href="#a3032aaeb67d38d01181590cd7f0acc7da30bd7cdef7eab119eaa17baa6ed75c35" class="m-dox">MESHCONV</a> }</span>
            </dt>
            <dd>Executable types for which an ascii logo is available in <a href="classtk_1_1_print.html" class="m-dox">tk::<wbr />Print</a>.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">enum class <a href="#ab84162b6a8fca5ac556cc8fafc8d4a77" class="m-dox">Centering</a>: char { </span><span class="m-dox-wrap"><a href="#ab84162b6a8fca5ac556cc8fafc8d4a77a0cc25b606fe928a0c9a58f7f209c4495" class="m-dox">NODE</a> = &#x27;n&#x27;,
              <a href="#ab84162b6a8fca5ac556cc8fafc8d4a77ad3e3387a4f355276d41eefead65395c5" class="m-dox">ELEM</a> = &#x27;e&#x27; }</span>
            </dt>
            <dd></dd>
          </dl>
        </section>
        <section id="typedef-members">
          <h2><a href="#typedef-members">Typedefs</a></h2>
          <dl class="m-dox">
            <dt>
              <div class="m-dox-template">template&lt;class li, class lo&gt;</div>
              using <a href="#a30c00988310413e9b96e131f8332b2b0" class="m-dox">cartesian_product</a> = brigand::reverse_fold&lt;brigand::list&lt;li, lo&gt;, brigand::list&lt;brigand::list&lt;&gt;&gt;, brigand::bind&lt;brigand::join, brigand::bind&lt;brigand::transform, brigand::_2, brigand::defer&lt;brigand::bind&lt;brigand::join, brigand::bind&lt;brigand::transform, brigand::parent&lt;brigand::_1&gt;, brigand::defer&lt;brigand::bind&lt;brigand::list, brigand::bind&lt;brigand::push_front, brigand::_1, brigand::parent&lt;brigand::_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
            </dt>
            <dd></dd>
            <dt>
              using <a href="#a9a69a8b024d95c6cb1433b0f37d7580e" class="m-dox-self" name="a9a69a8b024d95c6cb1433b0f37d7580e">ChareState</a> = <a href="classtk_1_1_tagged_tuple.html" class="m-dox">TaggedTuple</a>&lt;brigand::list&lt;<a href="structtag_1_1ch.html" class="m-dox">tag::<wbr />ch</a>, std::string, tag::id, int, <a href="structtag_1_1pe.html" class="m-dox">tag::<wbr />pe</a>, int, <a href="structtag_1_1it.html" class="m-dox">tag::<wbr />it</a>, uint64_t, tag::fn, std::string, <a href="structtag_1_1time.html" class="m-dox">tag::<wbr />time</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;
            </dt>
            <dd>Chare state.</dd>
            <dt>
              <div class="m-dox-template">template&lt;std::size_t N&gt;</div>
              using <a href="#ae1f47e67146a193c0f7e8dee7fa5d30d" class="m-dox">Table</a> = std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, N+1&gt;&gt;
            </dt>
            <dd></dd>
            <dt>
              using <a href="#a1a96ada94b7e2911ecca0a360f305575" class="m-dox-self" name="a1a96ada94b7e2911ecca0a360f305575">real</a> = double
            </dt>
            <dd>Real number type used throughout the whole code.</dd>
            <dt>
              using <a href="#acdb0e09f7bd61edc926448eec770f176" class="m-dox-self" name="acdb0e09f7bd61edc926448eec770f176">ncomp_t</a> = std::size_t
            </dt>
            <dd>uint type used throughout the whole code.</dd>
            <dt>
              using <a href="#a40ff0a76887b93164712b9ce9192fdd2" class="m-dox-self" name="a40ff0a76887b93164712b9ce9192fdd2">SiloErrorHandler</a> = void(*)(char*)
            </dt>
            <dd>Silo error handler function type.</dd>
            <dt>
              using <a href="#acfc698cb2947f9062174488d7e162748" class="m-dox-self" name="acfc698cb2947f9062174488d7e162748">NodeSet</a> = std::unordered_set&lt;std::size_t&gt;
            </dt>
            <dd>Node list type used for node communication map.</dd>
            <dt>
              using <a href="#ae54c6184a6794b266a991f0f33e88f86" class="m-dox-self" name="ae54c6184a6794b266a991f0f33e88f86">EdgeSet</a> = <a href="classtk_1_1_uns_mesh.html#a564c87d50c1611fff1c6d045bc07a3b4" class="m-dox">UnsMesh::<wbr />EdgeSet</a>
            </dt>
            <dd>Edge list type used for edge communication map.</dd>
            <dt>
              using <a href="#afae1f1be5bf7e58189087d896b6d6ad4" class="m-dox">NodeCommMap</a> = std::unordered_map&lt;int, <a href="namespacetk.html#acfc698cb2947f9062174488d7e162748" class="m-dox">NodeSet</a>&gt;
            </dt>
            <dd></dd>
            <dt>
              using <a href="#a0b9698b4e675bcacfb5726151c08ea8e" class="m-dox">EdgeCommMap</a> = std::unordered_map&lt;int, <a href="namespacetk.html#ae54c6184a6794b266a991f0f33e88f86" class="m-dox">EdgeSet</a>&gt;
            </dt>
            <dd></dd>
            <dt>
              using <a href="#a75788bc5ea5dc638a5981d8b8383abef" class="m-dox-self" name="a75788bc5ea5dc638a5981d8b8383abef">AllCommMaps</a> = <a href="classtk_1_1_tagged_tuple.html" class="m-dox">TaggedTuple</a>&lt;brigand::list&lt;<a href="structtag_1_1node.html" class="m-dox">tag::<wbr />node</a>, <a href="namespacetk.html#acfc698cb2947f9062174488d7e162748" class="m-dox">NodeSet</a>, <a href="structtag_1_1edge.html" class="m-dox">tag::<wbr />edge</a>, <a href="namespacetk.html#ae54c6184a6794b266a991f0f33e88f86" class="m-dox">EdgeSet</a>&gt;&gt;
            </dt>
            <dd>Type list of all communication maps bundled as a tagged tuple.</dd>
            <dt>
              using <a href="#aa1968d843c749b8901c9ffd71b3afb54" class="m-dox">CommMaps</a> = std::map&lt;int, <a href="namespacetk.html#a75788bc5ea5dc638a5981d8b8383abef" class="m-dox">AllCommMaps</a>&gt;
            </dt>
            <dd></dd>
            <dt>
              using <a href="#af81ac0b2512a37ffcd2c86eda61ffb9e" class="m-dox">InitializeFn</a> = std::function&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;(<a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a>, const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp;, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>)&gt;
            </dt>
            <dd></dd>
            <dt>
              using <a href="#ac36fb71a41ff5a1d9a41143652d61438" class="m-dox">RiemannFluxFn</a> = std::function&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;(const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp;, const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp;, const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 2&gt;&amp;, const std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&gt;&amp;)&gt;
            </dt>
            <dd></dd>
            <dt>
              using <a href="#ae5069d4cf4c8f3690d8f2ee0f0ada528" class="m-dox">FluxFn</a> = std::function&lt;std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&gt;(<a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a>, const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp;, const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp;, const std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&gt;&amp;)&gt;
            </dt>
            <dd></dd>
            <dt>
              using <a href="#ab96930c6425f28fde0af48eb346cc1ed" class="m-dox">VelFn</a> = std::function&lt;std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&gt;(<a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>)&gt;
            </dt>
            <dd></dd>
            <dt>
              using <a href="#aea3cd7451f600631750f04f970ef6f6e" class="m-dox">StateFn</a> = std::function&lt;std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 2&gt;(<a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a>, const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp;, const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp;, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp;)&gt;
            </dt>
            <dd></dd>
            <dt>
              using <a href="#a2cb83e9ba934b9ff1f9acc75c096e496" class="m-dox">SrcFn</a> = std::function&lt;void(<a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a>, const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp;, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp;)&gt;
            </dt>
            <dd></dd>
            <dt>
              using <a href="#afd672b0538bba68a2580d9500c7f4e29" class="m-dox-self" name="afd672b0538bba68a2580d9500c7f4e29">ElemGradFn</a> = std::function&lt;std::tuple&lt;std::array&lt;std::size_t, 4&gt;, std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 4&gt;, std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 4&gt;&gt;, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;(<a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a>, <a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a>, std::size_t, const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp;, const std::vector&lt;std::size_t&gt;&amp;, const std::tuple&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp;, const tk::Fields&amp;)&gt;
            </dt>
            <dd>Function prototype for computing the element gradient contribution to a nodal gradient in ALECG.</dd>
            <dt>
              using <a href="#a4800d95987e1904c9e423e8612672950" class="m-dox-self" name="a4800d95987e1904c9e423e8612672950">GetVarFn</a> = std::function&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;(const tk::Fields&amp;, std::size_t)&gt;
            </dt>
            <dd>Prototype for functions to compute a variable from the numerical solution.</dd>
            <dt>
              using <a href="#a49e25312de34a28a1da46d894efbe480" class="m-dox-self" name="a49e25312de34a28a1da46d894efbe480">MultiMatIdxFn</a> = std::function&lt;std::size_t(std::size_t, std::size_t)&gt;
            </dt>
            <dd>Prototype for functions to a compute multi-material index.</dd>
          </dl>
        </section>
        <section id="func-members">
          <h2><a href="#func-members">Functions</a></h2>
          <dl class="m-dox">
            <dt>
              <div class="m-dox-template">template&lt;class Container&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a87af1b002bc711716bd170a714bda211" class="m-dox">unique</a>(</span><span class="m-dox-wrap">Container&amp; c)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Container&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a33be2bf221a519d736333a9f18c8ffdc" class="m-dox">uniquecopy</a>(</span><span class="m-dox-wrap">const Container&amp; src) -&gt; Container</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename Container&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a907b848a4d232ecacb8eb34182c7b26c" class="m-dox">cref_find</a>(</span><span class="m-dox-wrap">const Container&amp; map,
              const typename Container::key_type&amp; key) -&gt; const typename Container::mapped_type &amp; -&gt; auto</span>
            </dt>
            <dd>Find and return a constant reference to value for key in container that provides a find() member function with error handling.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename Container&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a882a6f0eaec378f90eaac07cf46cb12c" class="m-dox">ref_find</a>(</span><span class="m-dox-wrap">const Container&amp; map,
              const typename Container::key_type&amp; key) -&gt; typename Container::mapped_type &amp; -&gt; auto</span>
            </dt>
            <dd>Find and return a reference to value for key in a container that provides a find() member function with error handling.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#af0de4157a7818da7a9deb1476099bd8d" class="m-dox">extents</a>(</span><span class="m-dox-wrap">const std::vector&lt;T&gt;&amp; vec) -&gt; std::array&lt;T, 2&gt;</span>
            </dt>
            <dd>Return minimum and maximum values of a vector.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename Container&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a1930c11b6d90076b9d17c9f9c9d49efe" class="m-dox">extents</a>(</span><span class="m-dox-wrap">const Container&amp; map) -&gt; std::array&lt; typename Container::mapped_type, 2 &gt; -&gt; auto</span>
            </dt>
            <dd>Find and return minimum and maximum values in associative container.</dd>
            <dt>
              <div class="m-dox-template">template&lt;class T, std::size_t N&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a0992ad19886e651975f3458f8c6ec246" class="m-dox">operator+=</a>(</span><span class="m-dox-wrap">std::array&lt;T, N&gt;&amp; dst,
              const std::array&lt;T, N&gt;&amp; src) -&gt; std::array&lt;T, N&gt;&amp;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class T, class Allocator&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ad47c993218d9384828fcce2794850ac7" class="m-dox">operator+=</a>(</span><span class="m-dox-wrap">std::vector&lt;T, Allocator&gt;&amp; dst,
              const std::vector&lt;T, Allocator&gt;&amp; src) -&gt; std::vector&lt;T, Allocator&gt;&amp;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class T, class Allocator&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#abac51edb62bae02ce65993e726320410" class="m-dox">operator/=</a>(</span><span class="m-dox-wrap">std::vector&lt;T, Allocator&gt;&amp; dst,
              const std::vector&lt;T, Allocator&gt;&amp; src) -&gt; std::vector&lt;T, Allocator&gt;&amp;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class C1, class C2&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a05866fa57031940dc4ba5d4665847016" class="m-dox">keyEqual</a>(</span><span class="m-dox-wrap">const C1&amp; a,
              const C2&amp; b) -&gt; bool</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Container&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a0f319a47a6a5b983e161aa5f4d8f7b6c" class="m-dox">sumsize</a>(</span><span class="m-dox-wrap">const Container&amp; c) -&gt; std::size_t</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Container&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ace2a28e46e910dd6356eec7d627f85dc" class="m-dox">numunique</a>(</span><span class="m-dox-wrap">const Container&amp; c) -&gt; std::size_t</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Map&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a357e40550c113066882bc3e3c3cf52b8" class="m-dox">sumvalsize</a>(</span><span class="m-dox-wrap">const Map&amp; c) -&gt; std::size_t</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Container&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a9140b408dcbd2eaef58f9c3a54fa104a" class="m-dox">destroy</a>(</span><span class="m-dox-wrap">Container&amp; c)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename Container, typename Predicate&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a38a390b2dd9f091d2ca7465208a960ed" class="m-dox">erase_if</a>(</span><span class="m-dox-wrap">Container&amp; items,
              const Predicate&amp; predicate)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class T&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a228ffc383c02503a4b6018b25996f2ae" class="m-dox">concat</a>(</span><span class="m-dox-wrap">std::vector&lt;T&gt;&amp;&amp; src,
              std::vector&lt;T&gt;&amp; dst)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class T&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a8a66b9309d4065593f466b35c61510f1" class="m-dox">concat</a>(</span><span class="m-dox-wrap">std::vector&lt;std::pair&lt;bool, T&gt;&gt;&amp;&amp; src,
              std::vector&lt;std::pair&lt;bool, T&gt;&gt;&amp; dst)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class Eq = std::equal_to&lt;Key&gt;&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a48e3038d2c19125151bf84caad6d7ae9" class="m-dox">concat</a>(</span><span class="m-dox-wrap">std::unordered_set&lt;Key, Hash, Eq&gt;&amp;&amp; src,
              std::unordered_set&lt;Key, Hash, Eq&gt;&amp; dst)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Key, class Value&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a433a341b79ff4eab8ca99e66a67de578" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::ostream&amp; os,
              const std::pair&lt;const Key, Value&gt;&amp; v) -&gt; std::ostream&amp;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ad3c124a1502656b2b17aab7aaefbec0c" class="m-dox">parameter</a>(</span><span class="m-dox-wrap">const T&amp; v) -&gt; std::string</span>
            </dt>
            <dd>Convert and return value as string.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename V&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a31d32eb5c332a0116f9c45eca4450b66" class="m-dox">parameters</a>(</span><span class="m-dox-wrap">const V&amp; v) -&gt; std::string</span>
            </dt>
            <dd>Convert and return values from container as string.</dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#adc362fc7a89c617e1ab8f57f1dbd100a" class="m-dox">operator*</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs) -&gt; <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#afd730d099e698f124362ef8c01483e0f" class="m-dox">min</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; a,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; b) -&gt; <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ac9a26e30d19b940a12990a866a514cb5" class="m-dox">max</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; a,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; b) -&gt; <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a21669e4d06c62a58cd0f4bf63868ab7e" class="m-dox">operator==</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs) -&gt; bool</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ac38f5055c45cd35b8ce00151cea4c1d3" class="m-dox">operator!=</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs) -&gt; bool</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;uint8_t Layout&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ab7f02155bc2945a0a0c82c1be5cad041" class="m-dox">maxdiff</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs) -&gt; std::pair&lt;std::size_t, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class C, class Key, class Factory, typename... ConstructorArgs&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#ad986ef5558d44d5e0c6650c589499980" class="m-dox">record</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ConstructorArgs&amp;&amp;... args)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Factory, class Key, class Obj = typename std::remove_pointer&lt;                       typename Factory::mapped_type::result_type&gt;::type&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#aeb9673379e599043b13fff369dce1402" class="m-dox">instantiate</a>(</span><span class="m-dox-wrap">const Factory&amp; f,
              const Key&amp; key) -&gt; std::unique_ptr&lt;Obj&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Host, class ModelConstructor, class Factory, class Key, typename... ModelConstrArgs&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a24170c3146caaa7b79d78d4aa1d98f66" class="m-dox">recordModel</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ModelConstrArgs&amp;&amp;... args)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Host, class ModelConstructor, class Factory, class Key&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#aa787e22ae8d722011d9cbddf1e7354ba" class="m-dox">recordModelLate</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Host, class ModelConstructor, class Factory, class Key, typename... ModelConstrArgs&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a4bd6374b4792dbd3c626dad60bcef168" class="m-dox">recordCharmModel</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ModelConstrArgs&amp;&amp;... args)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename A, typename B&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ac2323b3c43edbcc32d55d91100ffc3a6" class="m-dox">flip_pair</a>(</span><span class="m-dox-wrap">const std::pair&lt;A, B&gt;&amp; p) -&gt; std::pair&lt;B, A&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename A, typename B&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a42982d289f8edfffa60fa4da8b7b9fdf" class="m-dox">flip_map</a>(</span><span class="m-dox-wrap">const std::map&lt;A, B&gt;&amp; src) -&gt; std::multimap&lt;B, A&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Eq = std::equal_to&lt;Key&gt;&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ae89ad400e8727632059aab318889c52c" class="m-dox">serialize</a>(</span><span class="m-dox-wrap">const std::unordered_map&lt;Key, T, Hash, Eq&gt;&amp; m) -&gt; std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Eq = std::equal_to&lt;Key&gt;&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#ac371117af5d2009dca83a8cb5539a43f" class="m-dox">mergeHashMap</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs) -&gt; CkReductionMsg*</span>
            </dt>
            <dd>Charm++ custom reducer for merging std::unordered_maps during reduction across PEs.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ae484074849c5c9532282fc9fa4e19467" class="m-dox">linearLoadDistributor</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> virtualization,
              uint64_t load,
              int npe,
              uint64_t&amp; chunksize,
              uint64_t&amp; remainder) -&gt; uint64_t</span>
            </dt>
            <dd>Compute linear load distribution for given total work and virtualization.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename Enum, typename Ch, typename Tr, typename std::enable_if_t&lt;std::is_enum_v&lt;Enum&gt;, int&gt; = 0&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a80fbbf9455232f7f68136d0322f22cab" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_ostream&lt;Ch, Tr&gt;&amp; os,
              const Enum&amp; e) -&gt; std::basic_ostream&lt;Ch, Tr&gt;&amp;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class T, typename Ch, typename Tr&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a97430ef922a10f0dc200f61f6e2c4e40" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_ostream&lt;Ch, Tr&gt;&amp; os,
              const std::vector&lt;T&gt;&amp; v) -&gt; std::basic_ostream&lt;Ch, Tr&gt;&amp;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename Ch, typename Tr, class Key, class Value, class Compare = std::less&lt;Key&gt;&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a1d82ad961b5527a3ec225246282d1b48" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_ostream&lt;Ch, Tr&gt;&amp; os,
              const std::map&lt;Key, Value, Compare&gt;&amp; m) -&gt; std::basic_ostream&lt;Ch, Tr&gt;&amp;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T, typename Ch, typename Tr&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#aa160d13ea2e4a3498916472c3b6cdbb0" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_string&lt;Ch, Tr&gt;&amp; lhs,
              const T&amp; e) -&gt; std::basic_string&lt;Ch, Tr&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T, typename Ch, typename Tr&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a7adfa2dfb8b3a38f60ac0edf5666b6c4" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_string&lt;Ch, Tr&gt;&amp;&amp; lhs,
              const T&amp; e) -&gt; std::basic_string&lt;Ch, Tr&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a08013d493d2688c9525b63e666240443" class="m-dox">splitLines</a>(</span><span class="m-dox-wrap">std::string str,
              std::string indent,
              const std::string&amp; name = &quot;&quot;,
              std::size_t width = 80) -&gt; std::string</span>
            </dt>
            <dd>Clean up whitespaces and format a long string into multiple lines.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aa99868f695794091b932a82a69e04807" class="m-dox">baselogname</a>(</span><span class="m-dox-wrap">const std::string&amp; executable) -&gt; std::string</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a486a888804d7b698fe21241968f719cb" class="m-dox">logname</a>(</span><span class="m-dox-wrap">const std::string&amp; executable,
              int numrestart = 0) -&gt; std::string</span>
            </dt>
            <dd>Construct log file name.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#ad0ed65df66049a89a8a5055895ae417a" class="m-dox">signalHandler</a>(</span><span class="m-dox-wrap">int signum)</span>
            </dt>
            <dd>Signal handler for multiple signals, SIGABRT, SIGSEGV, etc.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a5e8c72da5967d8fb725ff4a26294a871" class="m-dox">setSignalHandlers</a>(</span><span class="m-dox-wrap">) -&gt; int</span>
            </dt>
            <dd>Set signal handlers for multiple signals, SIGABRT, SIGSEGV, etc.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#af04df49334286e653e440035c499a8d1" class="m-dox">processExceptionCharm</a>(</span><span class="m-dox-wrap">)</span>
            </dt>
            <dd>Process an exception from the Charm++ runtime system.</dd>
            <dt>
              <div class="m-dox-template">template&lt;typename T&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#aa7d376e7f0dd51a64632432345dd4423" class="m-dox">swap_endian</a>(</span><span class="m-dox-wrap">T u) -&gt; T</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a550509206419175e2b2277bc5c18016e" class="m-dox">swap_endian</a>(</span><span class="m-dox-wrap">double u) -&gt; double</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;std::size_t N&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a8ef5bd8de033f50be3f02dd2543da0b8" class="m-dox">sample</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x,
              const <a href="namespacetk.html#ae1f47e67146a193c0f7e8dee7fa5d30d" class="m-dox">Table</a>&lt;N&gt;&amp; table) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, N&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class Tuple&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a0aba20ed8021caba53eeb77f31dafda1" class="m-dox">print</a>(</span><span class="m-dox-wrap">std::ostream&amp; os,
              const std::string&amp; name,
              const Tuple&amp; c)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class List&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a08d29a8f44564890253cf13273ae33b6" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::ostream&amp; os,
              const <a href="classtk_1_1_tagged_tuple.html" class="m-dox">tk::<wbr />TaggedTuple</a>&lt;List&gt;&amp; t) -&gt; std::ostream&amp;</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class List, class Ignore = brigand::set&lt;&gt;&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a8b82934c22714a95ea88f9a03e6d1b5e" class="m-dox">print</a>(</span><span class="m-dox-wrap">std::ostream&amp; os,
              const <a href="classtk_1_1_tagged_tuple.html" class="m-dox">tk::<wbr />TaggedTuple</a>&lt;List&gt;&amp; t)</span>
            </dt>
            <dd>Simple (unformatted, one-line) output of a <a href="classtk_1_1_tagged_tuple.html" class="m-dox">TaggedTuple</a> to output stream with ignore.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ad6260a3dcdcb9a995a4886e566b665c4" class="m-dox">hms</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> stamp) -&gt; <a href="structtk_1_1_timer_1_1_watch.html" class="m-dox">Timer::<wbr />Watch</a></span>
            </dt>
            <dd>Convert existing time stamp as a real to Watch (global scope)</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a7ad0c203ea16b614fcbdfb5f7b310866" class="m-dox">flip</a>(</span><span class="m-dox-wrap">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a951f9484d41235130b057570caa4b670" class="m-dox">cross</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1z,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2z,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; rx,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; ry,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; rz)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a0cf686dec23cd9154006f18317a439d5" class="m-dox">cross</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v1,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v2) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a88d5b3926cac1da27cfb650712ef5585" class="m-dox">crossdiv</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1z,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2z,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> j,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; rx,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; ry,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; rz)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a7885e77a710a1ff3c5ce53655a16e49f" class="m-dox">crossdiv</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v1,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> j) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ae1c0fdc133ccaae0fb2437ac6d447972" class="m-dox">dot</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v1,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v2) -&gt; <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a></span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aa229c58c4089e9ae908232b2a353e9b3" class="m-dox">matvec</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt;&amp; m,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aa3db06a7e253fc3f22c4fb28dae6ac37" class="m-dox">length</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z) -&gt; <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a></span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a3a772fb3873098fb1951fd6d311cd60d" class="m-dox">length</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v) -&gt; <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a></span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a926d47129e0cb4cc72e296953a7da5d4" class="m-dox">unit</a>(</span><span class="m-dox-wrap">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a7f0f4bf9256573132baf2fa5f9ba814f" class="m-dox">triple</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1z,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2z,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v3x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v3y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v3z) -&gt; <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a></span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a77dfe4f35f647c7ca6a504a5a06d9178" class="m-dox">triple</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v1,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v2,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v3) -&gt; <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a></span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#af006b6e0681a9222c91616da30d23d44" class="m-dox">rotateX</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> angle) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a2e45ee53422ebc214c485a40e9bdcdff" class="m-dox">rotateY</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> angle) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a16fb059763d22c82cb9bd5f19be696e1" class="m-dox">rotateZ</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> angle) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#acd96de1dc0141f11e98a8b5dcce6522f" class="m-dox">Jacobian</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v1,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v2,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v3,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v4) -&gt; <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a></span>
            </dt>
            <dd>Compute the determinant of the Jacobian of a coordinate transformation over a tetrahedron.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a9bf3d7327197dcb3a74af13b52ee23d8" class="m-dox">inverseJacobian</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v1,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v2,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v3,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v4) -&gt; std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt;</span>
            </dt>
            <dd>Compute the inverse of the Jacobian of a coordinate transformation over a tetrahedron.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a377e30bd4504f7a7243ca97b01208a25" class="m-dox">determinant</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; a) -&gt; <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a></span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aa6ec274c35f3ace5cb1e4fed556844c2" class="m-dox">inverse</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; m) -&gt; std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a02cec3254bd9d8882f11a23fa8b0cf33" class="m-dox">cramer</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; a,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; b) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#aa4fc566f3521577c8a92473beff6b776" class="m-dox">movePoint</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; origin,
              std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; point)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#acbb53fcd1f298717edfcfde883b5f923" class="m-dox">rotatePoint</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; angles,
              std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; point)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aa6016dbfb2fed3c3abdf49f19615c87b" class="m-dox">getRightCauchyGreen</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt;&amp; g) -&gt; std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt;</span>
            </dt>
            <dd>Get the Right Cauchy-Green strain tensor from the inverse deformation gradient tensor.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a0a749960309157e64607e1a1d723118d" class="m-dox">getLeftCauchyGreen</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt;&amp; g) -&gt; std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt;</span>
            </dt>
            <dd>Get the Left Cauchy-Green strain tensor from the inverse deformation gradient tensor.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a0c1fa139012400110734c8432ea3229f" class="m-dox">getDevHencky</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt;&amp; g) -&gt; std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt;</span>
            </dt>
            <dd>Get the deviatoric Hencky strain tensor from the inverse deformation gradient tensor.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a76fbe98f45d72e60c904bfca24e35ebd" class="m-dox">transpose3by3</a>(</span><span class="m-dox-wrap">std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt; mat) -&gt; std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;</span>
            </dt>
            <dd>Get transpose of a 3 by 3 matrix.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ae65248cecf67b86c310b35efa3e288d6" class="m-dox">getRotationMatrix</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; r) -&gt; std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;</span>
            </dt>
            <dd>Get rotation matrix in 2D array form given a normal direction. The remaining directions are given by section 5.3.1 of Miller, G. H., and P. Colella. &quot;A conservative three-dimensional
Eulerian method for coupled solid–fluid shock capturing.&quot; Journal of Computational Physics 183.1 (2002): 26-82.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#acbd49264cd05edead612a698bb5f4e16" class="m-dox">rotateTensor</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; mat,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; r) -&gt; std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;</span>
            </dt>
            <dd>Rotate a second order tensor (e.g. a Strain/Stress matrix) from the (x,y,z) to a new (r,s,t) coordinate system. The directions are given by section 5.3.1 of Miller, G. H., and P. Colella. &quot;A conservative three-dimensional
Eulerian method for coupled solid–fluid shock capturing.&quot; Journal of Computational Physics 183.1 (2002): 26-82.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a40126fd348d6f946f6b038e7dfd59fe2" class="m-dox">unrotateTensor</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; mat,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; r) -&gt; std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;</span>
            </dt>
            <dd>Rotate a second order tensor (e.g. a Strain/Stress matrix) from the (x,y,z) to a new (r,s,t) coordinate system. The directions are given by section 5.3.1 of Miller, G. H., and P. Colella. &quot;A conservative three-dimensional
Eulerian method for coupled solid–fluid shock capturing.&quot; Journal of Computational Physics 183.1 (2002): 26-82.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#adcf0f9f6d18ca59357df41ff221b2044" class="m-dox">rotateVector</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; v,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; r) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;</span>
            </dt>
            <dd>Rotate a vector (e.g. a velocity) from the (x,y,z) to a new (r,s,t) coordinate system. The directions are given by section 5.3.1 of Miller, G. H., and P. Colella. &quot;A conservative three-dimensional
Eulerian method for coupled solid–fluid shock capturing.&quot; Journal of Computational Physics 183.1 (2002): 26-82.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a7a1cf38b0a38723a4aa83deaef714d95" class="m-dox">unrotateVector</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; v,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; r) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;</span>
            </dt>
            <dd>Unrotate a vector (e.g. a velocity) from the (x,y,z) to a new (r,s,t) coordinate system. The directions are given by section 5.3.1 of Miller, G. H., and P. Colella. &quot;A conservative three-dimensional
Eulerian method for coupled solid–fluid shock capturing.&quot; Journal of Computational Physics 183.1 (2002): 26-82.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ae457dd74a494f2106734b6b88bce3eaf" class="m-dox">reflectTensor</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; mat,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; reflectMat) -&gt; std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;</span>
            </dt>
            <dd>Reflect a second order tensor (e.g. a Strain/Stress matrix)</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a485fc849f142f0ee38055fad224206d6" class="m-dox">detectInput</a>(</span><span class="m-dox-wrap">const std::string&amp; filename) -&gt; <a href="namespacetk.html#a8e37e8d13562df3379a730217f735255" class="m-dox">MeshReaderType</a></span>
            </dt>
            <dd>Detect input mesh file type.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a6bcaad9b4f5b0aa6e5792f9ccacf8d79" class="m-dox">pickOutput</a>(</span><span class="m-dox-wrap">const std::string&amp; filename) -&gt; <a href="namespacetk.html#ab4676f2ab442a552c4409d65b5d1b751" class="m-dox">MeshWriterType</a></span>
            </dt>
            <dd>Determine output mesh file type.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#af947865970b76333655208aea71ceb71" class="m-dox">readUnsMesh</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">tk::<wbr />Print</a>&amp; print,
              const std::string&amp; filename,
              std::pair&lt;std::string, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; timestamp) -&gt; <a href="classtk_1_1_uns_mesh.html" class="m-dox">UnsMesh</a></span>
            </dt>
            <dd>Read unstructured mesh from file.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a92ff858133bdb654de9b95c279427325" class="m-dox">writeUnsMesh</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">tk::<wbr />Print</a>&amp; print,
              const std::string&amp; filename,
              <a href="classtk_1_1_uns_mesh.html" class="m-dox">UnsMesh</a>&amp; mesh,
              bool reorder) -&gt; std::vector&lt;std::pair&lt;std::string, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;</span>
            </dt>
            <dd>Write unstructured mesh to file.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a20ee8c554da198c14efbb80a0b623a4a" class="m-dox">SiloError</a>(</span><span class="m-dox-wrap">char* msg)</span>
            </dt>
            <dd>Silo error handler.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">static auto <a href="#a8e567fa9a72a1d5d02cea9eb020b192a" class="m-dox">workdir</a>(</span><span class="m-dox-wrap">) -&gt; std::string</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a43865234637c85533d5af75178b99f8a" class="m-dox">curtime</a>(</span><span class="m-dox-wrap">) -&gt; std::string</span>
            </dt>
            <dd>Wrapper for the standard C library&#x27;s gettimeofday() from.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a2984d7c82e0629d99655b5221a2dcc89" class="m-dox">echoHeader</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">Print</a>&amp; print,
              <a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d" class="m-dox">HeaderType</a> header)</span>
            </dt>
            <dd>Echo program header.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a300a6be5864385fcea6b688f6a7a9ce7" class="m-dox">echoBuildEnv</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">Print</a>&amp; print,
              const std::string&amp; executable)</span>
            </dt>
            <dd>Echo build environment.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#ad4032baef5ff4408d0110d6ed9464af6" class="m-dox">echoRunEnv</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">Print</a>&amp; print,
              int argc,
              char** argv,
              bool verbose,
              bool quiescence,
              bool charestate,
              bool trace,
              const std::string&amp; screen_log,
              const std::string&amp; input_log)</span>
            </dt>
            <dd>Echo runtime environment.</dd>
            <dt>
              <div class="m-dox-template">template&lt;class Driver, class CmdLine&gt;</div>
              <span class="m-dox-wrap-bumper">auto <a href="#a11c11dc55f2ea83cd4f0259f6a5a0a73" class="m-dox">Main</a>(</span><span class="m-dox-wrap">int argc,
              char* argv[],
              const CmdLine&amp; cmdline,
              <a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d" class="m-dox">HeaderType</a> header,
              const std::string&amp; executable,
              const std::string&amp; def,
              int nrestart) -&gt; Driver</span>
            </dt>
            <dd>Generic <a href="namespacetk.html#a11c11dc55f2ea83cd4f0259f6a5a0a73" class="m-dox">Main()</a> used for all executables for code-reuse and a uniform output.</dd>
            <dt>
              <div class="m-dox-template">template&lt;class MainProxy, class CmdLine&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#a118dbe0f73ff075fdc09cf2c26a755db" class="m-dox">MainCtor</a>(</span><span class="m-dox-wrap">MainProxy&amp; mp,
              const MainProxy&amp; thisProxy,
              std::vector&lt;<a href="classtk_1_1_timer.html" class="m-dox">tk::<wbr />Timer</a>&gt;&amp; timer,
              const CmdLine&amp; cmdline,
              const CkCallback&amp; quiescenceTarget)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class CmdLine&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#ab61b4ac95d7b87d8c9e8ae13a736b42a" class="m-dox">dumpstate</a>(</span><span class="m-dox-wrap">const CmdLine&amp; cmdline,
              const std::string&amp; def,
              int nrestart,
              CkReductionMsg* msg)</span>
            </dt>
            <dd></dd>
            <dt>
              <div class="m-dox-template">template&lt;class CmdLine&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#ab114f87f68585c32d84b05b5e934435c" class="m-dox">finalize</a>(</span><span class="m-dox-wrap">const CmdLine&amp; cmdline,
              const std::vector&lt;<a href="classtk_1_1_timer.html" class="m-dox">tk::<wbr />Timer</a>&gt;&amp; timer,
              tk::CProxy_ChareStateCollector&amp; state,
              std::vector&lt;std::pair&lt;std::string, <a href="structtk_1_1_timer_1_1_watch.html" class="m-dox">tk::<wbr />Timer::<wbr />Watch</a>&gt;&gt;&amp; timestamp,
              const std::string&amp; def,
              int nrestart,
              const CkCallback&amp; dumpstateTarget,
              bool clean = true)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a941f4e5e7ed94fc8394f4442cdab10f6" class="m-dox">slave</a>(</span><span class="m-dox-wrap">const <a href="namespacetk.html#afae1f1be5bf7e58189087d896b6d6ad4" class="m-dox">NodeCommMap</a>&amp; map,
              std::size_t node,
              int chare) -&gt; bool</span>
            </dt>
            <dd>Decide if a node is not counted by a chare.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a70e9a96b1d8050073ddc6fc0bedcc251" class="m-dox">count</a>(</span><span class="m-dox-wrap">const <a href="namespacetk.html#afae1f1be5bf7e58189087d896b6d6ad4" class="m-dox">NodeCommMap</a>&amp; map,
              std::size_t node) -&gt; <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a></span>
            </dt>
            <dd>Count the number of contributions to a node.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a59a1ea7e9a16e4ac2e9209c34afbf24e" class="m-dox">orient</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_uns_mesh.html#a622c34bab099c772650f046b848346d7" class="m-dox">UnsMesh::<wbr />Edge</a>&amp; t,
              const <a href="classtk_1_1_uns_mesh.html#a622c34bab099c772650f046b848346d7" class="m-dox">UnsMesh::<wbr />Edge</a>&amp; e) -&gt; int</span>
            </dt>
            <dd>Determine edge orientation.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a8d70c9570a2ddeb17fd30a9222ee7ac0" class="m-dox">npoin_in_graph</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel) -&gt; std::size_t</span>
            </dt>
            <dd>Compute number of points (nodes) in mesh from connectivity.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">genEsup</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe) -&gt; std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate derived data structure, elements surrounding points.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ad2a88a65102c17149b44660db15d445b" class="m-dox">genPsup</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate derived data structure, points surrounding points.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#adb7a88611b67f7c809f2bba5c794df0b" class="m-dox">genEdsup</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate derived data structure, edges surrounding points.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a559eb56e40ec844767bd2a55da55bda0" class="m-dox">genInpoed</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::vector&lt;std::size_t&gt;</span>
            </dt>
            <dd>Generate derived data structure, edge connectivity.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a9d835a7a93970d17a66356b64f3291af" class="m-dox">genEsupel</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate derived data structure, elements surrounding points of elements.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a7b12aff8f884c70e45c6037b4f37e662" class="m-dox">genEsuel</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate derived data structure, elements surrounding elements.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a7c8a720dd257388a44d5ca7af7aaec8f" class="m-dox">genInedel</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::vector&lt;std::size_t&gt;&amp; inpoed) -&gt; std::vector&lt;std::size_t&gt;</span>
            </dt>
            <dd>Generate derived data structure, edges of elements.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#af261e2b0ef3a9622a0fc51d6efc65967" class="m-dox">genEsued</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::unordered_map&lt;<a href="classtk_1_1_uns_mesh.html#a622c34bab099c772650f046b848346d7" class="m-dox">UnsMesh::<wbr />Edge</a>, std::vector&lt;std::size_t&gt;, <a href="structtk_1_1_uns_mesh_1_1_hash.html" class="m-dox">UnsMesh::<wbr />Hash</a>&lt;2&gt;, <a href="structtk_1_1_uns_mesh_1_1_eq.html" class="m-dox">UnsMesh::<wbr />Eq</a>&lt;2&gt;&gt;</span>
            </dt>
            <dd>Generate derived data structure, elements surrounding edges.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ab68c15dd976b0c7420ebee8770fb1f9c" class="m-dox">genNbfacTet</a>(</span><span class="m-dox-wrap">std::size_t tnbfac,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;std::size_t&gt;&amp; triinpoel_complete,
              const std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;&amp; bface_complete,
              const std::unordered_map&lt;std::size_t, std::size_t&gt;&amp; lid,
              std::vector&lt;std::size_t&gt;&amp; triinpoel,
              std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;&amp; bface) -&gt; std::size_t</span>
            </dt>
            <dd>Generate total number of boundary faces in this chunk.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a5b61b3cb6492e71ff9853404440fddcc" class="m-dox">genEsuelTet</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::vector&lt;int&gt;</span>
            </dt>
            <dd>Generate derived data structure, elements surrounding elements as a fixed length data structure as a full vector, including boundary elements as -1.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a9bda76e788ecb9f8f6e9ba004319b5e9" class="m-dox">genNipfac</a>(</span><span class="m-dox-wrap">std::size_t nfpe,
              std::size_t nbfac,
              const std::vector&lt;int&gt;&amp; esuelTet) -&gt; std::size_t</span>
            </dt>
            <dd>Generate number of internal and physical-boundary faces.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#af281200a7657c27936421122cb275757" class="m-dox">genEsuf</a>(</span><span class="m-dox-wrap">std::size_t nfpe,
              std::size_t nipfac,
              std::size_t nbfac,
              const std::vector&lt;std::size_t&gt;&amp; belem,
              const std::vector&lt;int&gt;&amp; esuelTet) -&gt; std::vector&lt;int&gt;</span>
            </dt>
            <dd>Generate derived data structure, elements surrounding faces.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#af5cc30c5f79658a16b2ea7a133f71e2c" class="m-dox">genInpofaTet</a>(</span><span class="m-dox-wrap">std::size_t nipfac,
              std::size_t nbfac,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;std::size_t&gt;&amp; triinpoel,
              const std::vector&lt;int&gt;&amp; esuelTet) -&gt; std::vector&lt;std::size_t&gt;</span>
            </dt>
            <dd>Generate derived data structure, node-face connectivity.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ad69e35d3f9e7f2237c0c5c3b9c5c0888" class="m-dox">genBelemTet</a>(</span><span class="m-dox-wrap">std::size_t nbfac,
              const std::vector&lt;std::size_t&gt;&amp; inpofa,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup) -&gt; std::vector&lt;std::size_t&gt;</span>
            </dt>
            <dd>Generate derived data structure, host/boundary element.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#abb68cb017ab503c71a4d58ad8323737c" class="m-dox">genGeoFaceTri</a>(</span><span class="m-dox-wrap">std::size_t nipfac,
              const std::vector&lt;std::size_t&gt;&amp; inpofa,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord) -&gt; Fields</span>
            </dt>
            <dd>Generate derived data structure, face geometry.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a8e4e79311cfbb84411a988b345c27a09" class="m-dox">normal</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; x,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; y,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; z) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;</span>
            </dt>
            <dd>Compute the unit normal vector of a triangle.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a8fd1bff99bc1afceca19f11735b8297d" class="m-dox">area</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; x,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; y,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; z) -&gt; <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a></span>
            </dt>
            <dd>Compute the area of a triangle.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ab6dc93c321bffbc6396d15a92ecfdf99" class="m-dox">geoFaceTri</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; x,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; y,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; z) -&gt; Fields</span>
            </dt>
            <dd>Compute geometry of the face given by three vertices.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a270eadffd276067dd536490955591430" class="m-dox">genGeoElemTet</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord) -&gt; Fields</span>
            </dt>
            <dd>Generate derived data structure, element geometry.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ab49591cb2d971a3dc0cd2bb29334922c" class="m-dox">leakyPartition</a>(</span><span class="m-dox-wrap">const std::vector&lt;int&gt;&amp; esueltet,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord) -&gt; bool</span>
            </dt>
            <dd>Perform leak-test on mesh (partition)</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aad0b322c0aa1ffd260a5117f6fffb020" class="m-dox">conforming</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              bool cerr,
              const std::vector&lt;std::size_t&gt;&amp; rid) -&gt; bool</span>
            </dt>
            <dd>Check if mesh (partition) is conforming.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#adb48770af89aaa8c6903aa60c20956e1" class="m-dox">intet</a>(</span><span class="m-dox-wrap">const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; p,
              std::size_t e,
              std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 4&gt;&amp; N) -&gt; bool</span>
            </dt>
            <dd>Determine if a point is in a tetrahedron.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a2be9c3302cc95370541eca0353c3e08b" class="m-dox">curl</a>(</span><span class="m-dox-wrap">const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; v) -&gt; <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a></span>
            </dt>
            <dd>Compute curl of a vector field at nodes of unstructured tetrahedra mesh.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#accc2f0b25920758e1a07f1eb0e80ba19" class="m-dox">div</a>(</span><span class="m-dox-wrap">const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; v) -&gt; std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;</span>
            </dt>
            <dd>Compute divergence of vector field at nodes of unstructured tetrahedra mesh.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a6f77a6120edfe8a5a1596cbc7f5b682f" class="m-dox">grad</a>(</span><span class="m-dox-wrap">const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; phi) -&gt; <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a></span>
            </dt>
            <dd>Compute gradient of a scalar field at nodes of unstructured tetrahedra mesh.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#ad72b139a74e8954c87fd9d0bd413e1c8" class="m-dox">normal</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x1,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x3,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y1,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y3,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z1,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z3,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; nx,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; ny,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; nz)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aa9d35ddc0df888b4c03f56407df6f664" class="m-dox">area</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x1,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x3,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y1,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y3,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z1,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z3) -&gt; <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a></span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aae5766a4d0dae70d561c514f2758072e" class="m-dox">nodegrad</a>(</span><span class="m-dox-wrap">std::size_t node,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup,
              const tk::Fields&amp; U,
              <a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> c) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;</span>
            </dt>
            <dd>Compute gradient at a mesh node.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a6310e8e153342ea9dfc433ff49006b66" class="m-dox">edgegrad</a>(</span><span class="m-dox-wrap">const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;std::size_t&gt;&amp; esued,
              const tk::Fields&amp; U,
              <a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> c) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;</span>
            </dt>
            <dd>Compute gradient at a mesh edge.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a293dd6fafcc3b8f4b28bef4f3ef050e1" class="m-dox">shiftToZero</a>(</span><span class="m-dox-wrap">std::vector&lt;std::size_t&gt;&amp; inpoel) -&gt; std::size_t</span>
            </dt>
            <dd>Shift node IDs to start with zero in element connectivity.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a261ac7b3e006f7fa6621ad910b6553cc" class="m-dox">remap</a>(</span><span class="m-dox-wrap">std::vector&lt;std::size_t&gt;&amp; ids,
              const std::vector&lt;std::size_t&gt;&amp; map)</span>
            </dt>
            <dd>Apply new mapping to vector of indices.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#af808bcf55ee4b5e910f68ecb0fe2f8dd" class="m-dox">remap</a>(</span><span class="m-dox-wrap">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; r,
              const std::vector&lt;std::size_t&gt;&amp; map)</span>
            </dt>
            <dd>Apply new mapping to vector of real numbers.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a75a9071479f742158c8e2af6d769296e" class="m-dox">remap</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; ids,
              const std::vector&lt;std::size_t&gt;&amp; map) -&gt; std::vector&lt;std::size_t&gt;</span>
            </dt>
            <dd>Create remapped vector of indices using a vector.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a1b909e9b0ca382a70d04369428b870b4" class="m-dox">remap</a>(</span><span class="m-dox-wrap">std::vector&lt;std::size_t&gt;&amp; ids,
              const std::unordered_map&lt;std::size_t, std::size_t&gt;&amp; map)</span>
            </dt>
            <dd>In-place remap vector of indices using a map.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#af12e0c9640bbca8b774394442f9e9594" class="m-dox">remap</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; ids,
              const std::unordered_map&lt;std::size_t, std::size_t&gt;&amp; map) -&gt; std::vector&lt;std::size_t&gt;</span>
            </dt>
            <dd>Create remapped vector of indices using a map.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a5cd7c3fd77cff6095f0d2627a784b6e7" class="m-dox">remap</a>(</span><span class="m-dox-wrap">const std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;&amp; ids,
              const std::unordered_map&lt;std::size_t, std::size_t&gt;&amp; map) -&gt; std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Create remapped map of vector of indices using a map.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a22a8b455edb4f8453d5a6173319f9c80" class="m-dox">renumber</a>(</span><span class="m-dox-wrap">const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; psup) -&gt; std::vector&lt;std::size_t&gt;</span>
            </dt>
            <dd>Reorder mesh points with the advancing front technique.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#acb19d7c5f6c7354614bb457d6b17afde" class="m-dox">assignLid</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; gid) -&gt; std::unordered_map&lt;std::size_t, std::size_t&gt;</span>
            </dt>
            <dd>Assign local ids to global ids.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a0ee7abd71123782d48e2ec04906fe982" class="m-dox">global2local</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; ginpoel) -&gt; std::tuple&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;, std::unordered_map&lt;std::size_t, std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate element connectivity of local node IDs from connectivity of global node IDs also returning the mapping between local to global IDs.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a6c5589db5d1caeac294a0b1569b65ebd" class="m-dox">positiveJacobians</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 3&gt;&amp; coord) -&gt; bool</span>
            </dt>
            <dd>Test positivity of the Jacobian for all cells in a mesh.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ab1b8944aeb6eae5bd8760a2928485139" class="m-dox">bfacenodes</a>(</span><span class="m-dox-wrap">const std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;&amp; bface,
              const std::vector&lt;std::size_t&gt;&amp; triinpoel) -&gt; std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;</span>
            </dt>
            <dd>Generate nodes of side set faces.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a7a2f751a9f985c66ae1980d220c50c75" class="m-dox">eval_gp</a>(</span><span class="m-dox-wrap">const std::size_t igp,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; coordfa,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 2&gt;&amp; coordgp) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;</span>
            </dt>
            <dd>Compute the coordinates of quadrature points for face integral.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aab2e57ac0b1baf8981558aa3a91764af" class="m-dox">eval_gp</a>(</span><span class="m-dox-wrap">const std::size_t igp,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 4&gt;&amp; coord,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coordgp) -&gt; std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;</span>
            </dt>
            <dd>Compute the coordinates of quadrature points for volume integral.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a31a683418acb38b655511b5195e705eb" class="m-dox">eval_dBdxi</a>(</span><span class="m-dox-wrap">const std::size_t ndof,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; coordgp) -&gt; std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;</span>
            </dt>
            <dd>Compute the derivatives of Dubiner basis wrt. reference coordinates.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a20a4a76c54a62ad526c6cace7d51b633" class="m-dox">eval_dBdx_p1</a>(</span><span class="m-dox-wrap">const std::size_t ndof,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; jacInv) -&gt; std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;</span>
            </dt>
            <dd>Compute the derivatives of basis function for DG(P1)</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a4f21cafccba0a899016b10f0b5dfe62b" class="m-dox">eval_dBdx_p2</a>(</span><span class="m-dox-wrap">const std::size_t igp,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coordgp,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; jacInv,
              std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; dBdx)</span>
            </dt>
            <dd>Compute the derivatives of basis function for DG(P2)</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a05283ead5075604d24ce31bd08f15e29" class="m-dox">eval_basis</a>(</span><span class="m-dox-wrap">const std::size_t ndof,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> xi,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> eta,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> zeta) -&gt; std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;</span>
            </dt>
            <dd>Compute the Dubiner basis functions.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a7f2d089704f8e4ba486a52f3b0dd1839" class="m-dox">eval_state</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              const std::size_t ndof_el,
              const std::size_t e,
              const Fields&amp; U,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B) -&gt; std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;</span>
            </dt>
            <dd>Compute the state variables for the tetrahedron element.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ace05c78061791953348607c3f58a0f9d" class="m-dox">DubinerToTaylor</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t e,
              const std::size_t ndof,
              const tk::Fields&amp; U,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; coord) -&gt; std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;</span>
            </dt>
            <dd>Transform the solution with Dubiner basis to the solution with Taylor basis.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#ad58a99eff3952dadd4750f4263cc2fe8" class="m-dox">TaylorToDubiner</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              std::size_t e,
              std::size_t ndof,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; coord,
              const tk::Fields&amp; geoElem,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; unk)</span>
            </dt>
            <dd>Convert the solution with Taylor basis to the solution with Dubiner basis.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a5da762c456f9c8fb0872f9e38d7beb92" class="m-dox">eval_TaylorBasis</a>(</span><span class="m-dox-wrap">const std::size_t ndof,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; x,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; x_c,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 4&gt;&amp; coordel) -&gt; std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;</span>
            </dt>
            <dd>Evaluate the Taylor basis at points.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a39a14210e3b0950ef04faac6796027f2" class="m-dox">DubinerToTaylorRefEl</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t e,
              const std::size_t ndof,
              const std::size_t ndof_el,
              const std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; mtInv,
              const tk::Fields&amp; U) -&gt; std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;</span>
            </dt>
            <dd>Transform the solution from Dubiner basis to Taylor basis.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a71612512ff454a48f3ba82a9976573e3" class="m-dox">TaylorToDubinerRefEl</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; unk)</span>
            </dt>
            <dd>Transform the solution from Taylor to Dubiner basis.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aaa3bc5f93f0ae004537f98d64e015e8a" class="m-dox">eval_TaylorBasisRefEl</a>(</span><span class="m-dox-wrap">std::size_t ndof,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> z) -&gt; std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;</span>
            </dt>
            <dd>Evaluate the Taylor basis at a point in the reference element.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aaefd147a807ea8ce52fa64c99527b9b1" class="m-dox">invMassMatTaylorRefEl</a>(</span><span class="m-dox-wrap">std::size_t dof) -&gt; std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;</span>
            </dt>
            <dd>Obtain inverse mass matrix for Taylor basis in reference element.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ab81f5b0a43cf0e18bad829649b285cf5" class="m-dox">massMatrixTaylorRefEl</a>(</span><span class="m-dox-wrap">std::size_t dof) -&gt; std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;</span>
            </dt>
            <dd>Obtain mass matrix for Taylor basis in reference element.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a232f493cf1cec91423df69a44bfdb2c5" class="m-dox">bndSurfInt</a>(</span><span class="m-dox-wrap">const bool pref,
              std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::vector&lt;std::size_t&gt;&amp; bcconfig,
              const <a href="classinciter_1_1_face_data.html" class="m-dox">inciter::<wbr />FaceData</a>&amp; fd,
              const Fields&amp; geoFace,
              const Fields&amp; geoElem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const <a href="namespacetk.html#ac36fb71a41ff5a1d9a41143652d61438" class="m-dox">RiemannFluxFn</a>&amp; flux,
              const <a href="namespacetk.html#ab96930c6425f28fde0af48eb346cc1ed" class="m-dox">VelFn</a>&amp; vel,
              const <a href="namespacetk.html#aea3cd7451f600631750f04f970ef6f6e" class="m-dox">StateFn</a>&amp; state,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              Fields&amp; R,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannDeriv,
              int intsharp)</span>
            </dt>
            <dd>Compute boundary surface flux integrals for a given boundary type for DG.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a454d85b03fabcb2bbd5d3c9a79db3b7a" class="m-dox">update_rhs_bc</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              std::size_t nmat,
              const std::size_t ndof,
              const std::size_t ndof_l,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; fn,
              const std::size_t el,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; fl,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B_l,
              Fields&amp; R,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannDeriv)</span>
            </dt>
            <dd>Update the rhs by adding the boundary surface integration term.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a23d73849c3644a212f6c4c0c457e3ade" class="m-dox">bndSurfIntFV</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t rdof,
              const std::vector&lt;std::size_t&gt;&amp; bcconfig,
              const <a href="classinciter_1_1_face_data.html" class="m-dox">inciter::<wbr />FaceData</a>&amp; fd,
              const Fields&amp; geoFace,
              const Fields&amp; geoElem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const <a href="namespacetk.html#ac36fb71a41ff5a1d9a41143652d61438" class="m-dox">RiemannFluxFn</a>&amp; flux,
              const <a href="namespacetk.html#ab96930c6425f28fde0af48eb346cc1ed" class="m-dox">VelFn</a>&amp; vel,
              const <a href="namespacetk.html#aea3cd7451f600631750f04f970ef6f6e" class="m-dox">StateFn</a>&amp; state,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;int&gt;&amp; srcFlag,
              Fields&amp; R,
              int intsharp)</span>
            </dt>
            <dd>Compute boundary surface flux integrals for a given boundary type for FV.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a2330cac84a48cb1ff2fb84d4f1ce68c0" class="m-dox">bndSurfIntViscousFV</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t rdof,
              const std::vector&lt;std::size_t&gt;&amp; bcconfig,
              const <a href="classinciter_1_1_face_data.html" class="m-dox">inciter::<wbr />FaceData</a>&amp; fd,
              const Fields&amp; geoFace,
              const Fields&amp; geoElem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const <a href="namespacetk.html#aea3cd7451f600631750f04f970ef6f6e" class="m-dox">StateFn</a>&amp; state,
              const <a href="namespacetk.html#aea3cd7451f600631750f04f970ef6f6e" class="m-dox">StateFn</a>&amp; gradFn,
              const Fields&amp; U,
              const Fields&amp; P,
              const Fields&amp; T,
              const std::vector&lt;int&gt;&amp; srcFlag,
              Fields&amp; R,
              int intsharp)</span>
            </dt>
            <dd>Compute boundary surface flux integrals for a given boundary type for FV.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a5e437639bfcdd6b5d9edf23efe736afd" class="m-dox">initialize</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const Fields&amp; L,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const <a href="namespacetk.html#af81ac0b2512a37ffcd2c86eda61ffb9e" class="m-dox">InitializeFn</a>&amp; solution,
              Fields&amp; unk,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const std::size_t nielem)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#ad6bb09243695c7fdfaea6ae8d3e6484e" class="m-dox">update_rhs</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; s,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; R)</span>
            </dt>
            <dd>Update the rhs by adding the initial analytical solution term.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#aae6bd4333d13dfffd40cde738719b9ec" class="m-dox">eval_init</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::size_t e,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; R,
              const Fields&amp; L,
              Fields&amp; unk)</span>
            </dt>
            <dd>Compute the initial conditions.</dd>
            <dt>
              <div class="m-dox-template">template&lt;class eq&gt;</div>
              <span class="m-dox-wrap-bumper">void <a href="#ae8a0facd864463216fe2b73eee8b02b5" class="m-dox">BoxElems</a>(</span><span class="m-dox-wrap">const tk::Fields&amp; geoElem,
              std::size_t nielem,
              std::vector&lt;std::unordered_set&lt;std::size_t&gt;&gt;&amp; inbox)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a0e1c25d76d7a0f5e791fb7ed1a70480c" class="m-dox">mass</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              <a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ndof,
              const Fields&amp; geoElem,
              Fields&amp; l)</span>
            </dt>
            <dd>Compute the block-diagnoal mass matrix for DG.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aa030103c8628271f28b884a78fe1592d" class="m-dox">lump</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel) -&gt; tk::Fields</span>
            </dt>
            <dd>Compute lumped mass matrix for CG.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a41aa06a834c1ec42178551ecc45445e0" class="m-dox">massMatrixDubiner</a>(</span><span class="m-dox-wrap">std::size_t dof,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> vol) -&gt; std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;</span>
            </dt>
            <dd>Compute the diagonal mass matrix for DG with Dubiner basis functions.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#aa210863fa60aeb1f1ca70797ec213179" class="m-dox">nonConservativeInt</a>(</span><span class="m-dox-wrap">const bool pref,
              std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::size_t nelem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannDeriv,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              Fields&amp; R,
              int intsharp)</span>
            </dt>
            <dd>Compute volume integrals of non-conservative terms for multi-material DG.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a840a0d1a42102ff7d58aa01e0398ca5f" class="m-dox">updateRhsNonCons</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t nmat,
              const std::size_t ndof,
              ] const std::size_t ndof_el,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::size_t e,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B,
              ] const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; dBdx,
              const std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; ncf,
              Fields&amp; R)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#af3da9b77f4830ab02eea3bb29cf4208d" class="m-dox">nonConservativeIntFV</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::size_t rdof,
              const std::size_t e,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; fn,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; var_riemann) -&gt; std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;</span>
            </dt>
            <dd>Compute volume integrals of non-conservative terms for multi-material FV.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#ab908a31e5b594bc395420d89d4705312" class="m-dox">pressureRelaxationInt</a>(</span><span class="m-dox-wrap">const bool pref,
              std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::size_t nelem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> ct,
              Fields&amp; R,
              int intsharp)</span>
            </dt>
            <dd>Compute volume integrals of pressure relaxation terms in multi-material DG.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#aad1a4bf50cd82a0249e72753d1beb5aa" class="m-dox">updateRhsPre</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              ] const std::size_t ndof_el,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::size_t e,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; ncf,
              Fields&amp; R)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a218c791cc73f982a80c04b99923b61f8" class="m-dox">pressureRelaxationIntFV</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t rdof,
              const std::size_t nelem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const Fields&amp; U,
              const Fields&amp; P,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> ct,
              Fields&amp; R)</span>
            </dt>
            <dd>Compute volume integrals of pressure relaxation terms in multi-material FV.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a0888955d3797d23fa3dd56876c12286c" class="m-dox">solvevriem</a>(</span><span class="m-dox-wrap">std::size_t nelem,
              const std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; vriem,
              const std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannLoc) -&gt; std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;</span>
            </dt>
            <dd>Solve the reconstruct velocity used for volume fraction equation.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a7d5d3a55b5a44c20e94fd470383f807e" class="m-dox">evaluRiemann</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const int e_left,
              const int e_right,
              const std::size_t nmat,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; fl,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; fn,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; gp,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 2&gt;&amp; state,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; vriem,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannLoc)</span>
            </dt>
            <dd>Compute the riemann velociry at the interface.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ac5e880fa846ad14a270989bf6c40b6ca" class="m-dox">fluxTerms</a>(</span><span class="m-dox-wrap">std::size_t ncomp,
              std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp;,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; ugp) -&gt; std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&gt;</span>
            </dt>
            <dd>Compute the flux-function for the multimaterial PDEs.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a0c1cbadd34268617c8c5992ec81b191d" class="m-dox-self" name="a0c1cbadd34268617c8c5992ec81b191d">updateRhsNonCons</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t nmat,
              const std::size_t ndof,
              const std::size_t ndof_el,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::size_t e,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; dBdx,
              const std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; ncf,
              Fields&amp; R)</span>
            </dt>
            <dd>Update the rhs by adding the non-conservative term integrals.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#aff87c9a4159b00bb29d9c3794401a931" class="m-dox-self" name="aff87c9a4159b00bb29d9c3794401a931">updateRhsPre</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              const std::size_t ndof_el,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::size_t e,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; ncf,
              Fields&amp; R)</span>
            </dt>
            <dd>Update the rhs by adding the pressure relaxation integrals.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a843d06b274313e564210eebe4ea2f90f" class="m-dox">NGvol</a>(</span><span class="m-dox-wrap">const std::size_t ndof) -&gt; std::size_t <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a9eb1a7ff5bb94c367fbb50e4af142174" class="m-dox">NGfa</a>(</span><span class="m-dox-wrap">const std::size_t ndof) -&gt; std::size_t <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#adabe655f67c84632f6883412875cf6af" class="m-dox">NGdiag</a>(</span><span class="m-dox-wrap">const std::size_t ndof) -&gt; std::size_t <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd>Initialization of number of Gauss points for volume integration in error estimation.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#aa70f5775e02bd3a02ec039d85644337c" class="m-dox">NGinit</a>(</span><span class="m-dox-wrap">const std::size_t ndof) -&gt; std::size_t <span class="m-label m-flat m-primary">constexpr</span></span>
            </dt>
            <dd>Initialization of number of Gauss points for volume integration in DG initialization.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#aca6fb44879789ccaa13aedc3726b8105" class="m-dox">GaussQuadratureTet</a>(</span><span class="m-dox-wrap">std::size_t NG,
              std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 3&gt;&amp; coordgp,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; wgp)</span>
            </dt>
            <dd>Initialize Gaussian quadrature points locations and weights for a tetrahedron.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#aacd73a16836192c36647a903548139b5" class="m-dox">GaussQuadratureTri</a>(</span><span class="m-dox-wrap">std::size_t NG,
              std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 2&gt;&amp; coordgp,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; wgp)</span>
            </dt>
            <dd>Initialize Gaussian quadrature points locations and weights for a triangle.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#ac890f6a0863964d93c0961187f6b79af" class="m-dox">solidTermsVolInt</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::size_t nelem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> dt,
              Fields&amp; R,
              int intsharp)</span>
            </dt>
            <dd>Compute Solid Terms with volume integrals.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#acea01580b595b144a1e320f916d8fe14" class="m-dox">update_rhs</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::size_t ndof,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::size_t e,
              const std::size_t solidx,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; s,
              Fields&amp; R)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a6ce3351b679fc43d842fa90c6564a3d4" class="m-dox">srcInt</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const std::size_t ndof,
              const std::size_t nelem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const <a href="namespacetk.html#a2cb83e9ba934b9ff1f9acc75c096e496" class="m-dox">SrcFn</a>&amp; src,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              Fields&amp; R,
              std::size_t nmat = 1)</span>
            </dt>
            <dd>Compute source term integrals for DG.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a1a9be85b697a1036068e5d73c74b7e35" class="m-dox">update_rhs</a>(</span><span class="m-dox-wrap">const std::size_t ndof,
              const std::size_t ndof_el,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::size_t e,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; s,
              Fields&amp; R)</span>
            </dt>
            <dd>Update the rhs by adding the source term integrals.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a95996daa8d78162e4b44b81df971a7bb" class="m-dox">srcIntFV</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const std::size_t nelem,
              const Fields&amp; geoElem,
              const <a href="namespacetk.html#a2cb83e9ba934b9ff1f9acc75c096e496" class="m-dox">SrcFn</a>&amp; src,
              Fields&amp; R,
              std::size_t nmat)</span>
            </dt>
            <dd>Compute source term integrals for FV.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a363af110ad72e8ef5ff5c17987fdf52e" class="m-dox">surfInt</a>(</span><span class="m-dox-wrap">const bool pref,
              std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;std::size_t&gt;&amp;,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const <a href="classinciter_1_1_face_data.html" class="m-dox">inciter::<wbr />FaceData</a>&amp; fd,
              const Fields&amp; geoFace,
              const Fields&amp; geoElem,
              const <a href="namespacetk.html#ac36fb71a41ff5a1d9a41143652d61438" class="m-dox">RiemannFluxFn</a>&amp; flux,
              const <a href="namespacetk.html#ab96930c6425f28fde0af48eb346cc1ed" class="m-dox">VelFn</a>&amp; vel,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>,
              Fields&amp; R,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannDeriv,
              int intsharp)</span>
            </dt>
            <dd>Compute internal surface flux integrals for DG.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#afffc8e3b481a3bcb24766e6941dbce24" class="m-dox">update_rhs_fa</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              std::size_t nmat,
              const std::size_t ndof,
              const std::size_t ndof_l,
              const std::size_t ndof_r,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; fn,
              const std::size_t el,
              const std::size_t er,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; fl,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B_l,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B_r,
              Fields&amp; R,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannDeriv)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#ae94d519916ce36020b4bab7e4dd1acc0" class="m-dox">surfIntFV</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const std::size_t rdof,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const <a href="classinciter_1_1_face_data.html" class="m-dox">inciter::<wbr />FaceData</a>&amp; fd,
              const Fields&amp; geoFace,
              const Fields&amp; geoElem,
              const <a href="namespacetk.html#ac36fb71a41ff5a1d9a41143652d61438" class="m-dox">RiemannFluxFn</a>&amp; flux,
              const <a href="namespacetk.html#ab96930c6425f28fde0af48eb346cc1ed" class="m-dox">VelFn</a>&amp; vel,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;int&gt;&amp; srcFlag,
              Fields&amp; R,
              int intsharp)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#acf712f142d7648f0ce6fef3c19cdd2d4" class="m-dox">surfIntViscousFV</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t rdof,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const <a href="classinciter_1_1_face_data.html" class="m-dox">inciter::<wbr />FaceData</a>&amp; fd,
              const Fields&amp; geoFace,
              const Fields&amp; geoElem,
              const Fields&amp; U,
              const Fields&amp; P,
              const Fields&amp; T,
              const std::vector&lt;int&gt;&amp; srcFlag,
              Fields&amp; R,
              int intsharp)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a8dd110ea94afea76ed15d89596b9251e" class="m-dox">modifiedGradientViscousFlux</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              std::size_t ncomp,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; fn,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 2&gt;&amp; centroids,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 2&gt;&amp; state,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 2&gt;&amp; cellAvgState,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 2&gt;&amp; cellAvgT,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt; dudx,
              const std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&gt;&amp; dTdx) -&gt; std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a499b0b041aa0b276af0e2bb6873d7f66" class="m-dox">volInt</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::size_t nelem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const <a href="namespacetk.html#ae5069d4cf4c8f3690d8f2ee0f0ada528" class="m-dox">FluxFn</a>&amp; flux,
              const <a href="namespacetk.html#ab96930c6425f28fde0af48eb346cc1ed" class="m-dox">VelFn</a>&amp; vel,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              Fields&amp; R,
              int intsharp = 0)</span>
            </dt>
            <dd>Compute volume integrals for DG.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a880695db2108c697d970c8adf8f8212c" class="m-dox">update_rhs</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              const std::size_t ndof_el,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::size_t e,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; dBdx,
              const std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&gt;&amp; fl,
              Fields&amp; R)</span>
            </dt>
            <dd>Update the rhs by adding the source term integrals.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#acb45afb1ba8be52d3e78def468b323d4" class="m-dox">recoLeastSqExtStencil</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t e,
              const std::map&lt;std::size_t, std::vector&lt;std::size_t&gt;&gt;&amp; esup,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const Fields&amp; geoElem,
              Fields&amp; W,
              const std::vector&lt;std::size_t&gt;&amp; varList)</span>
            </dt>
            <dd>Reconstruct the second-order solution using least-squares approach from an extended stencil involving the node-neighbors.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a80bfc61569a3b444de580d6bb4cb4b73" class="m-dox">transform_P0P1</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              Fields&amp; W,
              const std::vector&lt;std::size_t&gt;&amp; varList)</span>
            </dt>
            <dd>Transform the reconstructed P1-derivatives to the Dubiner dofs.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a0deba99cc2316aa55db08d7eaffe3b05" class="m-dox">THINCReco</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t nmat,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; ref_xp,
              const Fields&amp; U,
              const Fields&amp; P,
              bool intInd,
              const std::vector&lt;std::size_t&gt;&amp; matInt,
              ] const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; vfmin,
              ] const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; vfmax,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; state)</span>
            </dt>
            <dd></dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#ae4b7fb2bec31f04ddabc239814c57523" class="m-dox">THINCRecoTransport</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; ref_xp,
              const Fields&amp; U,
              const Fields&amp;,
              ] const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; vfmin,
              ] const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; vfmax,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; state)</span>
            </dt>
            <dd>Compute THINC reconstructions for linear advection (transport)</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#ab95e81d5ce7a25f8dabf6daf4b416c2b" class="m-dox">THINCFunction</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t nmat,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; ref_xp,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> vol,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> bparam,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; alSol,
              bool intInd,
              const std::vector&lt;std::size_t&gt;&amp; matInt,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; alReco)</span>
            </dt>
            <dd>Old THINC reconstruction function for volume fractions near interfaces.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a25edfdeb9950dd5bafdb83c99ba2f652" class="m-dox">THINCFunction_new</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t nmat,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; ref_xp,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> vol,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> bparam,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; alSol,
              bool intInd,
              const std::vector&lt;std::size_t&gt;&amp; matInt,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; alReco)</span>
            </dt>
            <dd>New THINC reconstruction function for volume fractions near interfaces.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a3273188a20dab1aa8e45c75208b148c0" class="m-dox">computeTemperaturesFV</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              std::size_t nmat,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; coord,
              const tk::Fields&amp; geoElem,
              const tk::Fields&amp; unk,
              const tk::Fields&amp; prim,
              const std::vector&lt;int&gt;&amp; srcFlag,
              tk::Fields&amp; T)</span>
            </dt>
            <dd>Compute the temperatures based on FV conserved quantities.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ac73cbceaded6427573280b5007a59e68" class="m-dox">evalPolynomialSol</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              int intsharp,
              std::size_t ncomp,
              std::size_t nprim,
              std::size_t rdof,
              std::size_t nmat,
              std::size_t e,
              std::size_t dof_e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; ref_gp,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; B,
              const Fields&amp; U,
              const Fields&amp; P) -&gt; std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;</span>
            </dt>
            <dd>Evaluate polynomial solution at quadrature point.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#afd24a15bdc96fbe72fdb63e2e236f90e" class="m-dox">evalFVSol</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              int intsharp,
              std::size_t ncomp,
              std::size_t nprim,
              std::size_t rdof,
              std::size_t nmat,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; ref_gp,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; B,
              const Fields&amp; U,
              const Fields&amp; P,
              int srcFlag) -&gt; std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;</span>
            </dt>
            <dd>Evaluate second-order FV solution at quadrature point.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#af11e7c9285b2517cda0e2f19b9e14476" class="m-dox">safeReco</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t nmat,
              std::size_t el,
              int er,
              const Fields&amp; U,
              std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 2&gt;&amp; state)</span>
            </dt>
            <dd>Compute safe reconstructions near material interfaces.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">void <a href="#a41c0eead44483d52998f0263da861f82" class="m-dox-self" name="a41c0eead44483d52998f0263da861f82">THINCReco</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t nmat,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; xp,
              const Fields&amp; U,
              const Fields&amp; P,
              bool intInd,
              const std::vector&lt;std::size_t&gt;&amp; matInt,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; vfmin,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; vfmax,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; state)</span>
            </dt>
            <dd>Compute THINC reconstructions near material interfaces.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a9911fa67ba7f72d5376474bc17869a0b" class="m-dox">serialize</a>(</span><span class="m-dox-wrap">std::size_t meshid,
              const std::vector&lt;<a href="classtk_1_1_uni_p_d_f.html" class="m-dox">tk::<wbr />UniPDF</a>&gt;&amp; u) -&gt; std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt;</span>
            </dt>
            <dd>Serialize univariate PDF to raw memory stream.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a24204b4ddfb41147330f02a8e6e7b760" class="m-dox">mergeUniPDFs</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs) -&gt; CkReductionMsg*</span>
            </dt>
            <dd>Charm++ custom reducer for merging a univariate PDF during reduction across PEs.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#a95434266ed0be6503251e90e0fe60823" class="m-dox">serialize</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classtk_1_1_uni_p_d_f.html" class="m-dox">tk::<wbr />UniPDF</a>&gt;&amp; u,
              const std::vector&lt;<a href="classtk_1_1_bi_p_d_f.html" class="m-dox">tk::<wbr />BiPDF</a>&gt;&amp; b,
              const std::vector&lt;<a href="classtk_1_1_tri_p_d_f.html" class="m-dox">tk::<wbr />TriPDF</a>&gt;&amp; t) -&gt; std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt;</span>
            </dt>
            <dd>Serialize vectors of PDFs to raw memory stream.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">auto <a href="#ab8753a2df233c9b1327d5682940ddcbf" class="m-dox">mergePDF</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs) -&gt; CkReductionMsg*</span>
            </dt>
            <dd>Charm++ custom reducer for merging PDFs during reduction across PEs.</dd>
            <dt>
              <span class="m-dox-wrap-bumper">static auto <a href="#ac0a63cccd84b6bd8b998cb4282adac23" class="m-dox">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::ostream&amp; os,
              const <a href="classtk_1_1_uni_p_d_f.html" class="m-dox">tk::<wbr />UniPDF</a>&amp; p) -&gt; std::ostream&amp;</span>
            </dt>
            <dd></dd>
          </dl>
        </section>
        <section id="var-members">
          <h2><a href="#var-members">Variables</a></h2>
          <dl class="m-dox">
            <dt>const uint8_t <a href="#a78da814ef7132a0958c47f987e3e711c" class="m-dox-self" name="a78da814ef7132a0958c47f987e3e711c">UnkEqComp</a></dt>
            <dd>Tags for selecting data layout policies.</dd>
            <dt>const std::array&lt;std::size_t, 2&gt; <a href="#afc6a4dbf99954fbde58f895283a8de43" class="m-dox">ExoNnpe</a></dt>
            <dd></dd>
            <dt>const std::array&lt;std::array&lt;std::size_t, 3&gt;, 4&gt; <a href="#a9445a95368496196e7c7560eccadbb09" class="m-dox">expofa</a></dt>
            <dd></dd>
            <dt>const std::array&lt;<a href="classtk_1_1_uns_mesh.html#ae8262763c870433021affc6bb5a0f804" class="m-dox">UnsMesh::<wbr />Face</a>, 4&gt; <a href="#a6ad0280af8cd383252a1b894ac9b3c96" class="m-dox">lpofa</a></dt>
            <dd></dd>
            <dt>const std::array&lt;<a href="classtk_1_1_uns_mesh.html#a622c34bab099c772650f046b848346d7" class="m-dox">UnsMesh::<wbr />Edge</a>, 6&gt; <a href="#a42b65132a3f4727cdbfa0947236a9269" class="m-dox-self" name="a42b65132a3f4727cdbfa0947236a9269">lpoed</a></dt>
            <dd>Const array defining the node ordering convention for tetrahedron edges.</dd>
            <dt>const std::array&lt;<a href="classtk_1_1_uns_mesh.html#a622c34bab099c772650f046b848346d7" class="m-dox">UnsMesh::<wbr />Edge</a>, 3&gt; <a href="#af5b6ccac4b260745a2391518e0fe8356" class="m-dox-self" name="af5b6ccac4b260745a2391518e0fe8356">lpoet</a></dt>
            <dd>Const array defining the node ordering convention for triangle edges.</dd>
            <dt>static highwayhash::HH_U64 <a href="#a07af9a3d86b90e1861bd16ded6a6ae87" class="m-dox">hh_key</a> <span class="m-label m-flat m-primary">constexpr</span></dt>
            <dd></dd>
            <dt>static std::stringstream <a href="#a4307002aaea65b7a520684a19984d23d" class="m-dox-self" name="a4307002aaea65b7a520684a19984d23d">cerr_quiet</a></dt>
            <dd>std::tringstream used to quiet std::cerr&#x27;s stream by redirecting to it</dd>
            <dt>static std::streambuf* <a href="#ac1c0b967994a7c9bb78f3129827b80c8" class="m-dox-self" name="ac1c0b967994a7c9bb78f3129827b80c8">cerr_old</a></dt>
            <dd>std::streambuf used to store state of std::cerr before redirecting it</dd>
          </dl>
        </section>
        <section>
          <h2>Enum documentation</h2>
          <section class="m-dox-details" id="afcc275d91d4368505f221061b9ba822a"><div>
            <h3>
              enum tk::<wbr /><a href="#afcc275d91d4368505f221061b9ba822a" class="m-dox-self">ErrCode</a>
            </h3>
            <p>Error codes for the OS (or whatever calls us)</p>
            <table class="m-table m-fullwidth m-flat m-dox">
              <thead><tr><th style="width: 1%">Enumerators</th><th></th></tr></thead>
              <tbody>
                <tr>
                  <td><a href="#afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3" class="m-dox-self" name="afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3">SUCCESS</a></td>
                  <td>
                  <p>Everything went fine.</p>
                  </td>
                </tr>
                <tr>
                  <td><a href="#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1" class="m-dox-self" name="afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">FAILURE</a></td>
                  <td>
                  <p>Exceptions occurred.</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a3781b50ef71ead8dd0bd286455c6030c"><div>
            <h3>
              enum class tk::<wbr /><a href="#a3781b50ef71ead8dd0bd286455c6030c" class="m-dox-self">ExoElemType</a>: int
            </h3>
<p>Supported ExodusII mesh cell types</p><aside class="m-note m-default"><h4>See also</h4><p><a href="classtk_1_1_exodus_i_i_mesh_reader.html#afe8144814a95bbb94d87e04091042918" class="m-dox">ExodusIIMeshReader::<wbr />readElemBlockIDs()</a></p></aside>
            <table class="m-table m-fullwidth m-flat m-dox">
              <thead><tr><th style="width: 1%">Enumerators</th><th></th></tr></thead>
              <tbody>
                <tr>
                  <td><a href="#a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170" class="m-dox-self" name="a85016961456a798f65e4e5a451e44242a268c4b76ec894ec6ad3c119ad7cc2170">TET</a></td>
                  <td>
                  </td>
                </tr>
                <tr>
                  <td><a href="#a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433" class="m-dox-self" name="a85016961456a798f65e4e5a451e44242a38b464161bf5019798797584babd0433">TRI</a></td>
                  <td>
                  </td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="ab84162b6a8fca5ac556cc8fafc8d4a77"><div>
            <h3>
              enum class tk::<wbr /><a href="#ab84162b6a8fca5ac556cc8fafc8d4a77" class="m-dox-self">Centering</a>: char
            </h3>
<p>Mesh/scheme centering types</p><aside class="m-note m-default"><h4>See also</h4><p>Control/Inciter/Options/Scheme.h</p></aside>
            <table class="m-table m-fullwidth m-flat m-dox">
              <thead><tr><th style="width: 1%">Enumerators</th><th></th></tr></thead>
              <tbody>
                <tr>
                  <td><a href="#ab84162b6a8fca5ac556cc8fafc8d4a77a0cc25b606fe928a0c9a58f7f209c4495" class="m-dox-self" name="ab84162b6a8fca5ac556cc8fafc8d4a77a0cc25b606fe928a0c9a58f7f209c4495">NODE</a></td>
                  <td>
                  </td>
                </tr>
                <tr>
                  <td><a href="#ab84162b6a8fca5ac556cc8fafc8d4a77ad3e3387a4f355276d41eefead65395c5" class="m-dox-self" name="ab84162b6a8fca5ac556cc8fafc8d4a77ad3e3387a4f355276d41eefead65395c5">ELEM</a></td>
                  <td>
                  </td>
                </tr>
              </tbody>
            </table>
          </div></section>
        </section>
        <section>
          <h2>Typedef documentation</h2>
          <section class="m-dox-details" id="a30c00988310413e9b96e131f8332b2b0"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class li, class lo&gt;
              </div>
              using tk::<wbr /><a href="#a30c00988310413e9b96e131f8332b2b0" class="m-dox-self">cartesian_product</a> = brigand::reverse_fold&lt;brigand::list&lt;li, lo&gt;, brigand::list&lt;brigand::list&lt;&gt;&gt;, brigand::bind&lt;brigand::join, brigand::bind&lt;brigand::transform, brigand::_2, brigand::defer&lt;brigand::bind&lt;brigand::join, brigand::bind&lt;brigand::transform, brigand::parent&lt;brigand::_1&gt;, brigand::defer&lt;brigand::bind&lt;brigand::list, brigand::bind&lt;brigand::push_front, brigand::_1, brigand::parent&lt;brigand::_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
            </h3>
<p>Cartesian product of two brigand lists</p><aside class="m-note m-default"><h4>See also</h4><p>brigand_source/test/apply.cpp</p></aside>
          </div></section>
          <section class="m-dox-details" id="ae1f47e67146a193c0f7e8dee7fa5d30d"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;std::size_t N&gt;
              </div>
              using tk::<wbr /><a href="#ae1f47e67146a193c0f7e8dee7fa5d30d" class="m-dox-self">Table</a> = std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, N+1&gt;&gt;
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">N</td>
                  <td>Number of ordinates in the table</td>
                </tr>
              </tbody>
            </table>
<p>Type alias for storing a discrete (y1,y2,...,yN) = f(x) function</p>
          </div></section>
          <section class="m-dox-details" id="afae1f1be5bf7e58189087d896b6d6ad4"><div>
            <h3>
              using tk::<wbr /><a href="#afae1f1be5bf7e58189087d896b6d6ad4" class="m-dox-self">NodeCommMap</a> = std::unordered_map&lt;int, <a href="namespacetk.html#acfc698cb2947f9062174488d7e162748" class="m-dox">NodeSet</a>&gt;
            </h3>
<p>Node communication map type</p><p>Global mesh node IDs bordering the mesh chunk held by fellow chares associated to chare IDs</p>
          </div></section>
          <section class="m-dox-details" id="a0b9698b4e675bcacfb5726151c08ea8e"><div>
            <h3>
              using tk::<wbr /><a href="#a0b9698b4e675bcacfb5726151c08ea8e" class="m-dox-self">EdgeCommMap</a> = std::unordered_map&lt;int, <a href="namespacetk.html#ae54c6184a6794b266a991f0f33e88f86" class="m-dox">EdgeSet</a>&gt;
            </h3>
<p>Edge communication map type</p><p>Edge-end points with global mesh node IDs bordering the mesh chunk held by fellow chares associated to chare IDs</p>
          </div></section>
          <section class="m-dox-details" id="aa1968d843c749b8901c9ffd71b3afb54"><div>
            <h3>
              using tk::<wbr /><a href="#aa1968d843c749b8901c9ffd71b3afb54" class="m-dox-self">CommMaps</a> = std::map&lt;int, <a href="namespacetk.html#a75788bc5ea5dc638a5981d8b8383abef" class="m-dox">AllCommMaps</a>&gt;
            </h3>
<p>Communication map bundle type</p><p>All types of communication maps bundled and associated to chare IDs</p>
          </div></section>
          <section class="m-dox-details" id="af81ac0b2512a37ffcd2c86eda61ffb9e"><div>
            <h3>
              using tk::<wbr /><a href="#af81ac0b2512a37ffcd2c86eda61ffb9e" class="m-dox-self">InitializeFn</a> = std::function&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;(<a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a>, const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp;, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>)&gt;
            </h3>
<p>Function prototype for Problem::intiialize() functions</p><p>Functions of this type are used to initialize the computed fields</p><aside class="m-note m-default"><h4>See also</h4><p>e.g., <a href="classinciter_1_1_comp_flow_problem_vortical_flow.html#aff41011dc7b471a50bb14fe30e53ba07" class="m-dox">inciter::<wbr />CompFlowProblemVorticalFlow::<wbr />initialize</a></p></aside><aside class="m-note m-info"><h4>Note</h4><p>Used for both continuous and discontinuous Galerkin discretizations</p></aside>
          </div></section>
          <section class="m-dox-details" id="ac36fb71a41ff5a1d9a41143652d61438"><div>
            <h3>
              using tk::<wbr /><a href="#ac36fb71a41ff5a1d9a41143652d61438" class="m-dox-self">RiemannFluxFn</a> = std::function&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;(const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp;, const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp;, const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 2&gt;&amp;, const std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&gt;&amp;)&gt;
            </h3>
<p>Function prototype for Riemann flux functions</p><p>Functions of this type are used to compute numerical fluxes across a surface using a Riemann solver</p><aside class="m-note m-default"><h4>See also</h4><p>e.g., <a href="structinciter_1_1_upwind.html" class="m-dox">inciter::<wbr />Upwind</a>, <a href="structinciter_1_1_lax_friedrichs.html" class="m-dox">inciter::<wbr />LaxFriedrichs</a>, <a href="structinciter_1_1_h_l_l_c.html" class="m-dox">inciter::<wbr />HLLC</a></p></aside>
          </div></section>
          <section class="m-dox-details" id="ae5069d4cf4c8f3690d8f2ee0f0ada528"><div>
            <h3>
              using tk::<wbr /><a href="#ae5069d4cf4c8f3690d8f2ee0f0ada528" class="m-dox-self">FluxFn</a> = std::function&lt;std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&gt;(<a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a>, const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp;, const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp;, const std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&gt;&amp;)&gt;
            </h3>
<p>Function prototype for flux vector functions</p><p>Functions of this type are used to compute physical flux functions in the PDEs being solved. These are different than the RiemannFluxFn because they compute the actual flux functions, not the solution to a Riemann problem.</p><aside class="m-note m-default"><h4>See also</h4><p>e.g., <a href="classinciter_1_1dg_1_1_transport.html#a0a47652e233c220fc7e363a5c3d34c8b" class="m-dox">inciter::<wbr />dg::<wbr />Transport::<wbr />flux</a>, <a href="classinciter_1_1dg_1_1_comp_flow.html#ac67e5366e75dc9e780ea2f84279420f9" class="m-dox">inciter::<wbr />dg::<wbr />CompFlow::<wbr />flux</a></p></aside>
          </div></section>
          <section class="m-dox-details" id="ab96930c6425f28fde0af48eb346cc1ed"><div>
            <h3>
              using tk::<wbr /><a href="#ab96930c6425f28fde0af48eb346cc1ed" class="m-dox-self">VelFn</a> = std::function&lt;std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&gt;(<a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>)&gt;
            </h3>
<p>Function prototype for evaluating a prescribed velocity field</p><p>Functions of this type are used to prescribe known velocity fields</p><aside class="m-note m-info"><h4>Note</h4><p>Used for scalar transport</p></aside><aside class="m-note m-default"><h4>See also</h4><p>e.g., TransportProblemShearDiff::prescribedVelocity</p></aside>
          </div></section>
          <section class="m-dox-details" id="aea3cd7451f600631750f04f970ef6f6e"><div>
            <h3>
              using tk::<wbr /><a href="#aea3cd7451f600631750f04f970ef6f6e" class="m-dox-self">StateFn</a> = std::function&lt;std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 2&gt;(<a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a>, const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp;, const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp;, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp;)&gt;
            </h3>
<p>Function prototype for physical boundary states</p><p>Functions of this type are used to provide the left and right states of boundary faces along physical boundaries</p>
          </div></section>
          <section class="m-dox-details" id="a2cb83e9ba934b9ff1f9acc75c096e496"><div>
            <h3>
              using tk::<wbr /><a href="#a2cb83e9ba934b9ff1f9acc75c096e496" class="m-dox-self">SrcFn</a> = std::function&lt;void(<a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a>, const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp;, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp;)&gt;
            </h3>
<p>Function prototype for evaluating a source term</p><p>Functions of this type are used to evaluate an arbitrary source term specialized to a particular problem, e.g., derived using the method of manufactured solutions</p><aside class="m-note m-default"><h4>See also</h4><p>e.g., CompFlowProblemRayleighTaylor::src</p></aside>
          </div></section>
        </section>
        <section>
          <h2>Function documentation</h2>
          <section class="m-dox-details" id="a87af1b002bc711716bd170a714bda211"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Container&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a87af1b002bc711716bd170a714bda211" class="m-dox-self">unique</a>(</span><span class="m-dox-wrap">Container&amp; c)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">c&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Container</td>
                </tr>
              </tbody>
            </table>
<p>Make elements of container unique (in-place, overwriting source container)</p>
          </div></section>
          <section class="m-dox-details" id="a33be2bf221a519d736333a9f18c8ffdc"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Container&gt;
              </div>
              <span class="m-dox-wrap-bumper">Container tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a33be2bf221a519d736333a9f18c8ffdc" class="m-dox-self">uniquecopy</a>(</span><span class="m-dox-wrap">const Container&amp; src)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">src&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Container</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Container containing only unique elements compared to src</td>
                </tr>
              </tfoot>
            </table>
<p>Make elements of container unique (on a copy, leaving the source as is)</p>
          </div></section>
          <section class="m-dox-details" id="a907b848a4d232ecacb8eb34182c7b26c"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename Container&gt;
              </div>
              <span class="m-dox-wrap-bumper">auto tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a907b848a4d232ecacb8eb34182c7b26c" class="m-dox-self">cref_find</a>(</span><span class="m-dox-wrap">const Container&amp; map,
              const typename Container::key_type&amp; key) -&gt; const typename Container::mapped_type &amp;</span></span>
            </h3>
            <p>Find and return a constant reference to value for key in container that provides a find() member function with error handling.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Map associating values to keys</td>
                </tr>
                <tr>
                  <td>key&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Key to search for</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>A constant reference to the value associated to the key in map</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>If key is not found an exception is thrown.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a882a6f0eaec378f90eaac07cf46cb12c"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename Container&gt;
              </div>
              <span class="m-dox-wrap-bumper">auto tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a882a6f0eaec378f90eaac07cf46cb12c" class="m-dox-self">ref_find</a>(</span><span class="m-dox-wrap">const Container&amp; map,
              const typename Container::key_type&amp; key) -&gt; typename Container::mapped_type &amp;</span></span>
            </h3>
            <p>Find and return a reference to value for key in a container that provides a find() member function with error handling.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Map associating values to keys</td>
                </tr>
                <tr>
                  <td>key&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Key to search for</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>A reference to the value associated to the key in map</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>If key is not found an exception is thrown.</p></aside>
          </div></section>
          <section class="m-dox-details" id="af0de4157a7818da7a9deb1476099bd8d"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::array&lt;T, 2&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af0de4157a7818da7a9deb1476099bd8d" class="m-dox-self">extents</a>(</span><span class="m-dox-wrap">const std::vector&lt;T&gt;&amp; vec)</span></span>
            </h3>
            <p>Return minimum and maximum values of a vector.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">vec&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector whose extents to compute</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Array of two values with the minimum and maximum values</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>This function should not be called with heavy T types, as the a copy of a std::array&lt; T, 2 &gt; is created and returned.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a1930c11b6d90076b9d17c9f9c9d49efe"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename Container&gt;
              </div>
              <span class="m-dox-wrap-bumper">auto tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a1930c11b6d90076b9d17c9f9c9d49efe" class="m-dox-self">extents</a>(</span><span class="m-dox-wrap">const Container&amp; map) -&gt; std::array&lt; typename Container::mapped_type, 2 &gt;</span></span>
            </h3>
            <p>Find and return minimum and maximum values in associative container.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Map whose extents of values to find</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Array of two values with the minimum and maximum values in the map</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>This function should not be called with heavy Value types, as the a copy of a std::array&lt; Value, 2 &gt; is created and returned.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a0992ad19886e651975f3458f8c6ec246"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class T, std::size_t N&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::array&lt;T, N&gt;&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a0992ad19886e651975f3458f8c6ec246" class="m-dox-self">operator+=</a>(</span><span class="m-dox-wrap">std::array&lt;T, N&gt;&amp; dst,
              const std::array&lt;T, N&gt;&amp; src)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">dst&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Destination array, i.e., left-hand side of a1 += a2</td>
                </tr>
                <tr>
                  <td>src&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Source array, i.e., righ-hand side of a1 += a2</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Destination containing a1[0] += a2[0], a1[1] += a2[1], ...</td>
                </tr>
              </tfoot>
            </table>
<p>Add all elements of an array to those of another one</p>
          </div></section>
          <section class="m-dox-details" id="ad47c993218d9384828fcce2794850ac7"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class T, class Allocator&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::vector&lt;T, Allocator&gt;&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad47c993218d9384828fcce2794850ac7" class="m-dox-self">operator+=</a>(</span><span class="m-dox-wrap">std::vector&lt;T, Allocator&gt;&amp; dst,
              const std::vector&lt;T, Allocator&gt;&amp; src)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">dst&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Destination vector, i.e., left-hand side of v1 += v2</td>
                </tr>
                <tr>
                  <td>src&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Source vector, i.e., righ-hand side of v1 += v2</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Destination containing v1[0] += v2[0], v1[1] += v2[1], ...</td>
                </tr>
              </tfoot>
            </table>
<p>Add all elements of a vector to those of another one 

If src.size() &gt; dst.size() will grow dst to that of src.size() padding with zeros.</p><aside class="m-note m-info"><h4>Note</h4><p>Will throw exception in DEBUG if src is empty (to warn on no-op), and if src.size() &lt; dst.size() (to warn on loosing data).</p></aside>
          </div></section>
          <section class="m-dox-details" id="abac51edb62bae02ce65993e726320410"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class T, class Allocator&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::vector&lt;T, Allocator&gt;&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#abac51edb62bae02ce65993e726320410" class="m-dox-self">operator/=</a>(</span><span class="m-dox-wrap">std::vector&lt;T, Allocator&gt;&amp; dst,
              const std::vector&lt;T, Allocator&gt;&amp; src)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">dst&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Destination vector, i.e., left-hand side of v1 /= v2</td>
                </tr>
                <tr>
                  <td>src&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Source vector, i.e., righ-hand side of v1 /= v2</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Destination containing v1[0] /= v2[0], v1[1] /= v2[1], ...</td>
                </tr>
              </tfoot>
            </table>
<p>Divide all elements of a vector with those of another one 

If src.size() &gt; dst.size() will grow dst to that of src.size() padding with zeros.</p><aside class="m-note m-info"><h4>Note</h4><p>Will throw exception in DEBUG if src is empty (to warn on no-op), and if src.size() &lt; dst.size() (to warn on loosing data).</p></aside>
          </div></section>
          <section class="m-dox-details" id="a05866fa57031940dc4ba5d4665847016"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class C1, class C2&gt;
              </div>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a05866fa57031940dc4ba5d4665847016" class="m-dox-self">keyEqual</a>(</span><span class="m-dox-wrap">const C1&amp; a,
              const C2&amp; b)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">a&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st container to compare</td>
                </tr>
                <tr>
                  <td>b&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd container to compare</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if the containers have the same size and all keys (and only the keys) of the two containers are equal</td>
                </tr>
              </tfoot>
            </table>
<p>Test if all keys of two associative containers are equal</p><aside class="m-note m-info"><h4>Note</h4><p>It is an error to call this function with unequal-size containers, triggering an exception in DEBUG mode.</p><p>Operator != is used to compare the container keys.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a0f319a47a6a5b983e161aa5f4d8f7b6c"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Container&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a0f319a47a6a5b983e161aa5f4d8f7b6c" class="m-dox-self">sumsize</a>(</span><span class="m-dox-wrap">const Container&amp; c)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Container of containers</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Sum of the sizes of the containers of the container</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the sum of the sizes of a container of containers</p>
          </div></section>
          <section class="m-dox-details" id="ace2a28e46e910dd6356eec7d627f85dc"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Container&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ace2a28e46e910dd6356eec7d627f85dc" class="m-dox-self">numunique</a>(</span><span class="m-dox-wrap">const Container&amp; c)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Container of containers</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Number of unique values in a container of containers</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the number of unique values in a container of containers</p>
          </div></section>
          <section class="m-dox-details" id="a357e40550c113066882bc3e3c3cf52b8"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Map&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a357e40550c113066882bc3e3c3cf52b8" class="m-dox-self">sumvalsize</a>(</span><span class="m-dox-wrap">const Map&amp; c)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Map</td>
                  <td>Container of containers type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Container of containers</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Sum of the sizes of the values of the associative container</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the sum of the sizes of the values of an associative container</p>
          </div></section>
          <section class="m-dox-details" id="a9140b408dcbd2eaef58f9c3a54fa104a"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Container&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a9140b408dcbd2eaef58f9c3a54fa104a" class="m-dox-self">destroy</a>(</span><span class="m-dox-wrap">Container&amp; c)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Container defining a swap() member function</td>
                </tr>
              </tbody>
            </table>
<p>Free memory of a container 
See <a href="http://stackoverflow.com/a/10465032">http:/<wbr />/<wbr />stackoverflow.com/<wbr />a/<wbr />10465032</a> as to why this is done with the swap() member function of the container.</p><aside class="m-note m-default"><h4>See also</h4><p>Specializations of std::swap are documented at <a href="http://en.cppreference.com/w/cpp/algorithm/swap">http:/<wbr />/<wbr />en.cppreference.com/<wbr />w/<wbr />cpp/<wbr />algorithm/<wbr />swap</a></p></aside>
          </div></section>
          <section class="m-dox-details" id="a38a390b2dd9f091d2ca7465208a960ed"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename Container, typename Predicate&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a38a390b2dd9f091d2ca7465208a960ed" class="m-dox-self">erase_if</a>(</span><span class="m-dox-wrap">Container&amp; items,
              const Predicate&amp; predicate)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Container</td>
                  <td>Type of container to remove from</td>
                </tr>
                <tr>
                  <td>Predicate</td>
                  <td>Type for functor defining the predicate</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>items</td>
                  <td>Container object to remove from</td>
                </tr>
                <tr>
                  <td>predicate</td>
                  <td>Predicate object instance to use</td>
                </tr>
              </tbody>
            </table>
<p>Remove items from container based on predicate</p>
          </div></section>
          <section class="m-dox-details" id="a228ffc383c02503a4b6018b25996f2ae"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class T&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a228ffc383c02503a4b6018b25996f2ae" class="m-dox-self">concat</a>(</span><span class="m-dox-wrap">std::vector&lt;T&gt;&amp;&amp; src,
              std::vector&lt;T&gt;&amp; dst)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>Vector value type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>src&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Source vector (moved from)</td>
                </tr>
                <tr>
                  <td>dst&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Destination vector</td>
                </tr>
              </tbody>
            </table>
<p>Concatenate vectors of T</p>
          </div></section>
          <section class="m-dox-details" id="a8a66b9309d4065593f466b35c61510f1"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class T&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a8a66b9309d4065593f466b35c61510f1" class="m-dox-self">concat</a>(</span><span class="m-dox-wrap">std::vector&lt;std::pair&lt;bool, T&gt;&gt;&amp;&amp; src,
              std::vector&lt;std::pair&lt;bool, T&gt;&gt;&amp; dst)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>Vector value type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>src&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Source vector (moved from)</td>
                </tr>
                <tr>
                  <td>dst&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Destination vector</td>
                </tr>
              </tbody>
            </table>
<p>Overwrite vectors of pair&lt; bool, tk::real &gt;</p>
          </div></section>
          <section class="m-dox-details" id="a48e3038d2c19125151bf84caad6d7ae9"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class Eq = std::equal_to&lt;Key&gt;&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a48e3038d2c19125151bf84caad6d7ae9" class="m-dox-self">concat</a>(</span><span class="m-dox-wrap">std::unordered_set&lt;Key, Hash, Eq&gt;&amp;&amp; src,
              std::unordered_set&lt;Key, Hash, Eq&gt;&amp; dst)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Key</td>
                  <td>Set key</td>
                </tr>
                <tr>
                  <td>Hash</td>
                  <td>Set hasher</td>
                </tr>
                <tr>
                  <td>Eq</td>
                  <td>Set equality operator</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>src&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Source set (moved from)</td>
                </tr>
                <tr>
                  <td>dst&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Destination set</td>
                </tr>
              </tbody>
            </table>
<p>Concatenate unordered sets</p>
          </div></section>
          <section class="m-dox-details" id="a433a341b79ff4eab8ca99e66a67de578"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Key, class Value&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::ostream&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a433a341b79ff4eab8ca99e66a67de578" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::ostream&amp; os,
              const std::pair&lt;const Key, Value&gt;&amp; v)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">os&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Output stream to write to</td>
                </tr>
                <tr>
                  <td>v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>value_type entry of a map</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Updated output stream</td>
                </tr>
              </tfoot>
            </table>
<p>Operator &lt;&lt; for writing value_type of a standard map to output streams</p>
          </div></section>
          <section class="m-dox-details" id="ad3c124a1502656b2b17aab7aaefbec0c"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::string tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad3c124a1502656b2b17aab7aaefbec0c" class="m-dox-self">parameter</a>(</span><span class="m-dox-wrap">const T&amp; v)</span></span>
            </h3>
            <p>Convert and return value as string.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>Value type for input</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Value for input to return as a string</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>String for input value</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a31d32eb5c332a0116f9c45eca4450b66"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename V&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::string tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a31d32eb5c332a0116f9c45eca4450b66" class="m-dox-self">parameters</a>(</span><span class="m-dox-wrap">const V&amp; v)</span></span>
            </h3>
            <p>Convert and return values from container as string.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">V</td>
                  <td>Container range for works on</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Container whose components to return as a string</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Concatenated string of values read from a container</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="adc362fc7a89c617e1ab8f57f1dbd100a"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;uint8_t Layout&gt;
              </div>
              <span class="m-dox-wrap-bumper"><a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#adc362fc7a89c617e1ab8f57f1dbd100a" class="m-dox-self">operator*</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">lhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Scalar to multiply with</td>
                </tr>
                <tr>
                  <td>rhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Date object to multiply</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>New <a href="classtk_1_1_data.html" class="m-dox">Data</a> object with all items multipled with lhs</td>
                </tr>
              </tfoot>
            </table>
<p>Operator * multiplying all items by a scalar from the left</p>
          </div></section>
          <section class="m-dox-details" id="afd730d099e698f124362ef8c01483e0f"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;uint8_t Layout&gt;
              </div>
              <span class="m-dox-wrap-bumper"><a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#afd730d099e698f124362ef8c01483e0f" class="m-dox-self">min</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; a,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; b)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">a&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st <a href="classtk_1_1_data.html" class="m-dox">Data</a> object</td>
                </tr>
                <tr>
                  <td>b&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd <a href="classtk_1_1_data.html" class="m-dox">Data</a> object</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>New <a href="classtk_1_1_data.html" class="m-dox">Data</a> object containing the minimum of all values for each value in <em>a</em> and <em>b</em></td>
                </tr>
              </tfoot>
            </table>
<p>Operator min between two <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects</p><aside class="m-note m-info"><h4>Note</h4><p>The <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects <em>a</em> and <em>b</em> must have the same number of unknowns and properties.</p><p>As opposed to std::min, this function creates and returns a new object instead of returning a reference to one of the operands.</p></aside>
          </div></section>
          <section class="m-dox-details" id="ac9a26e30d19b940a12990a866a514cb5"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;uint8_t Layout&gt;
              </div>
              <span class="m-dox-wrap-bumper"><a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac9a26e30d19b940a12990a866a514cb5" class="m-dox-self">max</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; a,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; b)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">a&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st <a href="classtk_1_1_data.html" class="m-dox">Data</a> object</td>
                </tr>
                <tr>
                  <td>b&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd <a href="classtk_1_1_data.html" class="m-dox">Data</a> object</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>New <a href="classtk_1_1_data.html" class="m-dox">Data</a> object containing the maximum of all values for each value in <em>a</em> and <em>b</em></td>
                </tr>
              </tfoot>
            </table>
<p>Operator max between two <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects</p><aside class="m-note m-info"><h4>Note</h4><p>The <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects <em>a</em> and <em>b</em> must have the same number of unknowns and properties.</p><p>As opposed to std::max, this function creates and returns a new object instead of returning a reference to one of the operands.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a21669e4d06c62a58cd0f4bf63868ab7e"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;uint8_t Layout&gt;
              </div>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a21669e4d06c62a58cd0f4bf63868ab7e" class="m-dox-self">operator==</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">lhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><a href="classtk_1_1_data.html" class="m-dox">Data</a> object to compare</td>
                </tr>
                <tr>
                  <td>rhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><a href="classtk_1_1_data.html" class="m-dox">Data</a> object to compare</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if all entries are equal up to epsilon</td>
                </tr>
              </tfoot>
            </table>
<p>Operator == between two <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects</p>
          </div></section>
          <section class="m-dox-details" id="ac38f5055c45cd35b8ce00151cea4c1d3"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;uint8_t Layout&gt;
              </div>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac38f5055c45cd35b8ce00151cea4c1d3" class="m-dox-self">operator!=</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">lhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><a href="classtk_1_1_data.html" class="m-dox">Data</a> object to compare</td>
                </tr>
                <tr>
                  <td>rhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><a href="classtk_1_1_data.html" class="m-dox">Data</a> object to compare</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if all entries are unequal up to epsilon</td>
                </tr>
              </tfoot>
            </table>
<p>Operator != between two <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects</p>
          </div></section>
          <section class="m-dox-details" id="ab7f02155bc2945a0a0c82c1be5cad041"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;uint8_t Layout&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::size_t, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab7f02155bc2945a0a0c82c1be5cad041" class="m-dox-self">maxdiff</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; lhs,
              const <a href="classtk_1_1_data.html" class="m-dox">Data</a>&lt;Layout&gt;&amp; rhs)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">lhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st <a href="classtk_1_1_data.html" class="m-dox">Data</a> object</td>
                </tr>
                <tr>
                  <td>rhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd <a href="classtk_1_1_data.html" class="m-dox">Data</a> object</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>The index, i.e., the raw position, of and the largest absolute value of the difference between all corresponding elements of <em>lhs</em> and <em>rhs</em>.</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the maximum difference between the elements of two <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects 

The position returned is the position in the underlying raw data structure, independent of components, etc. If lhs == rhs with precision std::numeric_limits&lt; tk::real &gt;::epsilon(), a pair of (0,0.0) is returned.</p><aside class="m-note m-info"><h4>Note</h4><p>The <a href="classtk_1_1_data.html" class="m-dox">Data</a> objects <em>lhs</em> and <em>rhs</em> must have the same number of unknowns and properties.</p></aside>
          </div></section>
          <section class="m-dox-details" id="ad986ef5558d44d5e0c6650c589499980"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class C, class Key, class Factory, typename... ConstructorArgs&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad986ef5558d44d5e0c6650c589499980" class="m-dox-self">record</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ConstructorArgs&amp;&amp;... args)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">f&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Factory to register to (std::map with value using reference semantics)</td>
                </tr>
                <tr>
                  <td>key&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Key used to identify the entry in the factory</td>
                </tr>
                <tr>
                  <td>args&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Variable number of arguments to pass to the constructor being registered. Note that the constructor arguments are only bound to the constructor and stored in the factory (an std::map with value using reference semantics). The object is not instantiated here, i.e., the constructor is not called here. The object can be instantiated by function instantiate.</td>
                </tr>
              </tbody>
            </table>
<p>Register class into factory with given key. This is used to register a derived-class object&#x27;s constructor (deriving from some base class) to a factory. The factory itself is a std::map&lt; key, std::function&lt; Child*() &gt; &gt;, i.e., an associative container, associating some key to a std::function object holding a pointer of Child&#x27;s base class constructor. The constructor and its bound arguments are stored via boost::factory, which, in this use-case, yields the correct function object of type Base constructor pointer and thus facilitates runtime polymorphism. This function works in conjunction with boost::factory, i.e., uses reference semantics (works with storing pointers of objects). For a simple example on how to use this function, see tests/unit/Base/Factory.h.</p><aside class="m-note m-default"><h4>See also</h4><p><a href="namespacetk.html#aeb9673379e599043b13fff369dce1402" class="m-dox">instantiate</a></p></aside>
          </div></section>
          <section class="m-dox-details" id="aeb9673379e599043b13fff369dce1402"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Factory, class Key, class Obj = typename std::remove_pointer&lt;                       typename Factory::mapped_type::result_type&gt;::type&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::unique_ptr&lt;Obj&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aeb9673379e599043b13fff369dce1402" class="m-dox-self">instantiate</a>(</span><span class="m-dox-wrap">const Factory&amp; f,
              const Key&amp; key)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">f&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Factory to instantiate object from (std::map with value using reference semantics)</td>
                </tr>
                <tr>
                  <td>key&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Key used to identify the object to instantiate from factory</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>std::unique_ptr pointing to the object instantiated from factory</td>
                </tr>
              </tfoot>
            </table>
<p>Instantiate object from factory. Factory must have a mapped_value which must have a result_type ptr, e.g., std::map&lt; Key, std::function&lt; Obj*() &gt; &gt;. This wrapper function can be used to instantiate an derived-class object from a factory, repeatedly filled with wrapper function &#x27;record&#x27; above. The factory, as described in the documentation of &#x27;record&#x27;, stores base class pointers in an associative container, thereby facilitating runtime polymorphism and a simple lookup-and-instantiate-style object creation. The object instantiated is of type Child class. This function works in conjunction with boost::factory, i.e., uses reference semantics (works with storing pointers of objects). For a simple example on how to use this function, see tests/unit//Base/Factory.h.</p><aside class="m-note m-default"><h4>See also</h4><p><a href="namespacetk.html#ad986ef5558d44d5e0c6650c589499980" class="m-dox">record</a></p></aside>
          </div></section>
          <section class="m-dox-details" id="a24170c3146caaa7b79d78d4aa1d98f66"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Host, class ModelConstructor, class Factory, class Key, typename... ModelConstrArgs&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a24170c3146caaa7b79d78d4aa1d98f66" class="m-dox-self">recordModel</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ModelConstrArgs&amp;&amp;... args)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">f&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Factory to register to (std::map with value using value semantics)</td>
                </tr>
                <tr>
                  <td>key&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Key used to identify the entry in the factory</td>
                </tr>
                <tr>
                  <td>args&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Variable number of arguments to pass to the constructor being registered. Note that the constructor arguments are only bound to the constructor and stored in the factory (an std::map with value using value semantics). The object is not instantiated here, i.e., the constructor is not called here. The object can be instantiated by simply calling the function call operator () on the mapped value. For an example, RNGStack::selected() in RNG/RNGStack.C.</td>
                </tr>
              </tbody>
            </table>
<p>Register &quot;model&quot; class of &quot;host&quot; into factory with given key. This wrapper can be used to in a similar manner to &#x27;record&#x27;, but uses boost::value_factory to bind the model object constructor to its arguments and place it in the associative container storing host class objects. The container is thus of type std::map&lt; key, std::function&lt; T() &gt; &gt;, i.e., associating a key to a function holding a constructor (and not its pointer). Runtime polymorphism here is realized entirely within the &quot;base&quot; class. See walker::DiffEq in DiffEq/DiffEq.h for an example and more information on runtime polymorphism without client-side inheritance. As a result, this wrapper works with factories that use value semantics, as opposed to &#x27;record&#x27; and instantiate which work with reference semantics factories. In order to differentiate between runtime polymorphic classes using reference semantics, consistent with classes realizing runtime polymorphism without client-side inheritance, we call Host as the &quot;Base&quot; class and Model as the &quot;derived&quot; (or child) class. This wrapper function works in conjunction with boost::value_factory, i.e., uses value semantics (works with storing objects instead of object pointers). For a simple example on how to use this function, see tests/unit//Base/Factory.h.</p>
          </div></section>
          <section class="m-dox-details" id="aa787e22ae8d722011d9cbddf1e7354ba"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Host, class ModelConstructor, class Factory, class Key&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa787e22ae8d722011d9cbddf1e7354ba" class="m-dox-self">recordModelLate</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">f&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Factory to register to (std::map with value using value semantics)</td>
                </tr>
                <tr>
                  <td>key&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Key used to identify the entry in the factory</td>
                </tr>
              </tbody>
            </table>
<p>Register model class of host into factory with given key using late binding. This variant of &#x27;record&#x27; is very similar to &#x27;recordModel&#x27;, but registers a model class constructor to a factory with late binding of the constructor argument. Late binding allows specifying the constructor argument at the time when the object is instantiated instead of at the time when it is registered. This has all the benefits of using a factory and allows passing information into the model object only when it is available. The late bind is facilitated via std::bind instead of std::bind using a placeholder, _1, which stands for the first argument (bound later, i.e., not here). The value of the model constructor argument is then not used here, only its type, used to perform the late binding. The binding happens to both the model constructor via std::function (passed to the host constructor) as well as explicitly to the host constructor. Prescribing late binding to the model constructor ensures that the compiler requires the argument to the model constructor, i.e., ensures that the host constructor is required to pass the argument to the model constructor. Prescribing late binding to the host constructor puts in the actual request that an argument (with the correct type) must be passed to the host constructor at instantiate time, which then will forward it to the model constructor. See also, for example, walker::DiffEq&#x27;s corresponding constructor. An example of client-side code is in walker::DiffEqStack::registerDiffEq for registration into factory, and DiffEqStack::createDiffEq for instantiation late-passing the argument.</p><aside class="m-note m-danger"><h4>Warning</h4><p>Only works with a single constructor argument</p></aside>
          </div></section>
          <section class="m-dox-details" id="a4bd6374b4792dbd3c626dad60bcef168"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Host, class ModelConstructor, class Factory, class Key, typename... ModelConstrArgs&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a4bd6374b4792dbd3c626dad60bcef168" class="m-dox-self">recordCharmModel</a>(</span><span class="m-dox-wrap">Factory&amp; f,
              const Key&amp; key,
              ModelConstrArgs&amp;&amp;... args)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">f&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Factory to register to (std::map with value using value semantics)</td>
                </tr>
                <tr>
                  <td>key&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Key used to identify the entry in the factory</td>
                </tr>
                <tr>
                  <td>args&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Variable number of arguments to pass to the constructor being registered.</td>
                </tr>
              </tbody>
            </table>
<p>Register Charm++ model class of host into factory with given key. We bind a host constructor to its arguments of which the first one is a std::function holding a model constructor type (modeling, i.e., used polymorhically with host), followed by an optional number of others (possibly zero) with arbitrary types. Note that the model constructor is a nullptr (default- constructed) and only used to forward its type to the call site inside std::function. The host constructor function is then placed into the factory. This is because Charm++ chares do not explicitly invoke constructors, only call ckNew() on their proxy, which requires all constructor arguments to be present and forwarded to the actual constructor that is only called at a later point in time. This can then be used by those constructors of hosts that invoke the model constructors&#x27; proxies&#x27; ckNew() and ignore the std::function. See, e.g., rngtest::Battery() and the associated unit tests in tests/unit//Base/Factory.h.</p>
          </div></section>
          <section class="m-dox-details" id="ac2323b3c43edbcc32d55d91100ffc3a6"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename A, typename B&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::pair&lt;B, A&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac2323b3c43edbcc32d55d91100ffc3a6" class="m-dox-self">flip_pair</a>(</span><span class="m-dox-wrap">const std::pair&lt;A, B&gt;&amp; p)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">p&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>std::pair of arbitrary types, A and B</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>std::pair of arbitrary types, B and A</td>
                </tr>
              </tfoot>
            </table>
<p>Flip a std::pair of arbitrary types</p>
          </div></section>
          <section class="m-dox-details" id="a42982d289f8edfffa60fa4da8b7b9fdf"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename A, typename B&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::multimap&lt;B, A&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a42982d289f8edfffa60fa4da8b7b9fdf" class="m-dox-self">flip_map</a>(</span><span class="m-dox-wrap">const std::map&lt;A, B&gt;&amp; src)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">src&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>std::map of arbitrary key and value pairs of types A and B</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>std::multimap of arbitrary key and value pairs of types B and A</td>
                </tr>
              </tfoot>
            </table>
<p>Flip a std::map of arbitrary types, yielding a std::multimap sorted by std::map::value_type.</p>
          </div></section>
          <section class="m-dox-details" id="ae89ad400e8727632059aab318889c52c"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Eq = std::equal_to&lt;Key&gt;&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae89ad400e8727632059aab318889c52c" class="m-dox-self">serialize</a>(</span><span class="m-dox-wrap">const std::unordered_map&lt;Key, T, Hash, Eq&gt;&amp; m)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Key</td>
                  <td>Map key</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>Map value</td>
                </tr>
                <tr>
                  <td>Hash</td>
                  <td>Map hasher</td>
                </tr>
                <tr>
                  <td>Eq</td>
                  <td>Map equality operator</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>m&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Hash map to serialize</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Pair of the length and the raw stream containing the serialized map</td>
                </tr>
              </tfoot>
            </table>
<p>Serialize std::unordered_map to raw memory stream</p>
          </div></section>
          <section class="m-dox-details" id="ac371117af5d2009dca83a8cb5539a43f"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Eq = std::equal_to&lt;Key&gt;&gt;
              </div>
              <span class="m-dox-wrap-bumper">CkReductionMsg* tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac371117af5d2009dca83a8cb5539a43f" class="m-dox-self">mergeHashMap</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs)</span></span>
            </h3>
            <p>Charm++ custom reducer for merging std::unordered_maps during reduction across PEs.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Key</td>
                  <td>Map key</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>Map value</td>
                </tr>
                <tr>
                  <td>Hash</td>
                  <td>Map hasher</td>
                </tr>
                <tr>
                  <td>Eq</td>
                  <td>Map equality operator</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>nmsg&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of messages in msgs</td>
                </tr>
                <tr>
                  <td>msgs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Charm++ reduction message containing the serialized maps</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Aggregated std::unordered_maps built for further aggregation if needed</td>
                </tr>
              </tfoot>
            </table>
<p>During aggregation the map keys are inserted, i.e., the keys remain unique and the mapped values, assuming containers defining begin() and end() iterators() are concatenated.</p><aside class="m-note m-info"><h4>Note</h4><p>The mapped type must be a container, i.e., must provide iterators begin() and end().</p></aside>
          </div></section>
          <section class="m-dox-details" id="ae484074849c5c9532282fc9fa4e19467"><div>
            <h3>
              <span class="m-dox-wrap-bumper">uint64_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae484074849c5c9532282fc9fa4e19467" class="m-dox-self">linearLoadDistributor</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> virtualization,
              uint64_t load,
              int npe,
              uint64_t&amp; chunksize,
              uint64_t&amp; remainder)</span></span>
            </h3>
            <p>Compute linear load distribution for given total work and virtualization.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">virtualization&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Degree of virtualization [0.0...1.0]</td>
                </tr>
                <tr>
                  <td>load&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total load, e.g., number of particles, number of mesh cells</td>
                </tr>
                <tr>
                  <td>npe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of processing elements to distribute the load to</td>
                </tr>
                <tr>
                  <td>chunksize&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Chunk size, see detailed description</td>
                </tr>
                <tr>
                  <td>remainder&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Remainder, see detailed description</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Number of work units</td>
                </tr>
              </tfoot>
            </table>
<p>Compute load distibution (number of chares and chunksize) based on total work (e.g., total number of particles) and virtualization</p><p>The virtualization parameter, specified by the user, is a real number between 0.0 and 1.0, inclusive, which controls the degree of virtualization or over-decomposition. Independent of the value of virtualization the work is approximately evenly distributed among the available processing elements, given by npe. For zero virtualization (no over-decomposition), the work is simply decomposed into total_work/numPEs, which yields the smallest number of Charm++ chares and the largest chunks of work units. The other extreme is unity virtualization, which decomposes the total work into the smallest size work units possible, yielding the largest number of Charm++ chares. Obviously, the optimum will be between 0.0 and 1.0, depending on the problem.</p><p>The formula implemented uses a linear relationship between the virtualization parameter and the number of work units with the extremes described above. The formula is given by</p><p>chunksize = (1 - n) * v + n;</p><p>where</p><ul><li>v = degree of virtualization</li><li>n = load/npes</li><li>load = total work, e.g., number of particles, number of mesh cells</li><li>npes = number of hardware processing elements</li></ul>
          </div></section>
          <section class="m-dox-details" id="a80fbbf9455232f7f68136d0322f22cab"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename Enum, typename Ch, typename Tr, typename std::enable_if_t&lt;std::is_enum_v&lt;Enum&gt;, int&gt; = 0&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::basic_ostream&lt;Ch, Tr&gt;&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a80fbbf9455232f7f68136d0322f22cab" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_ostream&lt;Ch, Tr&gt;&amp; os,
              const Enum&amp; e)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">os&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Output stream into to write to</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Value of enum-class type to write to stream</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Updated output stream for chain-use of the operator</td>
                </tr>
              </tfoot>
            </table>
<p>Operator &lt;&lt; for writing an enum class to an output stream</p>
          </div></section>
          <section class="m-dox-details" id="a97430ef922a10f0dc200f61f6e2c4e40"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class T, typename Ch, typename Tr&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::basic_ostream&lt;Ch, Tr&gt;&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a97430ef922a10f0dc200f61f6e2c4e40" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_ostream&lt;Ch, Tr&gt;&amp; os,
              const std::vector&lt;T&gt;&amp; v)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">os&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Output stream to write to</td>
                </tr>
                <tr>
                  <td>v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector to write to stream</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Updated output stream for chain-use of the operator</td>
                </tr>
              </tfoot>
            </table>
<p>Operator &lt;&lt; for writing a std::vector to an output stream</p>
          </div></section>
          <section class="m-dox-details" id="a1d82ad961b5527a3ec225246282d1b48"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename Ch, typename Tr, class Key, class Value, class Compare = std::less&lt;Key&gt;&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::basic_ostream&lt;Ch, Tr&gt;&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a1d82ad961b5527a3ec225246282d1b48" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_ostream&lt;Ch, Tr&gt;&amp; os,
              const std::map&lt;Key, Value, Compare&gt;&amp; m)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">os&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Output stream to write to</td>
                </tr>
                <tr>
                  <td>m&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Map to write to stream</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Updated output stream for chain-use of the operator</td>
                </tr>
              </tfoot>
            </table>
<p>Operator &lt;&lt; for writing an std::map to an output stream</p>
          </div></section>
          <section class="m-dox-details" id="aa160d13ea2e4a3498916472c3b6cdbb0"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T, typename Ch, typename Tr&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::basic_string&lt;Ch, Tr&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa160d13ea2e4a3498916472c3b6cdbb0" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_string&lt;Ch, Tr&gt;&amp; lhs,
              const T&amp; e)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">lhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Output std::basic_string into which e is written</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Value of arbitrary type to write to string</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Updated string</td>
                </tr>
              </tfoot>
            </table>
<p>Operator &lt;&lt; for adding (concatenating) T to a std::basic_string for lvalues.</p>
          </div></section>
          <section class="m-dox-details" id="a7adfa2dfb8b3a38f60ac0edf5666b6c4"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T, typename Ch, typename Tr&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::basic_string&lt;Ch, Tr&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7adfa2dfb8b3a38f60ac0edf5666b6c4" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::basic_string&lt;Ch, Tr&gt;&amp;&amp; lhs,
              const T&amp; e)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">lhs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Output std::basic_string into which e is written</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Value of arbitrary type to write to string</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Updated string</td>
                </tr>
              </tfoot>
            </table>
<p>Operator &lt;&lt; for adding (concatenating) T to a std::basic_string for rvalues.</p>
          </div></section>
          <section class="m-dox-details" id="a08013d493d2688c9525b63e666240443"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::string tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a08013d493d2688c9525b63e666240443" class="m-dox-self">splitLines</a>(</span><span class="m-dox-wrap">std::string str,
              std::string indent,
              const std::string&amp; name = &quot;&quot;,
              std::size_t width = 80)</span></span>
            </h3>
            <p>Clean up whitespaces and format a long string into multiple lines.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">str&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>String to format</td>
                </tr>
                <tr>
                  <td>indent&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>String to use as identation</td>
                </tr>
                <tr>
                  <td>name&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>String to insert before string to output</td>
                </tr>
                <tr>
                  <td>width&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Width in characters to insert newlines for output</td>
                </tr>
              </tbody>
            </table>
<aside class="m-note m-default"><h4>See also</h4><p><a href="http://stackoverflow.com/a/6892562">http:/<wbr />/<wbr />stackoverflow.com/<wbr />a/<wbr />6892562</a></p><p><a href="http://stackoverflow.com/a/8362145">http:/<wbr />/<wbr />stackoverflow.com/<wbr />a/<wbr />8362145</a></p><p><a href="https://stackoverflow.com/a/6894764">https:/<wbr />/<wbr />stackoverflow.com/<wbr />a/<wbr />6894764</a></p></aside>
          </div></section>
          <section class="m-dox-details" id="aa99868f695794091b932a82a69e04807"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::string tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa99868f695794091b932a82a69e04807" class="m-dox-self">baselogname</a>(</span><span class="m-dox-wrap">const std::string&amp; executable)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">executable&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Name of the executable</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Base log file name</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a486a888804d7b698fe21241968f719cb"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::string tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a486a888804d7b698fe21241968f719cb" class="m-dox-self">logname</a>(</span><span class="m-dox-wrap">const std::string&amp; executable,
              int numrestart = 0)</span></span>
            </h3>
            <p>Construct log file name.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">executable&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Name of the executable</td>
                </tr>
                <tr>
                  <td>numrestart&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of times restarted</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>The name of the log file to use</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ad0ed65df66049a89a8a5055895ae417a"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad0ed65df66049a89a8a5055895ae417a" class="m-dox-self">signalHandler</a>(</span><span class="m-dox-wrap">int signum)</span></span>
            </h3>
            <p>Signal handler for multiple signals, SIGABRT, SIGSEGV, etc.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">signum&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Signal number</td>
                </tr>
              </tbody>
            </table>
<aside class="m-note m-default"><h4>See also</h4><p><a href="https://oroboro.com/stack-trace-on-crash">https:/<wbr />/<wbr />oroboro.com/<wbr />stack-trace-on-crash</a></p></aside><p>Signals caught: SIGABRT is generated when the program calls the abort() function, such as when an assert() triggers SIGSEGV is generated when the program makes an illegal memory access, such as reading unaligned memory, dereferencing a null pointer, reading memory out of bounds etc. SIGILL is generated when the program tries to execute a malformed instruction. This happens when the execution pointer starts reading non-program data, or when a pointer to a function is corrupted. SIGFPE is generated when executing an illegal floating point instruction, most commonly division by zero or floating point overflow.</p>
          </div></section>
          <section class="m-dox-details" id="a5e8c72da5967d8fb725ff4a26294a871"><div>
            <h3>
              <span class="m-dox-wrap-bumper">int tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a5e8c72da5967d8fb725ff4a26294a871" class="m-dox-self">setSignalHandlers</a>(</span><span class="m-dox-wrap">)</span></span>
            </h3>
            <p>Set signal handlers for multiple signals, SIGABRT, SIGSEGV, etc.</p>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>Ignore, used for calling in a constructor&#x27;s initializer list</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="af04df49334286e653e440035c499a8d1"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af04df49334286e653e440035c499a8d1" class="m-dox-self">processExceptionCharm</a>(</span><span class="m-dox-wrap">)</span></span>
            </h3>
            <p>Process an exception from the Charm++ runtime system.</p>
<p>See Josuttis, The C++ Standard Library - A Tutorial and Reference, 2nd Edition, 2012.</p>
          </div></section>
          <section class="m-dox-details" id="aa7d376e7f0dd51a64632432345dd4423"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-dox-wrap-bumper">T tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa7d376e7f0dd51a64632432345dd4423" class="m-dox-self">swap_endian</a>(</span><span class="m-dox-wrap">T u)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">u&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Integral type to convert</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Converted integer</td>
                </tr>
              </tfoot>
            </table>
<p>Swap endianness of an integral type</p>
          </div></section>
          <section class="m-dox-details" id="a550509206419175e2b2277bc5c18016e"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;&gt;
              </div>
              <span class="m-dox-wrap-bumper">double tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a550509206419175e2b2277bc5c18016e" class="m-dox-self">swap_endian</a>(</span><span class="m-dox-wrap">double u)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">u&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Double to convert</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Converted double</td>
                </tr>
              </tfoot>
            </table>
<p>Swap endianness of a double</p>
          </div></section>
          <section class="m-dox-details" id="a8ef5bd8de033f50be3f02dd2543da0b8"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;std::size_t N&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, N&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a8ef5bd8de033f50be3f02dd2543da0b8" class="m-dox-self">sample</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x,
              const <a href="namespacetk.html#ae1f47e67146a193c0f7e8dee7fa5d30d" class="m-dox">Table</a>&lt;N&gt;&amp; table)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">N</td>
                  <td>Number of ordinates in the table</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Abscissa to sample at</td>
                </tr>
                <tr>
                  <td>table&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Table to sample</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Ordinates sampled</td>
                </tr>
              </tfoot>
            </table>
<p>Sample a discrete (y1,y2,...,yN) = f(x) function at x</p>
          </div></section>
          <section class="m-dox-details" id="a0aba20ed8021caba53eeb77f31dafda1"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Tuple&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a0aba20ed8021caba53eeb77f31dafda1" class="m-dox-self">print</a>(</span><span class="m-dox-wrap">std::ostream&amp; os,
              const std::string&amp; name,
              const Tuple&amp; c)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">Tuple</td>
                  <td>Tuple object type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>os&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Output stream to print to</td>
                </tr>
                <tr>
                  <td>name&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Name of (root) Tuple</td>
                </tr>
                <tr>
                  <td>c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Command line object to output to file</td>
                </tr>
              </tbody>
            </table>
<p>Output command line object (a <a href="classtk_1_1_tagged_tuple.html" class="m-dox">TaggedTuple</a>) to file</p>
          </div></section>
          <section class="m-dox-details" id="a08d29a8f44564890253cf13273ae33b6"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class List&gt;
              </div>
              <span class="m-dox-wrap-bumper">std::ostream&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a08d29a8f44564890253cf13273ae33b6" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::ostream&amp; os,
              const <a href="classtk_1_1_tagged_tuple.html" class="m-dox">tk::<wbr />TaggedTuple</a>&lt;List&gt;&amp; t)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">List</td>
                  <td>brigand::list of types in the tagged tuple</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>os&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Output stream to output to</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><a href="classtk_1_1_tagged_tuple.html" class="m-dox">TaggedTuple</a> to print</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Output stream</td>
                </tr>
              </tfoot>
            </table>
<p>Simple (unformatted, one-line) output of a <a href="classtk_1_1_tagged_tuple.html" class="m-dox">TaggedTuple</a> to output stream</p>
          </div></section>
          <section class="m-dox-details" id="a8b82934c22714a95ea88f9a03e6d1b5e"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class List, class Ignore = brigand::set&lt;&gt;&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a8b82934c22714a95ea88f9a03e6d1b5e" class="m-dox-self">print</a>(</span><span class="m-dox-wrap">std::ostream&amp; os,
              const <a href="classtk_1_1_tagged_tuple.html" class="m-dox">tk::<wbr />TaggedTuple</a>&lt;List&gt;&amp; t)</span></span>
            </h3>
            <p>Simple (unformatted, one-line) output of a <a href="classtk_1_1_tagged_tuple.html" class="m-dox">TaggedTuple</a> to output stream with ignore.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">List</td>
                  <td>brigand::list of types in the tagged tuple</td>
                </tr>
                <tr>
                  <td>Ignore</td>
                  <td>brigand::list of types to not print</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>os&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Output stream to output to</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><a href="classtk_1_1_tagged_tuple.html" class="m-dox">TaggedTuple</a> to print</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="ad6260a3dcdcb9a995a4886e566b665c4"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="structtk_1_1_timer_1_1_watch.html" class="m-dox">Timer::<wbr />Watch</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad6260a3dcdcb9a995a4886e566b665c4" class="m-dox-self">hms</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> stamp)</span></span>
            </h3>
            <p>Convert existing time stamp as a real to Watch (global scope)</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">stamp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Time stamp as a real number</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Time as hours, minutes, and seconds, as a Watch struct.</td>
                </tr>
              </tfoot>
            </table>
<p>Convert existing time stamp as a real to Watch (global-scope)</p>
          </div></section>
          <section class="m-dox-details" id="a7ad0c203ea16b614fcbdfb5f7b310866"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7ad0c203ea16b614fcbdfb5f7b310866" class="m-dox-self">flip</a>(</span><span class="m-dox-wrap">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector whose components to multiply by -1.0</td>
                </tr>
              </tbody>
            </table>
<p>Flip sign of vector components</p>
          </div></section>
          <section class="m-dox-details" id="a951f9484d41235130b057570caa4b670"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a951f9484d41235130b057570caa4b670" class="m-dox-self">cross</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1z,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2z,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; rx,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; ry,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; rz)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 1st vector</td>
                </tr>
                <tr>
                  <td>v1y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 1st vector</td>
                </tr>
                <tr>
                  <td>v1z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 1st vector</td>
                </tr>
                <tr>
                  <td>v2x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 2nd vector</td>
                </tr>
                <tr>
                  <td>v2y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 2nd vector</td>
                </tr>
                <tr>
                  <td>v2z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 2nd vector</td>
                </tr>
                <tr>
                  <td>rx&nbsp;<span class="m-label m-flat m-warning">out</span></td>
                  <td>x coordinate of the product vector</td>
                </tr>
                <tr>
                  <td>ry&nbsp;<span class="m-label m-flat m-warning">out</span></td>
                  <td>y coordinate of the product vector</td>
                </tr>
                <tr>
                  <td>rz&nbsp;<span class="m-label m-flat m-warning">out</span></td>
                  <td>z coordinate of the product vector</td>
                </tr>
              </tbody>
            </table>
<p>Compute the cross-product of two vectors</p>
          </div></section>
          <section class="m-dox-details" id="a0cf686dec23cd9154006f18317a439d5"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a0cf686dec23cd9154006f18317a439d5" class="m-dox-self">cross</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v1,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v2)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st vector</td>
                </tr>
                <tr>
                  <td>v2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd vector</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Cross-product</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the cross-product of two vectors</p>
          </div></section>
          <section class="m-dox-details" id="a88d5b3926cac1da27cfb650712ef5585"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a88d5b3926cac1da27cfb650712ef5585" class="m-dox-self">crossdiv</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1z,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2z,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> j,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; rx,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; ry,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; rz)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 1st vector</td>
                </tr>
                <tr>
                  <td>v1y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 1st vector</td>
                </tr>
                <tr>
                  <td>v1z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 1st vector</td>
                </tr>
                <tr>
                  <td>v2x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 2nd vector</td>
                </tr>
                <tr>
                  <td>v2y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 2nd vector</td>
                </tr>
                <tr>
                  <td>v2z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 2nd vector</td>
                </tr>
                <tr>
                  <td>j&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>The scalar to divide the product with</td>
                </tr>
                <tr>
                  <td>rx&nbsp;<span class="m-label m-flat m-warning">out</span></td>
                  <td>x coordinate of the product vector</td>
                </tr>
                <tr>
                  <td>ry&nbsp;<span class="m-label m-flat m-warning">out</span></td>
                  <td>y coordinate of the product vector</td>
                </tr>
                <tr>
                  <td>rz&nbsp;<span class="m-label m-flat m-warning">out</span></td>
                  <td>z coordinate of the product vector</td>
                </tr>
              </tbody>
            </table>
<p>Compute the cross-product of two vectors divided by a scalar</p>
          </div></section>
          <section class="m-dox-details" id="a7885e77a710a1ff3c5ce53655a16e49f"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7885e77a710a1ff3c5ce53655a16e49f" class="m-dox-self">crossdiv</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v1,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> j)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st vector</td>
                </tr>
                <tr>
                  <td>v2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd vector</td>
                </tr>
                <tr>
                  <td>j&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Scalar to divide each component by</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Cross-product divided by scalar</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the cross-product of two vectors divided by a scalar</p>
          </div></section>
          <section class="m-dox-details" id="ae1c0fdc133ccaae0fb2437ac6d447972"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae1c0fdc133ccaae0fb2437ac6d447972" class="m-dox-self">dot</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v1,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v2)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st vector</td>
                </tr>
                <tr>
                  <td>v2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd vector</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Dot-product</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the dot-product of two vectors</p>
          </div></section>
          <section class="m-dox-details" id="aa229c58c4089e9ae908232b2a353e9b3"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa229c58c4089e9ae908232b2a353e9b3" class="m-dox-self">matvec</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt;&amp; m,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">m&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Matrix</td>
                </tr>
                <tr>
                  <td>v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>vector</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Dot-product</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the dot-product of a matrix and a vector</p>
          </div></section>
          <section class="m-dox-details" id="aa3db06a7e253fc3f22c4fb28dae6ac37"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa3db06a7e253fc3f22c4fb28dae6ac37" class="m-dox-self">length</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>X coordinate of vector</td>
                </tr>
                <tr>
                  <td>y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Y coordinate of vector</td>
                </tr>
                <tr>
                  <td>z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Z coordinate of vector</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>length</td>
                </tr>
              </tfoot>
            </table>
<p>Compute length of a vector</p>
          </div></section>
          <section class="m-dox-details" id="a3a772fb3873098fb1951fd6d311cd60d"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a3a772fb3873098fb1951fd6d311cd60d" class="m-dox-self">length</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>vector</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>length</td>
                </tr>
              </tfoot>
            </table>
<p>Compute length of a vector</p>
          </div></section>
          <section class="m-dox-details" id="a926d47129e0cb4cc72e296953a7da5d4"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a926d47129e0cb4cc72e296953a7da5d4" class="m-dox-self">unit</a>(</span><span class="m-dox-wrap">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Vector to normalize</td>
                </tr>
              </tbody>
            </table>
<p>Scale vector to unit length</p>
          </div></section>
          <section class="m-dox-details" id="a7f0f4bf9256573132baf2fa5f9ba814f"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7f0f4bf9256573132baf2fa5f9ba814f" class="m-dox-self">triple</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v1z,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v2z,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v3x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v3y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> v3z)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 1st vector</td>
                </tr>
                <tr>
                  <td>v1y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 1st vector</td>
                </tr>
                <tr>
                  <td>v1z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 1st vector</td>
                </tr>
                <tr>
                  <td>v2x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 2nd vector</td>
                </tr>
                <tr>
                  <td>v2y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 2nd vector</td>
                </tr>
                <tr>
                  <td>v2z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 2nd vector</td>
                </tr>
                <tr>
                  <td>v3x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 3rd vector</td>
                </tr>
                <tr>
                  <td>v3y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 3rd vector</td>
                </tr>
                <tr>
                  <td>v3z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 3rd vector</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Scalar value of the triple product</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the triple-product of three vectors</p>
          </div></section>
          <section class="m-dox-details" id="a77dfe4f35f647c7ca6a504a5a06d9178"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a77dfe4f35f647c7ca6a504a5a06d9178" class="m-dox-self">triple</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v1,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v2,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v3)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>1st vector</td>
                </tr>
                <tr>
                  <td>v2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>2nd vector</td>
                </tr>
                <tr>
                  <td>v3&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>3rd vector</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Triple-product</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the triple-product of three vectors</p>
          </div></section>
          <section class="m-dox-details" id="af006b6e0681a9222c91616da30d23d44"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af006b6e0681a9222c91616da30d23d44" class="m-dox-self">rotateX</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> angle)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector to rotate</td>
                </tr>
                <tr>
                  <td>angle&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Angle to use to rotate with</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Rotated vector</td>
                </tr>
              </tfoot>
            </table>
<p>Rotate vector about X axis</p>
          </div></section>
          <section class="m-dox-details" id="a2e45ee53422ebc214c485a40e9bdcdff"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a2e45ee53422ebc214c485a40e9bdcdff" class="m-dox-self">rotateY</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> angle)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector to rotate</td>
                </tr>
                <tr>
                  <td>angle&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Angle to use to rotate with</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Rotated vector</td>
                </tr>
              </tfoot>
            </table>
<p>Rotate vector about Y axis</p>
          </div></section>
          <section class="m-dox-details" id="a16fb059763d22c82cb9bd5f19be696e1"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a16fb059763d22c82cb9bd5f19be696e1" class="m-dox-self">rotateZ</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> angle)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector to rotate</td>
                </tr>
                <tr>
                  <td>angle&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Angle to use to rotate with</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Rotated vector</td>
                </tr>
              </tfoot>
            </table>
<p>Rotate vector about Z axis</p>
          </div></section>
          <section class="m-dox-details" id="acd96de1dc0141f11e98a8b5dcce6522f"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#acd96de1dc0141f11e98a8b5dcce6522f" class="m-dox-self">Jacobian</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v1,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v2,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v3,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v4)</span></span>
            </h3>
            <p>Compute the determinant of the Jacobian of a coordinate transformation over a tetrahedron.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>(x,y,z) coordinates of 1st vertex of the tetrahedron</td>
                </tr>
                <tr>
                  <td>v2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>(x,y,z) coordinates of 2nd vertex of the tetrahedron</td>
                </tr>
                <tr>
                  <td>v3&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>(x,y,z) coordinates of 3rd vertex of the tetrahedron</td>
                </tr>
                <tr>
                  <td>v4&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>(x,y,z) coordinates of 4th vertex of the tetrahedron</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Determinant of the Jacobian of transformation of physical tetrahedron to reference (xi, eta, zeta) space</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a9bf3d7327197dcb3a74af13b52ee23d8"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a9bf3d7327197dcb3a74af13b52ee23d8" class="m-dox-self">inverseJacobian</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v1,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v2,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v3,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; v4)</span></span>
            </h3>
            <p>Compute the inverse of the Jacobian of a coordinate transformation over a tetrahedron.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>(x,y,z) coordinates of 1st vertex of the tetrahedron</td>
                </tr>
                <tr>
                  <td>v2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>(x,y,z) coordinates of 2nd vertex of the tetrahedron</td>
                </tr>
                <tr>
                  <td>v3&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>(x,y,z) coordinates of 3rd vertex of the tetrahedron</td>
                </tr>
                <tr>
                  <td>v4&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>(x,y,z) coordinates of 4th vertex of the tetrahedron</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Inverse of the Jacobian of transformation of physical tetrahedron to reference (xi, eta, zeta) space</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a377e30bd4504f7a7243ca97b01208a25"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a377e30bd4504f7a7243ca97b01208a25" class="m-dox-self">determinant</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; a)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">a&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>3x3 matrix</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Determinant of the 3x3 matrix</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the determinant of 3x3 matrix</p>
          </div></section>
          <section class="m-dox-details" id="aa6ec274c35f3ace5cb1e4fed556844c2"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa6ec274c35f3ace5cb1e4fed556844c2" class="m-dox-self">inverse</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; m)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">m&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>3x3 matrix</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Inverse of the 3x3 matrix</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the inverse of 3x3 matrix</p>
          </div></section>
          <section class="m-dox-details" id="a02cec3254bd9d8882f11a23fa8b0cf33"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a02cec3254bd9d8882f11a23fa8b0cf33" class="m-dox-self">cramer</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; a,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; b)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">a&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>3x3 lhs matrix</td>
                </tr>
                <tr>
                  <td>b&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>3x1 rhs matrix</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Array of solutions of the 3x3 system</td>
                </tr>
              </tfoot>
            </table>
<p>Solve a 3x3 system of equations using Cramer&#x27;s rule</p>
          </div></section>
          <section class="m-dox-details" id="aa4fc566f3521577c8a92473beff6b776"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa4fc566f3521577c8a92473beff6b776" class="m-dox-self">movePoint</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; origin,
              std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; point)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">origin&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Origin of reference frame to which point is to be moved</td>
                </tr>
                <tr>
                  <td>point&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Point that needs to be moved to reference frame</td>
                </tr>
              </tbody>
            </table>
<p>Move a point to a reference space given coordinates of origin of that space</p>
          </div></section>
          <section class="m-dox-details" id="acbb53fcd1f298717edfcfde883b5f923"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#acbb53fcd1f298717edfcfde883b5f923" class="m-dox-self">rotatePoint</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; angles,
              std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; point)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">angles&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Angles in 3D space by which point is to be rotated</td>
                </tr>
                <tr>
                  <td>point&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Point that needs to be rotated</td>
                </tr>
              </tbody>
            </table>
<p>Rotate a point in 3D space by specifying rotation angles in degrees</p>
          </div></section>
          <section class="m-dox-details" id="aa6016dbfb2fed3c3abdf49f19615c87b"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa6016dbfb2fed3c3abdf49f19615c87b" class="m-dox-self">getRightCauchyGreen</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt;&amp; g)</span></span>
            </h3>
            <p>Get the Right Cauchy-Green strain tensor from the inverse deformation gradient tensor.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">g&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Inverse deformation gradient tensor</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Right Cauchy-Green tensor</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a0a749960309157e64607e1a1d723118d"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a0a749960309157e64607e1a1d723118d" class="m-dox-self">getLeftCauchyGreen</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt;&amp; g)</span></span>
            </h3>
            <p>Get the Left Cauchy-Green strain tensor from the inverse deformation gradient tensor.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">g&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Inverse deformation gradient tensor</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Left Cauchy-Green tensor</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a0c1fa139012400110734c8432ea3229f"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a0c1fa139012400110734c8432ea3229f" class="m-dox-self">getDevHencky</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt;&amp; g)</span></span>
            </h3>
            <p>Get the deviatoric Hencky strain tensor from the inverse deformation gradient tensor.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">g&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Inverse deformation gradient tensor</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Deviatoric Hencky strain tensor</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a76fbe98f45d72e60c904bfca24e35ebd"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a76fbe98f45d72e60c904bfca24e35ebd" class="m-dox-self">transpose3by3</a>(</span><span class="m-dox-wrap">std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt; mat)</span></span>
            </h3>
            <p>Get transpose of a 3 by 3 matrix.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">mat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>matrix to be transposed</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>transposed matrix</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ae65248cecf67b86c310b35efa3e288d6"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae65248cecf67b86c310b35efa3e288d6" class="m-dox-self">getRotationMatrix</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; r)</span></span>
            </h3>
            <p>Get rotation matrix in 2D array form given a normal direction. The remaining directions are given by section 5.3.1 of Miller, G. H., and P. Colella. &quot;A conservative three-dimensional
Eulerian method for coupled solid–fluid shock capturing.&quot; Journal of Computational Physics 183.1 (2002): 26-82.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">r&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Coordinates of the first basis vector r = (rx,ry,rz).</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>rotation matrix</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="acbd49264cd05edead612a698bb5f4e16"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#acbd49264cd05edead612a698bb5f4e16" class="m-dox-self">rotateTensor</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; mat,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; r)</span></span>
            </h3>
            <p>Rotate a second order tensor (e.g. a Strain/Stress matrix) from the (x,y,z) to a new (r,s,t) coordinate system. The directions are given by section 5.3.1 of Miller, G. H., and P. Colella. &quot;A conservative three-dimensional
Eulerian method for coupled solid–fluid shock capturing.&quot; Journal of Computational Physics 183.1 (2002): 26-82.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">mat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>matrix to be rotated.</td>
                </tr>
                <tr>
                  <td>r&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Coordinates of the first basis vector r = (rx,ry,rz).</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>rotated tensor</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a40126fd348d6f946f6b038e7dfd59fe2"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a40126fd348d6f946f6b038e7dfd59fe2" class="m-dox-self">unrotateTensor</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; mat,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; r)</span></span>
            </h3>
            <p>Rotate a second order tensor (e.g. a Strain/Stress matrix) from the (x,y,z) to a new (r,s,t) coordinate system. The directions are given by section 5.3.1 of Miller, G. H., and P. Colella. &quot;A conservative three-dimensional
Eulerian method for coupled solid–fluid shock capturing.&quot; Journal of Computational Physics 183.1 (2002): 26-82.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">mat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>matrix to be rotated.</td>
                </tr>
                <tr>
                  <td>r&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Coordinates of the first basis vector r = (rx,ry,rz).</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>rotated tensor</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="adcf0f9f6d18ca59357df41ff221b2044"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#adcf0f9f6d18ca59357df41ff221b2044" class="m-dox-self">rotateVector</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; v,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; r)</span></span>
            </h3>
            <p>Rotate a vector (e.g. a velocity) from the (x,y,z) to a new (r,s,t) coordinate system. The directions are given by section 5.3.1 of Miller, G. H., and P. Colella. &quot;A conservative three-dimensional
Eulerian method for coupled solid–fluid shock capturing.&quot; Journal of Computational Physics 183.1 (2002): 26-82.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector to be rotated.</td>
                </tr>
                <tr>
                  <td>r&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Coordinates of the first basis vector r = (rx,ry,rz).</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>rotated vector</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a7a1cf38b0a38723a4aa83deaef714d95"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7a1cf38b0a38723a4aa83deaef714d95" class="m-dox-self">unrotateVector</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; v,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; r)</span></span>
            </h3>
            <p>Unrotate a vector (e.g. a velocity) from the (x,y,z) to a new (r,s,t) coordinate system. The directions are given by section 5.3.1 of Miller, G. H., and P. Colella. &quot;A conservative three-dimensional
Eulerian method for coupled solid–fluid shock capturing.&quot; Journal of Computational Physics 183.1 (2002): 26-82.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector to be rotated.</td>
                </tr>
                <tr>
                  <td>r&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Coordinates of the first basis vector r = (rx,ry,rz).</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>rotated vector</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ae457dd74a494f2106734b6b88bce3eaf"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae457dd74a494f2106734b6b88bce3eaf" class="m-dox-self">reflectTensor</a>(</span><span class="m-dox-wrap">const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; mat,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; reflectMat)</span></span>
            </h3>
            <p>Reflect a second order tensor (e.g. a Strain/Stress matrix)</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">mat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>matrix to be rotated.</td>
                </tr>
                <tr>
                  <td>reflectMat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Reflection matrix</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>reflected tensor</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a485fc849f142f0ee38055fad224206d6"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a8e37e8d13562df3379a730217f735255" class="m-dox">MeshReaderType</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a485fc849f142f0ee38055fad224206d6" class="m-dox-self">detectInput</a>(</span><span class="m-dox-wrap">const std::string&amp; filename)</span></span>
            </h3>
            <p>Detect input mesh file type.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">filename&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>File to open and detect its type</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>enum specifying the mesh reader type</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a6bcaad9b4f5b0aa6e5792f9ccacf8d79"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#ab4676f2ab442a552c4409d65b5d1b751" class="m-dox">MeshWriterType</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a6bcaad9b4f5b0aa6e5792f9ccacf8d79" class="m-dox-self">pickOutput</a>(</span><span class="m-dox-wrap">const std::string&amp; filename)</span></span>
            </h3>
            <p>Determine output mesh file type.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">filename&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Filename to pick its type based on extension given</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>enum specifying the mesh writer type</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="af947865970b76333655208aea71ceb71"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="classtk_1_1_uns_mesh.html" class="m-dox">UnsMesh</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af947865970b76333655208aea71ceb71" class="m-dox-self">readUnsMesh</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">tk::<wbr />Print</a>&amp; print,
              const std::string&amp; filename,
              std::pair&lt;std::string, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; timestamp)</span></span>
            </h3>
            <p>Read unstructured mesh from file.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">print&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pretty printer</td>
                </tr>
                <tr>
                  <td>filename&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Filename to read mesh from</td>
                </tr>
                <tr>
                  <td>timestamp&nbsp;<span class="m-label m-flat m-warning">out</span></td>
                  <td>A time stamp consisting of a timer label (a string), and a time state (a <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> in seconds) measuring the mesh read time</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Unstructured mesh object</td>
                </tr>
              </tfoot>
            </table>
<p>Create unstructured mesh to store mesh</p>
          </div></section>
          <section class="m-dox-details" id="a92ff858133bdb654de9b95c279427325"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::pair&lt;std::string, <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a92ff858133bdb654de9b95c279427325" class="m-dox-self">writeUnsMesh</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">tk::<wbr />Print</a>&amp; print,
              const std::string&amp; filename,
              <a href="classtk_1_1_uns_mesh.html" class="m-dox">UnsMesh</a>&amp; mesh,
              bool reorder)</span></span>
            </h3>
            <p>Write unstructured mesh to file.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">print&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pretty printer</td>
                </tr>
                <tr>
                  <td>filename&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Filename to write mesh to</td>
                </tr>
                <tr>
                  <td>mesh&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Unstructured mesh object to write from</td>
                </tr>
                <tr>
                  <td>reorder&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Whether to also reorder mesh nodes</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Vector of time stamps consisting of a timer label (a string), and a time state (a <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> in seconds) measuring the renumber and the mesh write time</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a20ee8c554da198c14efbb80a0b623a4a"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a20ee8c554da198c14efbb80a0b623a4a" class="m-dox-self">SiloError</a>(</span><span class="m-dox-wrap">char* msg)</span></span>
            </h3>
            <p>Silo error handler.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">msg&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Error message</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a8e567fa9a72a1d5d02cea9eb020b192a"><div>
            <h3>
              <span class="m-dox-wrap-bumper">static std::string tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a8e567fa9a72a1d5d02cea9eb020b192a" class="m-dox-self">workdir</a>(</span><span class="m-dox-wrap">)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>A stirng containing the current working directory</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a43865234637c85533d5af75178b99f8a"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::string tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a43865234637c85533d5af75178b99f8a" class="m-dox-self">curtime</a>(</span><span class="m-dox-wrap">)</span></span>
            </h3>
            <p>Wrapper for the standard C library&#x27;s gettimeofday() from.</p>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>A stirng containing the current date and time</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a2984d7c82e0629d99655b5221a2dcc89"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a2984d7c82e0629d99655b5221a2dcc89" class="m-dox-self">echoHeader</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">Print</a>&amp; print,
              <a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d" class="m-dox">HeaderType</a> header)</span></span>
            </h3>
            <p>Echo program header.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">print&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pretty printer</td>
                </tr>
                <tr>
                  <td>header&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Header type enum indicating which header to print</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a300a6be5864385fcea6b688f6a7a9ce7"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a300a6be5864385fcea6b688f6a7a9ce7" class="m-dox-self">echoBuildEnv</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">Print</a>&amp; print,
              const std::string&amp; executable)</span></span>
            </h3>
            <p>Echo build environment.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">print&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pretty printer</td>
                </tr>
                <tr>
                  <td>executable&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Name of the executable</td>
                </tr>
              </tbody>
            </table>
<p>Echo information read from build_dir/Base/Config.h filled by CMake based on src/Main/Config.h.in.</p>
          </div></section>
          <section class="m-dox-details" id="ad4032baef5ff4408d0110d6ed9464af6"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad4032baef5ff4408d0110d6ed9464af6" class="m-dox-self">echoRunEnv</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_print.html" class="m-dox">Print</a>&amp; print,
              int argc,
              char** argv,
              bool verbose,
              bool quiescence,
              bool charestate,
              bool trace,
              const std::string&amp; screen_log,
              const std::string&amp; input_log)</span></span>
            </h3>
            <p>Echo runtime environment.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">print&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pretty printer</td>
                </tr>
                <tr>
                  <td>argc&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of command-line arguments to executable</td>
                </tr>
                <tr>
                  <td>argv&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>C-style string array to command-line arguments to executable</td>
                </tr>
                <tr>
                  <td>verbose&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>True for verbose screen-output</td>
                </tr>
                <tr>
                  <td>quiescence&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>True if quiescence detection is enabled</td>
                </tr>
                <tr>
                  <td>charestate&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>True if chare state collection is enabled</td>
                </tr>
                <tr>
                  <td>trace&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>True if call and stack trace output is enabled</td>
                </tr>
                <tr>
                  <td>screen_log&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Screen output log file name</td>
                </tr>
                <tr>
                  <td>input_log&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Input log file name</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a11c11dc55f2ea83cd4f0259f6a5a0a73"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class Driver, class CmdLine&gt;
              </div>
              <span class="m-dox-wrap-bumper">Driver tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a11c11dc55f2ea83cd4f0259f6a5a0a73" class="m-dox-self">Main</a>(</span><span class="m-dox-wrap">int argc,
              char* argv[],
              const CmdLine&amp; cmdline,
              <a href="namespacetk.html#a3032aaeb67d38d01181590cd7f0acc7d" class="m-dox">HeaderType</a> header,
              const std::string&amp; executable,
              const std::string&amp; def,
              int nrestart)</span></span>
            </h3>
            <p>Generic <a href="namespacetk.html#a11c11dc55f2ea83cd4f0259f6a5a0a73" class="m-dox">Main()</a> used for all executables for code-reuse and a uniform output.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">argc&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of command-line arguments to executable</td>
                </tr>
                <tr>
                  <td>argv&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>C-style string array to command-line arguments to executable</td>
                </tr>
                <tr>
                  <td>cmdline&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Command line object storing data parsed from the command line arguments</td>
                </tr>
                <tr>
                  <td>header&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Header type enum indicating which executable header to print</td>
                </tr>
                <tr>
                  <td>executable&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Name of the executable</td>
                </tr>
                <tr>
                  <td>def&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Default log file name</td>
                </tr>
                <tr>
                  <td>nrestart&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of times restarted</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Instantiated driver object which can then be used to <a href="classexecute.html" class="m-dox">execute()</a> whatever it is intended to drive</td>
                </tr>
              </tfoot>
            </table>
<p>The template arguments configure this <a href="class_main.html" class="m-dox">Main</a> class that is practically used instead of the usual main(). This allows code-reuse and a unfirom screen-output. The template arguments are:</p><ul><li>Driver, specializaing the driver type to be created, see tk::Driver</li><li>Printer, specializaing the pretty printer type to use, see <a href="classtk_1_1_print.html" class="m-dox">tk::<wbr />Print</a></li><li>CmdLine, specializing the command line object storing data parsed from the command line</li></ul>
          </div></section>
          <section class="m-dox-details" id="a118dbe0f73ff075fdc09cf2c26a755db"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class MainProxy, class CmdLine&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a118dbe0f73ff075fdc09cf2c26a755db" class="m-dox-self">MainCtor</a>(</span><span class="m-dox-wrap">MainProxy&amp; mp,
              const MainProxy&amp; thisProxy,
              std::vector&lt;<a href="classtk_1_1_timer.html" class="m-dox">tk::<wbr />Timer</a>&gt;&amp; timer,
              const CmdLine&amp; cmdline,
              const CkCallback&amp; quiescenceTarget)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">MainProxy</td>
                  <td><a href="class_main.html" class="m-dox">Main</a> Charm++ chare proxy for the executable</td>
                </tr>
                <tr>
                  <td>CmdLine</td>
                  <td>Executable-specific tagged tuple storing the rusult of the command line parser</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>mp&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>MainProxy to set for the main chare</td>
                </tr>
                <tr>
                  <td>thisProxy&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>&#x27;thisProxy&#x27; to set as MainProxy</td>
                </tr>
                <tr>
                  <td>timer&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Vector of timers, held by the main chare, in which to start the first timer, measuring the migration of global-scope data</td>
                </tr>
                <tr>
                  <td>cmdline&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Command line grammar stack for the executable (assumed already parsed)</td>
                </tr>
                <tr>
                  <td>quiescenceTarget&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pre-created Charm++ callback to use as the target function to call if quiescence is detected</td>
                </tr>
              </tbody>
            </table>
<p>Generic <a href="class_main.html" class="m-dox">Main</a> Charm++ module constructor for all executables</p>
          </div></section>
          <section class="m-dox-details" id="ab61b4ac95d7b87d8c9e8ae13a736b42a"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class CmdLine&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab61b4ac95d7b87d8c9e8ae13a736b42a" class="m-dox-self">dumpstate</a>(</span><span class="m-dox-wrap">const CmdLine&amp; cmdline,
              const std::string&amp; def,
              int nrestart,
              CkReductionMsg* msg)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">CmdLine</td>
                  <td>Executable-specific tagged tuple storing the rusult of the command line parser</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>cmdline&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Command line grammar stack for the executable</td>
                </tr>
                <tr>
                  <td>def&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Default log file name</td>
                </tr>
                <tr>
                  <td>nrestart&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of times restarted</td>
                </tr>
                <tr>
                  <td>msg&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Charm++ reduction message containing the chare state aggregated from all PEs</td>
                </tr>
              </tbody>
            </table>
<p>Generic function to dump the Charm++ chare state (if collected)</p>
          </div></section>
          <section class="m-dox-details" id="ab114f87f68585c32d84b05b5e934435c"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class CmdLine&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab114f87f68585c32d84b05b5e934435c" class="m-dox-self">finalize</a>(</span><span class="m-dox-wrap">const CmdLine&amp; cmdline,
              const std::vector&lt;<a href="classtk_1_1_timer.html" class="m-dox">tk::<wbr />Timer</a>&gt;&amp; timer,
              tk::CProxy_ChareStateCollector&amp; state,
              std::vector&lt;std::pair&lt;std::string, <a href="structtk_1_1_timer_1_1_watch.html" class="m-dox">tk::<wbr />Timer::<wbr />Watch</a>&gt;&gt;&amp; timestamp,
              const std::string&amp; def,
              int nrestart,
              const CkCallback&amp; dumpstateTarget,
              bool clean = true)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">cmdline&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Command line grammar stack for the executable</td>
                </tr>
                <tr>
                  <td>timer&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of timers, held by the main chare</td>
                </tr>
                <tr>
                  <td>state&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Chare state collector proxy</td>
                </tr>
                <tr>
                  <td>timestamp&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Vector of time stamps in h:m:s with labels</td>
                </tr>
                <tr>
                  <td>def&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Default log file name</td>
                </tr>
                <tr>
                  <td>nrestart&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of times restarted</td>
                </tr>
                <tr>
                  <td>dumpstateTarget&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pre-created Charm++ callback to use as the target function for dumping chare state</td>
                </tr>
                <tr>
                  <td>clean&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>True if we should exit with a zero exit code, false to exit with a nonzero exit code</td>
                </tr>
              </tbody>
            </table>
<p>Generic finalize function for different executables</p>
          </div></section>
          <section class="m-dox-details" id="a941f4e5e7ed94fc8394f4442cdab10f6"><div>
            <h3>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a941f4e5e7ed94fc8394f4442cdab10f6" class="m-dox-self">slave</a>(</span><span class="m-dox-wrap">const <a href="namespacetk.html#afae1f1be5bf7e58189087d896b6d6ad4" class="m-dox">NodeCommMap</a>&amp; map,
              std::size_t node,
              int chare)</span></span>
            </h3>
            <p>Decide if a node is not counted by a chare.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Node commuinication map to search in</td>
                </tr>
                <tr>
                  <td>node&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Global node id to search for</td>
                </tr>
                <tr>
                  <td>chare&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Caller chare id (but really can be any chare id)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if the node is a slave (counted by another chare with a lower chare id)</td>
                </tr>
              </tfoot>
            </table>
<p>If a node is found in the node communication map and is associated to a lower chare id than the chare id given, it is counted by another chare (and not the caller one), hence a &quot;slave&quot; (for the purpose of this count).</p>
          </div></section>
          <section class="m-dox-details" id="a70e9a96b1d8050073ddc6fc0bedcc251"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a70e9a96b1d8050073ddc6fc0bedcc251" class="m-dox-self">count</a>(</span><span class="m-dox-wrap">const <a href="namespacetk.html#afae1f1be5bf7e58189087d896b6d6ad4" class="m-dox">NodeCommMap</a>&amp; map,
              std::size_t node)</span></span>
            </h3>
            <p>Count the number of contributions to a node.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Node commuinication map to search in</td>
                </tr>
                <tr>
                  <td>node&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Global node id to search for</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Count of contributions to node</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a59a1ea7e9a16e4ac2e9209c34afbf24e"><div>
            <h3>
              <span class="m-dox-wrap-bumper">int tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a59a1ea7e9a16e4ac2e9209c34afbf24e" class="m-dox-self">orient</a>(</span><span class="m-dox-wrap">const <a href="classtk_1_1_uns_mesh.html#a622c34bab099c772650f046b848346d7" class="m-dox">UnsMesh::<wbr />Edge</a>&amp; t,
              const <a href="classtk_1_1_uns_mesh.html#a622c34bab099c772650f046b848346d7" class="m-dox">UnsMesh::<wbr />Edge</a>&amp; e)</span></span>
            </h3>
            <p>Determine edge orientation.</p>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>-1.0 if edge t is oriented the same as edge e, +1.0 opposite</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a8d70c9570a2ddeb17fd30a9222ee7ac0"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a8d70c9570a2ddeb17fd30a9222ee7ac0" class="m-dox-self">npoin_in_graph</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel)</span></span>
            </h3>
            <p>Compute number of points (nodes) in mesh from connectivity.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Inteconnectivity of points and elements. These are the</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Number of mesh points (nodes)</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a66a2889d5d8aeb4a836842c6a1010463"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox-self">genEsup</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe)</span></span>
            </h3>
            <p>Generate derived data structure, elements surrounding points.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linked lists storing elements surrounding points</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esup1</em> and <em>esup2</em>, where <em>esup2</em> holds the indices at which <em>esup1</em> holds the element ids surrounding points. Looping over all elements surrounding all points can then be accomplished by the following loop:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">npoin</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">esup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
     <span class="n">use</span> <span class="n">element</span> <span class="n">id</span> <span class="n">esup</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></pre><p>To find out the number of points, <em>npoin</em>, the mesh connectivity, <em>inpoel</em>, can be queried:</p><pre class="m-code"><span class="k">auto</span> <span class="n">minmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></pre><aside class="m-note m-info"><h4>Note</h4><p>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested.</p></aside><aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="ad2a88a65102c17149b44660db15d445b"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad2a88a65102c17149b44660db15d445b" class="m-dox-self">genPsup</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, points surrounding points.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linked lists storing points surrounding points</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>psup1</em> and <em>psup2</em>, where <em>psup2</em> holds the indices at which <em>psup1</em> holds the point ids surrounding points. Looping over all points surrounding all points can then be accomplished by the following loop:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">npoin</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">psup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">psup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
     <span class="n">use</span> <span class="n">point</span> <span class="n">id</span> <span class="n">psup</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></pre><p>To find out the number of points, <em>npoin</em>, the mesh connectivity, <em>inpoel</em>, can be queried:</p><pre class="m-code"><span class="k">auto</span> <span class="n">minmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></pre><p>or the length-1 of the generated index list: <code class="m-code"><span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="n">psup</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="mi">-1</span><span class="p">;</span></code></p><aside class="m-note m-info"><h4>Note</h4><p>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested.</p></aside><aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="adb7a88611b67f7c809f2bba5c794df0b"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#adb7a88611b67f7c809f2bba5c794df0b" class="m-dox-self">genEdsup</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, edges surrounding points.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element (3 or 4)</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linked lists storing edges (point ids p &lt; q) emanating from points</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>edsup1</em> and <em>edsup2</em>, where <em>edsup2</em> holds the indices at which <em>edsup1</em> holds the edge-end point ids emanating from points for all points. The generated data structure, linked lists edsup1 and edsup2, are very similar to psup1 and psup2, generated by <a href="namespacetk.html#ad2a88a65102c17149b44660db15d445b" class="m-dox">genPsup()</a>, except here only unique edges are stored, i.e., for edges with point ids p &lt; q, only ids q are stored that are still associated to point p. Looping over all unique edges can then be accomplished by the following loop:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">npoin</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">edsup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">edsup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">use</span> <span class="n">edge</span> <span class="n">with</span> <span class="n">point</span> <span class="n">ids</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">edsup</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></pre><p>To find out the number of points, <em>npoin</em>, the mesh connectivity, <em>inpoel</em>, can be queried:</p><pre class="m-code"><span class="k">auto</span> <span class="n">minmax</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="o">*</span><span class="n">minmax</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></pre><aside class="m-note m-info"><h4>Note</h4><p>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity.</p></aside><aside class="m-note m-default"><h4>See also</h4><p><a href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0" class="m-dox">tk::<wbr />genInpoed</a> for similar data that sometimes may be more advantageous</p><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="a559eb56e40ec844767bd2a55da55bda0"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a559eb56e40ec844767bd2a55da55bda0" class="m-dox-self">genInpoed</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, edge connectivity.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element (3 or 4)</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linear vector storing edge connectivity (point ids p &lt; q)</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linear vector and is very similar to the linked lists, <em>edsup1</em> and _edsup2, generated by <a href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b" class="m-dox">genEdsup()</a>. The difference is that in the linear vector, inpoed, generated here, both edge point ids are stored as a pair, p &lt; q, as opposed to the linked lists edsup1 and edsup2, in which edsup1 only stores the edge-end point ids (still associated to edge-start point ids when used together with edsup2). The rationale is that while inpoed is larger in memory, it allows direct access to edges (pair of point ids making up an edge), edsup1 and edsup2 are smaller in memory, still allow accessing the same data (edge point id pairs) but only in a linear fashion, not by direct access to particular edges. Accessing all unique edges using the edge connectivity data structure, inpoed, generated here can be accomplished by</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">inpoed</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">use</span> <span class="n">point</span> <span class="n">id</span> <span class="n">p</span> <span class="n">of</span> <span class="n">edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">inpoed</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">use</span> <span class="n">point</span> <span class="n">id</span> <span class="n">q</span> <span class="n">of</span> <span class="n">edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">inpoed</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span></pre><aside class="m-note m-info"><h4>Note</h4><p>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity.</p></aside><aside class="m-note m-default"><h4>See also</h4><p><a href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b" class="m-dox">tk::<wbr />genEdsup</a> for similar data that sometimes may be more advantageous</p><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="a9d835a7a93970d17a66356b64f3291af"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a9d835a7a93970d17a66356b64f3291af" class="m-dox-self">genEsupel</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, elements surrounding points of elements.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linked lists storing elements surrounding points of elements</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esupel1</em> and <em>esupel2</em>, where <em>esupel2</em> holds the indices at which <em>esupel1</em> holds the element ids surrounding points of elements. Looping over all elements surrounding the points of all elements can then be accomplished by the following loop:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">nelem</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">esupel</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">esupel</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
     <span class="n">use</span> <span class="n">element</span> <span class="n">id</span> <span class="n">esupel</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></pre><p>To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: <code class="m-code"><span class="k">auto</span> <span class="n">nelem</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="n">nnpe</span><span class="p">;</span></code></p><aside class="m-note m-info"><h4>Note</h4><p>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested.</p></aside><aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="a7b12aff8f884c70e45c6037b4f37e662"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7b12aff8f884c70e45c6037b4f37e662" class="m-dox-self">genEsuel</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, elements surrounding elements.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linked lists storing elements surrounding elements</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second; it will throw an exception.</p></aside><p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), <em>esuel1</em> and <em>esuel2</em>, where <em>esuel2</em> holds the indices at which <em>esuel1</em> holds the element ids surrounding elements. Looping over elements surrounding elements can then be accomplished by the following loop:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">nelem</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">esuel</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">esuel</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
     <span class="n">use</span> <span class="n">element</span> <span class="n">id</span> <span class="n">esuel</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></pre><p>To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: <code class="m-code"><span class="k">auto</span> <span class="n">nelem</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="n">nnpe</span><span class="p">;</span></code></p><aside class="m-note m-info"><h4>Note</h4><p>In principle, this function <em>should</em> work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested.</p></aside><aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="a7c8a720dd257388a44d5ca7af7aaec8f"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7c8a720dd257388a44d5ca7af7aaec8f" class="m-dox-self">genInedel</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::vector&lt;std::size_t&gt;&amp; inpoed)</span></span>
            </h3>
            <p>Generate derived data structure, edges of elements.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element</td>
                </tr>
                <tr>
                  <td>inpoed&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Edge connectivity as linear vector, see <a href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0" class="m-dox">tk::<wbr />genInpoed</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Linear vector storing all edge ids * 2 of all elements</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or inpoed or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>The data generated here is stored in a linear vector with all edge ids (as defined by inpoed) of all elements. The edge ids stored in inedel can be directly used to index the vector inpoed. Because the derived data structure generated here, inedel, is intended to be used in conjunction with the linear vector inpoed and not with the linked lists edsup1 and edsup2, this function takes inpoed as an argument. Accessing the edges of element e using the edge of elements data structure, inedel, generated here can be accomplished by</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">nelem</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nepe</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">use</span> <span class="n">edge</span> <span class="n">id</span> <span class="n">inedel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="n">nepe</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="n">of</span> <span class="n">element</span> <span class="n">e</span><span class="p">,</span> <span class="n">or</span>
    <span class="n">use</span> <span class="n">point</span> <span class="n">ids</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="n">of</span> <span class="n">edge</span> <span class="n">id</span> <span class="n">inedel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="n">nepe</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="n">of</span> <span class="n">element</span> <span class="n">e</span> <span class="n">as</span>
      <span class="n">p</span> <span class="o">=</span> <span class="n">inpoed</span><span class="p">[</span> <span class="n">inedel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="n">nepe</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="p">]</span>
      <span class="n">q</span> <span class="o">=</span> <span class="n">inpoed</span><span class="p">[</span> <span class="n">inedel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="n">nepe</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span> <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span></pre><p>where <em>nepe</em> denotes the number of edges per elements: 3 for triangles, 6 for tetrahedra. To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: <code class="m-code"><span class="k">auto</span> <span class="n">nelem</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="n">nnpe</span><span class="p">;</span></code></p><aside class="m-note m-info"><h4>Note</h4><p>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity.</p></aside><aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="af261e2b0ef3a9622a0fc51d6efc65967"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::unordered_map&lt;<a href="classtk_1_1_uns_mesh.html#a622c34bab099c772650f046b848346d7" class="m-dox">UnsMesh::<wbr />Edge</a>, std::vector&lt;std::size_t&gt;, <a href="structtk_1_1_uns_mesh_1_1_hash.html" class="m-dox">UnsMesh::<wbr />Hash</a>&lt;2&gt;, <a href="structtk_1_1_uns_mesh_1_1_eq.html" class="m-dox">UnsMesh::<wbr />Eq</a>&lt;2&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af261e2b0ef3a9622a0fc51d6efc65967" class="m-dox-self">genEsued</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              std::size_t nnpe,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, elements surrounding edges.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>nnpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of nodes per element (3 or 4)</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Associative container storing elements surrounding edges (value), assigned to edge-end points (key)</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</p></aside><p>Looping over elements surrounding all edges can be accomplished by the following loop:</p><pre class="m-code"><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">edge</span><span class="p">,</span><span class="n">surr_elements</span><span class="p">]</span> <span class="o">:</span> <span class="n">esued</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">use</span> <span class="n">element</span> <span class="n">edge</span><span class="o">-</span><span class="n">end</span><span class="o">-</span><span class="n">point</span> <span class="n">ids</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">surr_elements</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">use</span> <span class="n">element</span> <span class="n">id</span> <span class="n">e</span>
  <span class="p">}</span>
<span class="p">}</span></pre><p>esued.size() equals the number of edges.</p><aside class="m-note m-info"><h4>Note</h4><p>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity.</p></aside><aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="ab68c15dd976b0c7420ebee8770fb1f9c"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab68c15dd976b0c7420ebee8770fb1f9c" class="m-dox-self">genNbfacTet</a>(</span><span class="m-dox-wrap">std::size_t tnbfac,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;std::size_t&gt;&amp; triinpoel_complete,
              const std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;&amp; bface_complete,
              const std::unordered_map&lt;std::size_t, std::size_t&gt;&amp; lid,
              std::vector&lt;std::size_t&gt;&amp; triinpoel,
              std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;&amp; bface)</span></span>
            </h3>
            <p>Generate total number of boundary faces in this chunk.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">tnbfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of boundary faces in the entire mesh.</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh.</td>
                </tr>
                <tr>
                  <td>triinpoel_complete&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interconnectivity of points and boundary-face in the entire mesh.</td>
                </tr>
                <tr>
                  <td>bface_complete&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Map of boundary-face lists mapped to corresponding side set ids for the entire mesh.</td>
                </tr>
                <tr>
                  <td>lid&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mapping between the node indices used in the smaller inpoel connectivity (a subset of the entire triinpoel_complete connectivity), e.g., after mesh partitioning.</td>
                </tr>
                <tr>
                  <td>triinpoel&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Interconnectivity of points and boundary-face in this mesh-partition.</td>
                </tr>
                <tr>
                  <td>bface&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Map of boundary-face lists mapped to corresponding side set ids for this mesh-partition</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Number of boundary-faces on this chare/mesh-partition.</td>
                </tr>
              </tfoot>
            </table>
<p>This function takes a mesh by its domain-element (tetrahedron-connectivity) in inpoel and a boundary-face (triangle) connectivity in triinpoel_complete. Based on these two arrays, it searches for those faces of triinpoel_complete that are also in inpoel and as a result it generates (1) the number of boundary faces shared with the mesh in inpoel and (2) the intersection of the triangle element connectivity whose faces are shared with inpoel. An example use case is where triinpoel_complete contains the connectivity for the boundary of the full problem/mesh and inpoel contains the connectivity for only a chunk of an already partitioned mesh. This function then intersects triinpoel_complete with inpoel and returns only those faces that share nodes with inpoel.</p>
          </div></section>
          <section class="m-dox-details" id="a5b61b3cb6492e71ff9853404440fddcc"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;int&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a5b61b3cb6492e71ff9853404440fddcc" class="m-dox-self">genEsuelTet</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, elements surrounding elements as a fixed length data structure as a full vector, including boundary elements as -1.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><p>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span> <span class="p">{</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
                                    <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span> <span class="p">};</span></pre><p>specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }.</p></td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Vector storing elements surrounding elements</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-danger"><h4>Warning</h4><p>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second; it will throw an exception.</p></aside><p>The data generated here is stored in a single vector, with length nfpe * nelem. Note however, that nelem is not explicitly provided, but calculated from inpoel. For boundary elements, at the boundary face, this esuelTet stores value -1 indicating that this is outside the domain. The convention for numbering the local face (triangle) connectivity is very important, e.g., in generating the inpofa array later. This node ordering convention is stored in <a href="namespacetk.html#a6ad0280af8cd383252a1b894ac9b3c96" class="m-dox">tk::<wbr />lpofa</a>. Thus function is specific to tetrahedra, which is reflected in the fact that nnpe and nfpe are being set here in the function rather than being input arguments. To find out the number of elements, <em>nelem</em>, the size of the mesh connectivity vector, <em>inpoel</em>, can be devided by the number of nodes per elements, <em>nnpe</em>: <code class="m-code"><span class="k">auto</span> <span class="n">nelem</span> <span class="o">=</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="n">nnpe</span><span class="p">;</span></code></p>
          </div></section>
          <section class="m-dox-details" id="a9bda76e788ecb9f8f6e9ba004319b5e9"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a9bda76e788ecb9f8f6e9ba004319b5e9" class="m-dox-self">genNipfac</a>(</span><span class="m-dox-wrap">std::size_t nfpe,
              std::size_t nbfac,
              const std::vector&lt;int&gt;&amp; esuelTet)</span></span>
            </h3>
            <p>Generate number of internal and physical-boundary faces.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nfpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of faces per element.</td>
                </tr>
                <tr>
                  <td>nbfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of boundary faces.</td>
                </tr>
                <tr>
                  <td>esuelTet&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding elements.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Total number of faces in the mesh</td>
                </tr>
              </tfoot>
            </table>
<p>The unsigned integer here gives the number of internal and</p>
          </div></section>
          <section class="m-dox-details" id="af281200a7657c27936421122cb275757"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;int&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af281200a7657c27936421122cb275757" class="m-dox-self">genEsuf</a>(</span><span class="m-dox-wrap">std::size_t nfpe,
              std::size_t nipfac,
              std::size_t nbfac,
              const std::vector&lt;std::size_t&gt;&amp; belem,
              const std::vector&lt;int&gt;&amp; esuelTet)</span></span>
            </h3>
            <p>Generate derived data structure, elements surrounding faces.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nfpe&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of faces per element.</td>
                </tr>
                <tr>
                  <td>nipfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of internal and physical-boundary faces.</td>
                </tr>
                <tr>
                  <td>nbfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of boundary faces.</td>
                </tr>
                <tr>
                  <td>belem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Boundary element vector.</td>
                </tr>
                <tr>
                  <td>esuelTet&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding elements.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Elements surrounding faces.</td>
                </tr>
              </tfoot>
            </table>
<p>The unsigned integer vector gives the IDs of the elements to the</p>
          </div></section>
          <section class="m-dox-details" id="af5cc30c5f79658a16b2ea7a133f71e2c"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af5cc30c5f79658a16b2ea7a133f71e2c" class="m-dox-self">genInpofaTet</a>(</span><span class="m-dox-wrap">std::size_t nipfac,
              std::size_t nbfac,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;std::size_t&gt;&amp; triinpoel,
              const std::vector&lt;int&gt;&amp; esuelTet)</span></span>
            </h3>
            <p>Generate derived data structure, node-face connectivity.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nipfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of internal and physical-boundary faces.</td>
                </tr>
                <tr>
                  <td>nbfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of boundary faces.</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity.</td>
                </tr>
                <tr>
                  <td>triinpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face-node connectivity.</td>
                </tr>
                <tr>
                  <td>esuelTet&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding elements.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Points surrounding faces. The unsigned integer vector gives the elements to the left and to the right of each face in the mesh.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ad69e35d3f9e7f2237c0c5c3b9c5c0888"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad69e35d3f9e7f2237c0c5c3b9c5c0888" class="m-dox-self">genBelemTet</a>(</span><span class="m-dox-wrap">std::size_t nbfac,
              const std::vector&lt;std::size_t&gt;&amp; inpofa,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup)</span></span>
            </h3>
            <p>Generate derived data structure, host/boundary element.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nbfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of boundary faces.</td>
                </tr>
                <tr>
                  <td>inpofa&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face-node connectivity.</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points as linked lists, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup</a></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Host elements or boundary elements. The unsigned integer vector gives the elements to the left of each boundary face in the mesh.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="abb68cb017ab503c71a4d58ad8323737c"><div>
            <h3>
              <span class="m-dox-wrap-bumper">Fields tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#abb68cb017ab503c71a4d58ad8323737c" class="m-dox-self">genGeoFaceTri</a>(</span><span class="m-dox-wrap">std::size_t nipfac,
              const std::vector&lt;std::size_t&gt;&amp; inpofa,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord)</span></span>
            </h3>
            <p>Generate derived data structure, face geometry.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nipfac&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of internal and physical-boundary faces.</td>
                </tr>
                <tr>
                  <td>inpofa&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face-node connectivity.</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Co-ordinates of nodes in this mesh-chunk.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Face geometry information. This includes face area, unit normal pointing outward of the element to the left of the face, and face centroid coordinates. Use the following examples to access this information for face-f.</td>
                </tr>
              </tfoot>
            </table>
<p>face area: geoFace(f,0,0), unit-normal x-component: geoFace(f,1,0), y-component: geoFace(f,2,0), z-component: geoFace(f,3,0), centroid x-coordinate: geoFace(f,4,0), y-coordinate: geoFace(f,5,0), z-coordinate: geoFace(f,6,0).</p>
          </div></section>
          <section class="m-dox-details" id="a8e4e79311cfbb84411a988b345c27a09"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a8e4e79311cfbb84411a988b345c27a09" class="m-dox-self">normal</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; x,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; y,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; z)</span></span>
            </h3>
            <p>Compute the unit normal vector of a triangle.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x-coordinates of the three vertices of the triangle</td>
                </tr>
                <tr>
                  <td>y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y-coordinates of the three vertices of the triangle</td>
                </tr>
                <tr>
                  <td>z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z-coordinates of the three vertices of the triangle</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Unit normal</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the unit normal vector of a triangle</p>
          </div></section>
          <section class="m-dox-details" id="a8fd1bff99bc1afceca19f11735b8297d"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a8fd1bff99bc1afceca19f11735b8297d" class="m-dox-self">area</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; x,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; y,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; z)</span></span>
            </h3>
            <p>Compute the area of a triangle.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x-coordinates of the three vertices of the triangle</td>
                </tr>
                <tr>
                  <td>y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y-coordinates of the three vertices of the triangle</td>
                </tr>
                <tr>
                  <td>z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z-coordinates of the three vertices of the triangle</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Area</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the are of a triangle</p>
          </div></section>
          <section class="m-dox-details" id="ab6dc93c321bffbc6396d15a92ecfdf99"><div>
            <h3>
              <span class="m-dox-wrap-bumper">Fields tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab6dc93c321bffbc6396d15a92ecfdf99" class="m-dox-self">geoFaceTri</a>(</span><span class="m-dox-wrap">const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; x,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; y,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; z)</span></span>
            </h3>
            <p>Compute geometry of the face given by three vertices.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x-coordinates of the three vertices of the triangular face.</td>
                </tr>
                <tr>
                  <td>y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y-coordinates of the three vertices of the triangular face.</td>
                </tr>
                <tr>
                  <td>z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z-coordinates of the three vertices of the triangular face.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Face geometry information. This includes face area, unit normal pointing outward of the element to the left of the face, and face centroid coordinates.</td>
                </tr>
              </tfoot>
            </table>
<p>Compute geometry of the face given by three vertices 

face area: geoFace(f,0,0), unit-normal x-component: geoFace(f,1,0), y-component: geoFace(f,2,0), z-component: geoFace(f,3,0), centroid x-coordinate: geoFace(f,4,0), y-coordinate: geoFace(f,5,0), z-coordinate: geoFace(f,6,0).</p>
          </div></section>
          <section class="m-dox-details" id="a270eadffd276067dd536490955591430"><div>
            <h3>
              <span class="m-dox-wrap-bumper">Fields tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a270eadffd276067dd536490955591430" class="m-dox-self">genGeoElemTet</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord)</span></span>
            </h3>
            <p>Generate derived data structure, element geometry.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity.</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Co-ordinates of nodes in this mesh-chunk.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Element geometry information. This includes element volume, element centroid coordinates, and minimum edge length. Use the following examples to access this information for element-e. volume: geoElem(e,0,0), centroid x-coordinate: geoElem(e,1,0), y-coordinate: geoElem(e,2,0), z-coordinate: geoElem(e,3,0). minimum edge-length: geoElem(e,4,0).</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ab49591cb2d971a3dc0cd2bb29334922c"><div>
            <h3>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab49591cb2d971a3dc0cd2bb29334922c" class="m-dox-self">leakyPartition</a>(</span><span class="m-dox-wrap">const std::vector&lt;int&gt;&amp; esueltet,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord)</span></span>
            </h3>
            <p>Perform leak-test on mesh (partition)</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">esueltet&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding elements for tetrahedra, see tk::genEsueltet()</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Node coordinates</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if partition leaks.</td>
                </tr>
              </tfoot>
            </table>
<p>This function computes a surface integral over the boundary of the incoming mesh (partition). A non-zero vector result indicates a leak, e.g., a hole in the mesh (partition), which indicates an error either in the</p>
          </div></section>
          <section class="m-dox-details" id="aad0b322c0aa1ffd260a5117f6fffb020"><div>
            <h3>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aad0b322c0aa1ffd260a5117f6fffb020" class="m-dox-self">conforming</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              bool cerr,
              const std::vector&lt;std::size_t&gt;&amp; rid)</span></span>
            </h3>
            <p>Check if mesh (partition) is conforming.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Node coordinates</td>
                </tr>
                <tr>
                  <td>cerr&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>True if hanging-node edge data should be output to std::cerr (true by default)</td>
                </tr>
                <tr>
                  <td>rid&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td><a href="namespace_a_m_r.html" class="m-dox">AMR</a> Lib node id map std::cerr (true by default)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if mesh (partition) has no hanging nodes and thus the mesh is conforming, false if non-conforming.</td>
                </tr>
              </tfoot>
            </table>
<p>A conforming mesh by definition has no hanging nodes. A node is hanging if an edge of one element coincides with two (or more) edges (of two or more other elements). Thus, testing for conformity relies on checking the coordinates of all vertices: if any vertex coincides with that of a mid-point node of an edge, that is a hanging node. Note that this assumes that hanging nodes can only be at the mid-point of edges. This may happen after a mesh refinement step, due to a problem/bug, within the mesh refinement algorithm given by J. Waltz, Parallel adaptive refinement for unsteady flow calculations on 3D unstructured grids, International Journal for Numerical Methods in Fluids, 46: 37–57, 2004, which always adds/removes vertices at the mid-points of edges of a tetrahedron mesh within a single refinement step. Thus this algorithm is intended for this specific case, i.e., test for conformity after a single refinement step and not after multiple ones or for detecting hanging nodes in an arbitrary mesh.</p>
          </div></section>
          <section class="m-dox-details" id="adb48770af89aaa8c6903aa60c20956e1"><div>
            <h3>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#adb48770af89aaa8c6903aa60c20956e1" class="m-dox-self">intet</a>(</span><span class="m-dox-wrap">const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; p,
              std::size_t e,
              std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 4&gt;&amp; N)</span></span>
            </h3>
            <p>Determine if a point is in a tetrahedron.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh node coordinates</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh element connectivity</td>
                </tr>
                <tr>
                  <td>p&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Point coordinates</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh cell index</td>
                </tr>
                <tr>
                  <td>N&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Shapefunctions evaluated at the point</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if ppoint is in mesh cell</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-default"><h4>See also</h4><p>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008</p></aside>
          </div></section>
          <section class="m-dox-details" id="a2be9c3302cc95370541eca0353c3e08b"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a2be9c3302cc95370541eca0353c3e08b" class="m-dox-self">curl</a>(</span><span class="m-dox-wrap">const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; v)</span></span>
            </h3>
            <p>Compute curl of a vector field at nodes of unstructured tetrahedra mesh.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh node coordinates</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh element connectivity</td>
                </tr>
                <tr>
                  <td>v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector field whose curl to compute</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Weak (partial) result of curl of v (partial beacuse it still needs a division by the nodal volumes.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="accc2f0b25920758e1a07f1eb0e80ba19"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#accc2f0b25920758e1a07f1eb0e80ba19" class="m-dox-self">div</a>(</span><span class="m-dox-wrap">const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; v)</span></span>
            </h3>
            <p>Compute divergence of vector field at nodes of unstructured tetrahedra mesh.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh node coordinates</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh element connectivity</td>
                </tr>
                <tr>
                  <td>v&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector field whose divergence to compute</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Weak (partial) result of div v (partial beacuse it still needs a division by the nodal volumes.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a6f77a6120edfe8a5a1596cbc7f5b682f"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a6f77a6120edfe8a5a1596cbc7f5b682f" class="m-dox-self">grad</a>(</span><span class="m-dox-wrap">const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; phi)</span></span>
            </h3>
            <p>Compute gradient of a scalar field at nodes of unstructured tetrahedra mesh.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh node coordinates</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh element connectivity</td>
                </tr>
                <tr>
                  <td>phi&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Scalar field whose gradient to compute</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Weak (partial) result of grad phi (partial beacuse it still needs a division by the nodal volumes.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ad72b139a74e8954c87fd9d0bd413e1c8"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad72b139a74e8954c87fd9d0bd413e1c8" class="m-dox-self">normal</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x1,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x3,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y1,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y3,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z1,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z3,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; nx,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; ny,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&amp; nz)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">x1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 1st vertex of the triangle</td>
                </tr>
                <tr>
                  <td>x2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 2nd vertex of the triangle</td>
                </tr>
                <tr>
                  <td>x3&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 3rd vertex of the triangle</td>
                </tr>
                <tr>
                  <td>y1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 1st vertex of the triangle</td>
                </tr>
                <tr>
                  <td>y2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 2nd vertex of the triangle</td>
                </tr>
                <tr>
                  <td>y3&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 3rd vertex of the triangle</td>
                </tr>
                <tr>
                  <td>z1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 1st vertex of the triangle</td>
                </tr>
                <tr>
                  <td>z2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 2nd vertex of the triangle</td>
                </tr>
                <tr>
                  <td>z3&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 3rd vertex of the triangle</td>
                </tr>
                <tr>
                  <td>nx&nbsp;<span class="m-label m-flat m-warning">out</span></td>
                  <td>x coordinate of the unit normal</td>
                </tr>
                <tr>
                  <td>ny&nbsp;<span class="m-label m-flat m-warning">out</span></td>
                  <td>y coordinate of the unit normal</td>
                </tr>
                <tr>
                  <td>nz&nbsp;<span class="m-label m-flat m-warning">out</span></td>
                  <td>z coordinate of the unit normal</td>
                </tr>
              </tbody>
            </table>
<p>Compute the unit normal vector of a triangle</p>
          </div></section>
          <section class="m-dox-details" id="aa9d35ddc0df888b4c03f56407df6f664"><div>
            <h3>
              <span class="m-dox-wrap-bumper"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa9d35ddc0df888b4c03f56407df6f664" class="m-dox-self">area</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x1,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> x3,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y1,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> y3,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z1,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z2,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> z3)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">x1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 1st vertex of the triangle</td>
                </tr>
                <tr>
                  <td>x2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 2nd vertex of the triangle</td>
                </tr>
                <tr>
                  <td>x3&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>x coordinate of the 3rd vertex of the triangle</td>
                </tr>
                <tr>
                  <td>y1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 1st vertex of the triangle</td>
                </tr>
                <tr>
                  <td>y2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 2nd vertex of the triangle</td>
                </tr>
                <tr>
                  <td>y3&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>y coordinate of the 3rd vertex of the triangle</td>
                </tr>
                <tr>
                  <td>z1&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 1st vertex of the triangle</td>
                </tr>
                <tr>
                  <td>z2&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 2nd vertex of the triangle</td>
                </tr>
                <tr>
                  <td>z3&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>z coordinate of the 3rd vertex of the triangle</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Area of the triangle</td>
                </tr>
              </tfoot>
            </table>
<p>Compute the are of a triangle</p>
          </div></section>
          <section class="m-dox-details" id="aae5766a4d0dae70d561c514f2758072e"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aae5766a4d0dae70d561c514f2758072e" class="m-dox-self">nodegrad</a>(</span><span class="m-dox-wrap">std::size_t node,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; esup,
              const tk::Fields&amp; U,
              <a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> c)</span></span>
            </h3>
            <p>Compute gradient at a mesh node.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">node&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Node id at which to compute gradient</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh node coordinates</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh element connectivity</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Linked lists storing elements surrounding points, see <a href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" class="m-dox">tk::<wbr />genEsup()</a></td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Field vector whose component gradient to compute</td>
                </tr>
                <tr>
                  <td>c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Scalar component to compute gradient of</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Gradient of U(c) at mesh node</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a6310e8e153342ea9dfc433ff49006b66"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a6310e8e153342ea9dfc433ff49006b66" class="m-dox-self">edgegrad</a>(</span><span class="m-dox-wrap">const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;std::size_t&gt;&amp; esued,
              const tk::Fields&amp; U,
              <a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> c)</span></span>
            </h3>
            <p>Compute gradient at a mesh edge.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh node coordinates</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh element connectivity</td>
                </tr>
                <tr>
                  <td>esued&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>List of elements surrounding edge, see <a href="namespacetk.html#af261e2b0ef3a9622a0fc51d6efc65967" class="m-dox">tk::<wbr />genEsued()</a></td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Field vector whose component gradient to compute</td>
                </tr>
                <tr>
                  <td>c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Scalar component to compute gradient of</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Gradient of U(c) at mesh edge</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a293dd6fafcc3b8f4b28bef4f3ef050e1"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a293dd6fafcc3b8f4b28bef4f3ef050e1" class="m-dox-self">shiftToZero</a>(</span><span class="m-dox-wrap">std::vector&lt;std::size_t&gt;&amp; inpoel)</span></span>
            </h3>
            <p>Shift node IDs to start with zero in element connectivity.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Inteconnectivity of points and elements</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Amount shifted</td>
                </tr>
              </tfoot>
            </table>
<p>This function implements a simple reordering of the node ids of the element connectivity in inpoel by shifting the node ids so that the smallest is zero.</p><aside class="m-note m-info"><h4>Note</h4><p>It is okay to call this function with an empty container; it will simply return without throwing an exception.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a261ac7b3e006f7fa6621ad910b6553cc"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a261ac7b3e006f7fa6621ad910b6553cc" class="m-dox-self">remap</a>(</span><span class="m-dox-wrap">std::vector&lt;std::size_t&gt;&amp; ids,
              const std::vector&lt;std::size_t&gt;&amp; map)</span></span>
            </h3>
            <p>Apply new mapping to vector of indices.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ids&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Vector of integer IDs to remap</td>
                </tr>
                <tr>
                  <td>map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of indices creating a new order</td>
                </tr>
              </tbody>
            </table>
<p>This function applies a mapping (reordering) to the integer IDs passed in using the map passed in. The mapping is expressed between the array index and its value. The function overwrites every value, i, of vector ids with map[i].</p><aside class="m-note m-info"><h4>Note</h4><p>The sizes of ids and map need not equal. Only the maximum index in ids must be lower than the size of map.</p><p>It is okay to call this function with either of the containers empty; it will simply return without throwing an exception.</p></aside>
          </div></section>
          <section class="m-dox-details" id="af808bcf55ee4b5e910f68ecb0fe2f8dd"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af808bcf55ee4b5e910f68ecb0fe2f8dd" class="m-dox-self">remap</a>(</span><span class="m-dox-wrap">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; r,
              const std::vector&lt;std::size_t&gt;&amp; map)</span></span>
            </h3>
            <p>Apply new mapping to vector of real numbers.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">r&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Vector of real numbers to remap</td>
                </tr>
                <tr>
                  <td>map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of indices creating a new order</td>
                </tr>
              </tbody>
            </table>
<p>This function applies a mapping (reordering) to the real values passed in using the map passed in. The mapping is expressed between the array index and its value. The function moves every value r[i] to r[ map[i] ].</p><aside class="m-note m-info"><h4>Note</h4><p>The sizes of r and map must be equal and the maximum index in map must be lower than the size of map.</p><p>It is okay to call this function with either of the containers empty; it will simply return without throwing an exception.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a75a9071479f742158c8e2af6d769296e"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a75a9071479f742158c8e2af6d769296e" class="m-dox-self">remap</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; ids,
              const std::vector&lt;std::size_t&gt;&amp; map)</span></span>
            </h3>
            <p>Create remapped vector of indices using a vector.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ids&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of integer IDs to remap</td>
                </tr>
                <tr>
                  <td>map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of indices creating a new order</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Remapped vector of ids</td>
                </tr>
              </tfoot>
            </table>
<p>This function applies a mapping (reordering) to the integer IDs passed in using the map passed in. The mapping is expressed between the array index and its value. The function creates and returns a new container with remapped ids of identical size of the origin ids container.</p><aside class="m-note m-info"><h4>Note</h4><p>The sizes of ids and map must be equal and the maximum index in map must be lower than the size of map.</p><p>It is okay to call this function with either of the containers empty; if ids is empty, it returns an empty container; if map is empty, it will return the original container.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a1b909e9b0ca382a70d04369428b870b4"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a1b909e9b0ca382a70d04369428b870b4" class="m-dox-self">remap</a>(</span><span class="m-dox-wrap">std::vector&lt;std::size_t&gt;&amp; ids,
              const std::unordered_map&lt;std::size_t, std::size_t&gt;&amp; map)</span></span>
            </h3>
            <p>In-place remap vector of indices using a map.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ids&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of integer IDs to remap</td>
                </tr>
                <tr>
                  <td>map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Hash-map of key-&gt;value creating a new order</td>
                </tr>
              </tbody>
            </table>
<p>This function applies a mapping (reordering) to the integer IDs passed in using the map passed in. The mapping is expressed as a hash-map of key-&gt;value pairs, where the key is the original and the value is the new ids of the mapping. The function overwrites the ids container with the remapped ids of identical size.</p><aside class="m-note m-info"><h4>Note</h4><p>All ids in the input ids container must have a key in the map. Otherwise an exception is thrown.</p><p>It is okay to call this function with the ids container empty but not okay to pass an empty map.</p></aside>
          </div></section>
          <section class="m-dox-details" id="af12e0c9640bbca8b774394442f9e9594"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af12e0c9640bbca8b774394442f9e9594" class="m-dox-self">remap</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; ids,
              const std::unordered_map&lt;std::size_t, std::size_t&gt;&amp; map)</span></span>
            </h3>
            <p>Create remapped vector of indices using a map.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ids&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of integer IDs to create new container of ids from</td>
                </tr>
                <tr>
                  <td>map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Hash-map of key-&gt;value creating a new order</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Remapped vector of ids</td>
                </tr>
              </tfoot>
            </table>
<p>This function applies a mapping (reordering) to the integer IDs passed in using the map passed in. The mapping is expressed as a hash-map of key-&gt;value pairs, where the key is the original and the value is the new ids of the mapping. The function creates and returns a new container with the remapped ids of identical size of the original ids container.</p><aside class="m-note m-info"><h4>Note</h4><p>All ids in the input ids container must have a key in the map. Otherwise an exception is thrown.</p><p>It is okay to call this function with the ids container empty but not okay to pass an empty map.</p></aside>
          </div></section>
          <section class="m-dox-details" id="a5cd7c3fd77cff6095f0d2627a784b6e7"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::map&lt;int, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a5cd7c3fd77cff6095f0d2627a784b6e7" class="m-dox-self">remap</a>(</span><span class="m-dox-wrap">const std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;&amp; ids,
              const std::unordered_map&lt;std::size_t, std::size_t&gt;&amp; map)</span></span>
            </h3>
            <p>Create remapped map of vector of indices using a map.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ids&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Map of vector of integer IDs to create new container of ids from</td>
                </tr>
                <tr>
                  <td>map&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Hash-map of key-&gt;value creating a new order</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Remapped vector of ids</td>
                </tr>
              </tfoot>
            </table>
<p>This function applies a mapping (reordering) to the map of integer IDs passed in using the map passed in by applying remap(vector,map) on each vector of ids. The keys in the returned map will be the same as in ids.</p>
          </div></section>
          <section class="m-dox-details" id="a22a8b455edb4f8453d5a6173319f9c80"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a22a8b455edb4f8453d5a6173319f9c80" class="m-dox-self">renumber</a>(</span><span class="m-dox-wrap">const std::pair&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;&gt;&amp; psup)</span></span>
            </h3>
            <p>Reorder mesh points with the advancing front technique.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">psup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Points surrounding points</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Mapping created by renumbering (reordering)</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="acb19d7c5f6c7354614bb457d6b17afde"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::unordered_map&lt;std::size_t, std::size_t&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#acb19d7c5f6c7354614bb457d6b17afde" class="m-dox-self">assignLid</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; gid)</span></span>
            </h3>
            <p>Assign local ids to global ids.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">gid&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Global ids</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Map associating global ids to local ids</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a0ee7abd71123782d48e2ec04906fe982"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::tuple&lt;std::vector&lt;std::size_t&gt;, std::vector&lt;std::size_t&gt;, std::unordered_map&lt;std::size_t, std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a0ee7abd71123782d48e2ec04906fe982" class="m-dox-self">global2local</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; ginpoel)</span></span>
            </h3>
            <p>Generate element connectivity of local node IDs from connectivity of global node IDs also returning the mapping between local to global IDs.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ginpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element connectivity with global node IDs</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Tuple of (1) element connectivity with local node IDs, (2) the vector of unique global node IDs (i.e., the mapping between local to global node IDs), and (3) mapping between global to local node IDs.</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a6c5589db5d1caeac294a0b1569b65ebd"><div>
            <h3>
              <span class="m-dox-wrap-bumper">bool tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a6c5589db5d1caeac294a0b1569b65ebd" class="m-dox-self">positiveJacobians</a>(</span><span class="m-dox-wrap">const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 3&gt;&amp; coord)</span></span>
            </h3>
            <p>Test positivity of the Jacobian for all cells in a mesh.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element connectivity (zero-based, i.e., local if parallel)</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Node coordinates</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>True if Jacobians of all mesh cells are positive</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ab1b8944aeb6eae5bd8760a2928485139"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::map&lt;int, std::vector&lt;std::size_t&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab1b8944aeb6eae5bd8760a2928485139" class="m-dox-self">bfacenodes</a>(</span><span class="m-dox-wrap">const std::map&lt;int, std::vector&lt;std::size_t&gt;&gt;&amp; bface,
              const std::vector&lt;std::size_t&gt;&amp; triinpoel)</span></span>
            </h3>
            <p>Generate nodes of side set faces.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">bface&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Boundary-faces mapped to side set ids</td>
                </tr>
                <tr>
                  <td>triinpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Boundary-face connectivity</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Nodes of side set faces for each side set passed in</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a7a2f751a9f985c66ae1980d220c50c75"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7a2f751a9f985c66ae1980d220c50c75" class="m-dox-self">eval_gp</a>(</span><span class="m-dox-wrap">const std::size_t igp,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; coordfa,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 2&gt;&amp; coordgp)</span></span>
            </h3>
            <p>Compute the coordinates of quadrature points for face integral.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">igp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Index of quadrature points</td>
                </tr>
                <tr>
                  <td>coordfa&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates for face element</td>
                </tr>
                <tr>
                  <td>coordgp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of coordinates for quadrature points in reference space</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Array of coordinates for quadrature points in physical space</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="aab2e57ac0b1baf8981558aa3a91764af"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aab2e57ac0b1baf8981558aa3a91764af" class="m-dox-self">eval_gp</a>(</span><span class="m-dox-wrap">const std::size_t igp,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 4&gt;&amp; coord,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coordgp)</span></span>
            </h3>
            <p>Compute the coordinates of quadrature points for volume integral.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">igp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Index of quadrature points</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates for tetrahedron element</td>
                </tr>
                <tr>
                  <td>coordgp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of coordinates for quadrature points in reference space</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Array of coordinates for quadrature points in physical space</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a31a683418acb38b655511b5195e705eb"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a31a683418acb38b655511b5195e705eb" class="m-dox-self">eval_dBdxi</a>(</span><span class="m-dox-wrap">const std::size_t ndof,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; coordgp)</span></span>
            </h3>
            <p>Compute the derivatives of Dubiner basis wrt. reference coordinates.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>coordgp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Coordinates in ref element where derivatives are needed</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Array of the derivatives of basis functions</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a20a4a76c54a62ad526c6cace7d51b633"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a20a4a76c54a62ad526c6cace7d51b633" class="m-dox-self">eval_dBdx_p1</a>(</span><span class="m-dox-wrap">const std::size_t ndof,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; jacInv)</span></span>
            </h3>
            <p>Compute the derivatives of basis function for DG(P1)</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>jacInv&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of the inverse of Jacobian</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Array of the derivatives of basis functions</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a4f21cafccba0a899016b10f0b5dfe62b"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a4f21cafccba0a899016b10f0b5dfe62b" class="m-dox-self">eval_dBdx_p2</a>(</span><span class="m-dox-wrap">const std::size_t igp,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coordgp,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 3&gt;&amp; jacInv,
              std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; dBdx)</span></span>
            </h3>
            <p>Compute the derivatives of basis function for DG(P2)</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">igp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Index of quadrature points</td>
                </tr>
                <tr>
                  <td>coordgp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Gauss point coordinates for tetrahedron element</td>
                </tr>
                <tr>
                  <td>jacInv&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of the inverse of Jacobian</td>
                </tr>
                <tr>
                  <td>dBdx&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Array of the derivatives of basis function</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a05283ead5075604d24ce31bd08f15e29"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a05283ead5075604d24ce31bd08f15e29" class="m-dox-self">eval_basis</a>(</span><span class="m-dox-wrap">const std::size_t ndof,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> xi,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> eta,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> zeta)</span></span>
            </h3>
            <p>Compute the Dubiner basis functions.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>xi&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Coordinates for quadrature points in reference space</td>
                </tr>
                <tr>
                  <td>eta&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Coordinates for quadrature points in reference space</td>
                </tr>
                <tr>
                  <td>zeta&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Coordinates for quadrature points in reference space</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Vector of basis functions</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a7f2d089704f8e4ba486a52f3b0dd1839"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7f2d089704f8e4ba486a52f3b0dd1839" class="m-dox-self">eval_state</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              const std::size_t ndof_el,
              const std::size_t e,
              const Fields&amp; U,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B)</span></span>
            </h3>
            <p>Compute the state variables for the tetrahedron element.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>ndof_el&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom for the local element</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Index for the tetrahedron element</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>B&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of basis functions</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Vector of state variable for tetrahedron element</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ace05c78061791953348607c3f58a0f9d"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ace05c78061791953348607c3f58a0f9d" class="m-dox-self">DubinerToTaylor</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t e,
              const std::size_t ndof,
              const tk::Fields&amp; U,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; coord)</span></span>
            </h3>
            <p>Transform the solution with Dubiner basis to the solution with Taylor basis.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Id of element whose solution is to be limited</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>High-order solution vector with Dubiner basis</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>High-order solution vector with Taylor basis</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ad58a99eff3952dadd4750f4263cc2fe8"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad58a99eff3952dadd4750f4263cc2fe8" class="m-dox-self">TaylorToDubiner</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              std::size_t e,
              std::size_t ndof,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; coord,
              const tk::Fields&amp; geoElem,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; unk)</span></span>
            </h3>
            <p>Convert the solution with Taylor basis to the solution with Dubiner basis.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Id of element whose solution is to be limited</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>geoElem</td>
                  <td></td>
                </tr>
                <tr>
                  <td>unk&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>High-order solution vector with Taylor basis</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a5da762c456f9c8fb0872f9e38d7beb92"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a5da762c456f9c8fb0872f9e38d7beb92" class="m-dox-self">eval_TaylorBasis</a>(</span><span class="m-dox-wrap">const std::size_t ndof,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; x,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; x_c,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 4&gt;&amp; coordel)</span></span>
            </h3>
            <p>Evaluate the Taylor basis at points.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Nodal coordinates</td>
                </tr>
                <tr>
                  <td>x_c&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Coordinates of the centroid</td>
                </tr>
                <tr>
                  <td>coordel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates for the tetrahedron</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a39a14210e3b0950ef04faac6796027f2"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a39a14210e3b0950ef04faac6796027f2" class="m-dox-self">DubinerToTaylorRefEl</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t e,
              const std::size_t ndof,
              const std::size_t ndof_el,
              const std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; mtInv,
              const tk::Fields&amp; U)</span></span>
            </h3>
            <p>Transform the solution from Dubiner basis to Taylor basis.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Id of element whose solution is to be limited</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>ndof_el&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Local number of degrees of freedom for the element</td>
                </tr>
                <tr>
                  <td>mtInv&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Inverse of Taylor mass matrix</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>High-order solution vector with Dubiner basis</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>High-order solution vector with Taylor basis (ref element)</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a71612512ff454a48f3ba82a9976573e3"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a71612512ff454a48f3ba82a9976573e3" class="m-dox-self">TaylorToDubinerRefEl</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; unk)</span></span>
            </h3>
            <p>Transform the solution from Taylor to Dubiner basis.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>unk&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>High-order solution vector with Taylor basis that gets transformed to solution with Dubiner basis</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="aaa3bc5f93f0ae004537f98d64e015e8a"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aaa3bc5f93f0ae004537f98d64e015e8a" class="m-dox-self">eval_TaylorBasisRefEl</a>(</span><span class="m-dox-wrap">std::size_t ndof,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> x,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> y,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> z)</span></span>
            </h3>
            <p>Evaluate the Taylor basis at a point in the reference element.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>x&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Xi coordinate of point in reference element</td>
                </tr>
                <tr>
                  <td>y&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Eta coordinate of point in reference element</td>
                </tr>
                <tr>
                  <td>z&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Zeta coordinate of point in reference element</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="aaefd147a807ea8ce52fa64c99527b9b1"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aaefd147a807ea8ce52fa64c99527b9b1" class="m-dox-self">invMassMatTaylorRefEl</a>(</span><span class="m-dox-wrap">std::size_t dof)</span></span>
            </h3>
            <p>Obtain inverse mass matrix for Taylor basis in reference element.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">dof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Inverse mass matrix</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ab81f5b0a43cf0e18bad829649b285cf5"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab81f5b0a43cf0e18bad829649b285cf5" class="m-dox-self">massMatrixTaylorRefEl</a>(</span><span class="m-dox-wrap">std::size_t dof)</span></span>
            </h3>
            <p>Obtain mass matrix for Taylor basis in reference element.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">dof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Mass matrix</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a232f493cf1cec91423df69a44bfdb2c5"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a232f493cf1cec91423df69a44bfdb2c5" class="m-dox-self">bndSurfInt</a>(</span><span class="m-dox-wrap">const bool pref,
              std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::vector&lt;std::size_t&gt;&amp; bcconfig,
              const <a href="classinciter_1_1_face_data.html" class="m-dox">inciter::<wbr />FaceData</a>&amp; fd,
              const Fields&amp; geoFace,
              const Fields&amp; geoElem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const <a href="namespacetk.html#ac36fb71a41ff5a1d9a41143652d61438" class="m-dox">RiemannFluxFn</a>&amp; flux,
              const <a href="namespacetk.html#ab96930c6425f28fde0af48eb346cc1ed" class="m-dox">VelFn</a>&amp; vel,
              const <a href="namespacetk.html#aea3cd7451f600631750f04f970ef6f6e" class="m-dox">StateFn</a>&amp; state,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              Fields&amp; R,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannDeriv,
              int intsharp)</span></span>
            </h3>
            <p>Compute boundary surface flux integrals for a given boundary type for DG.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">pref&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Indicator for p-adaptive algorithm</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>EOS material block</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>bcconfig&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>BC configuration vector for multiple side sets</td>
                </tr>
                <tr>
                  <td>fd&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face connectivity and boundary conditions object</td>
                </tr>
                <tr>
                  <td>geoFace&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face geometry array</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Physical time</td>
                </tr>
                <tr>
                  <td>flux&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Riemann flux function to use</td>
                </tr>
                <tr>
                  <td>vel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Function to use to query prescribed velocity (if any)</td>
                </tr>
                <tr>
                  <td>state&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Function to evaluate the left and right solution state at boundaries</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitives at recent time step</td>
                </tr>
                <tr>
                  <td>ndofel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of local number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
                <tr>
                  <td>riemannDeriv&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Derivatives of partial-pressures and velocities computed from the Riemann solver for use in the non-conservative terms. These derivatives are used only for multi-material hydro and unused for single-material compflow and linear transport.</td>
                </tr>
                <tr>
                  <td>intsharp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface compression tag, an optional argument, with default 0, so that it is unused for single-material and transport.</td>
                </tr>
              </tbody>
            </table>
<p>Compute boundary surface flux integrals for a given boundary type for DG</p><p>This function computes contributions from surface integrals along all faces for a particular boundary condition type, configured by the state function</p>
          </div></section>
          <section class="m-dox-details" id="a454d85b03fabcb2bbd5d3c9a79db3b7a"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a454d85b03fabcb2bbd5d3c9a79db3b7a" class="m-dox-self">update_rhs_bc</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              std::size_t nmat,
              const std::size_t ndof,
              const std::size_t ndof_l,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; fn,
              const std::size_t el,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; fl,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B_l,
              Fields&amp; R,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannDeriv)</span></span>
            </h3>
            <p>Update the rhs by adding the boundary surface integration term.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>ndof_l&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom for the left element</td>
                </tr>
                <tr>
                  <td>wt&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Weight of gauss quadrature point</td>
                </tr>
                <tr>
                  <td>fn&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face/Surface normal</td>
                </tr>
                <tr>
                  <td>el&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Left element index</td>
                </tr>
                <tr>
                  <td>fl&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Surface flux</td>
                </tr>
                <tr>
                  <td>B_l&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Basis function for the left element</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
                <tr>
                  <td>riemannDeriv&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Derivatives of partial-pressures and velocities computed from the Riemann solver for use in the non-conservative terms. These derivatives are used only for multi-material hydro and unused for single-material compflow and linear transport.</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a23d73849c3644a212f6c4c0c457e3ade"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a23d73849c3644a212f6c4c0c457e3ade" class="m-dox-self">bndSurfIntFV</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t rdof,
              const std::vector&lt;std::size_t&gt;&amp; bcconfig,
              const <a href="classinciter_1_1_face_data.html" class="m-dox">inciter::<wbr />FaceData</a>&amp; fd,
              const Fields&amp; geoFace,
              const Fields&amp; geoElem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const <a href="namespacetk.html#ac36fb71a41ff5a1d9a41143652d61438" class="m-dox">RiemannFluxFn</a>&amp; flux,
              const <a href="namespacetk.html#ab96930c6425f28fde0af48eb346cc1ed" class="m-dox">VelFn</a>&amp; vel,
              const <a href="namespacetk.html#aea3cd7451f600631750f04f970ef6f6e" class="m-dox">StateFn</a>&amp; state,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;int&gt;&amp; srcFlag,
              Fields&amp; R,
              int intsharp)</span></span>
            </h3>
            <p>Compute boundary surface flux integrals for a given boundary type for FV.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>EOS material block</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>bcconfig&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>BC configuration vector for multiple side sets</td>
                </tr>
                <tr>
                  <td>fd&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face connectivity and boundary conditions object</td>
                </tr>
                <tr>
                  <td>geoFace&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face geometry array</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Physical time</td>
                </tr>
                <tr>
                  <td>flux&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Riemann flux function to use</td>
                </tr>
                <tr>
                  <td>vel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Function to use to query prescribed velocity (if any)</td>
                </tr>
                <tr>
                  <td>state&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Function to evaluate the left and right solution state at boundaries</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitives at recent time step</td>
                </tr>
                <tr>
                  <td>srcFlag&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Whether the energy source was added</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
                <tr>
                  <td>intsharp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface compression tag, an optional argument, with default 0, so that it is unused for single-material and transport.</td>
                </tr>
              </tbody>
            </table>
<p>Compute boundary surface flux integrals for a given boundary type for FV</p><p>This function computes contributions from surface integrals along all faces for a particular boundary condition type, configured by the state function</p>
          </div></section>
          <section class="m-dox-details" id="a2330cac84a48cb1ff2fb84d4f1ce68c0"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a2330cac84a48cb1ff2fb84d4f1ce68c0" class="m-dox-self">bndSurfIntViscousFV</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t rdof,
              const std::vector&lt;std::size_t&gt;&amp; bcconfig,
              const <a href="classinciter_1_1_face_data.html" class="m-dox">inciter::<wbr />FaceData</a>&amp; fd,
              const Fields&amp; geoFace,
              const Fields&amp; geoElem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const <a href="namespacetk.html#aea3cd7451f600631750f04f970ef6f6e" class="m-dox">StateFn</a>&amp; state,
              const <a href="namespacetk.html#aea3cd7451f600631750f04f970ef6f6e" class="m-dox">StateFn</a>&amp; gradFn,
              const Fields&amp; U,
              const Fields&amp; P,
              const Fields&amp; T,
              const std::vector&lt;int&gt;&amp; srcFlag,
              Fields&amp; R,
              int intsharp)</span></span>
            </h3>
            <p>Compute boundary surface flux integrals for a given boundary type for FV.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>EOS material block</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>bcconfig&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>BC configuration vector for multiple side sets</td>
                </tr>
                <tr>
                  <td>fd&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face connectivity and boundary conditions object</td>
                </tr>
                <tr>
                  <td>geoFace&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face geometry array</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Physical time</td>
                </tr>
                <tr>
                  <td>state&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Function to evaluate the left and right solution state at boundaries</td>
                </tr>
                <tr>
                  <td>gradFn&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Function to evaluate the left and right solution gradients at boundaries</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitives at recent time step</td>
                </tr>
                <tr>
                  <td>T&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of temperatures at recent time step</td>
                </tr>
                <tr>
                  <td>srcFlag&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Whether the energy source was added</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
                <tr>
                  <td>intsharp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface compression tag, an optional argument, with default 0, so that it is unused for single-material and transport.</td>
                </tr>
              </tbody>
            </table>
<p>Compute boundary surface flux integrals for a given boundary type for FV</p><p>This function computes contributions from surface integrals along all faces for a particular boundary condition type, configured by the state function</p>
          </div></section>
          <section class="m-dox-details" id="a5e437639bfcdd6b5d9edf23efe736afd"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a5e437639bfcdd6b5d9edf23efe736afd" class="m-dox-self">initialize</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const Fields&amp; L,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const <a href="namespacetk.html#af81ac0b2512a37ffcd2c86eda61ffb9e" class="m-dox">InitializeFn</a>&amp; solution,
              Fields&amp; unk,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const std::size_t nielem)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>mat_blk</td>
                  <td></td>
                </tr>
                <tr>
                  <td>L&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Block diagonal mass matrix</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of node coordinates</td>
                </tr>
                <tr>
                  <td>solution&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Function to call to evaluate known solution or initial conditions at x,y,z,t</td>
                </tr>
                <tr>
                  <td>unk&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Array of unknowns</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Physical time</td>
                </tr>
                <tr>
                  <td>nielem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of internal elements</td>
                </tr>
              </tbody>
            </table>
<p>Initalize a PDE system for DG by projecting the exact solution in the DG solution space</p><p>Initalize a system of DGPDEs by projecting the exact solution in the DG solution space</p><p>This is the public interface exposed to client code.</p>
          </div></section>
          <section class="m-dox-details" id="ad6bb09243695c7fdfaea6ae8d3e6484e"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ad6bb09243695c7fdfaea6ae8d3e6484e" class="m-dox-self">update_rhs</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; s,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; R)</span></span>
            </h3>
            <p>Update the rhs by adding the initial analytical solution term.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>wt&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Weight of gauss quadrature point</td>
                </tr>
                <tr>
                  <td>B&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of basis functions</td>
                </tr>
                <tr>
                  <td>s&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of analytical solution at quadrature point</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="aae6bd4333d13dfffd40cde738719b9ec"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aae6bd4333d13dfffd40cde738719b9ec" class="m-dox-self">eval_init</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::size_t e,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; R,
              const Fields&amp; L,
              Fields&amp; unk)</span></span>
            </h3>
            <p>Compute the initial conditions.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element index</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Right-hand side vector</td>
                </tr>
                <tr>
                  <td>L&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Block diagonal mass matrix</td>
                </tr>
                <tr>
                  <td>unk&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Array of unknowns</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="ae8a0facd864463216fe2b73eee8b02b5"><div>
            <h3>
              <div class="m-dox-template">
                template&lt;class eq&gt;
              </div>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae8a0facd864463216fe2b73eee8b02b5" class="m-dox-self">BoxElems</a>(</span><span class="m-dox-wrap">const tk::Fields&amp; geoElem,
              std::size_t nielem,
              std::vector&lt;std::unordered_set&lt;std::size_t&gt;&gt;&amp; inbox)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">eq</td>
                  <td>Equation type to operate on, e.g., tag::compflow, tag::multimat</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>nielem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of internal elements</td>
                </tr>
                <tr>
                  <td>inbox&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>List of nodes at which box user ICs are set for each IC box</td>
                </tr>
              </tbody>
            </table>
<p>Determine if elements lie inside user defined IC boxes</p>
          </div></section>
          <section class="m-dox-details" id="a0e1c25d76d7a0f5e791fb7ed1a70480c"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a0e1c25d76d7a0f5e791fb7ed1a70480c" class="m-dox-self">mass</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              <a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ndof,
              const Fields&amp; geoElem,
              Fields&amp; l)</span></span>
            </h3>
            <p>Compute the block-diagnoal mass matrix for DG.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of solution degrees of freedom</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>l&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Block diagonal mass matrix</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="aa030103c8628271f28b884a78fe1592d"><div>
            <h3>
              <span class="m-dox-wrap-bumper">tk::Fields tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa030103c8628271f28b884a78fe1592d" class="m-dox-self">lump</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; coord,
              const std::vector&lt;std::size_t&gt;&amp; inpoel)</span></span>
            </h3>
            <p>Compute lumped mass matrix for CG.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of scalar components in the eq system</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh node coordinates</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh element connectivity</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Lumped mass matrix</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a41aa06a834c1ec42178551ecc45445e0"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a41aa06a834c1ec42178551ecc45445e0" class="m-dox-self">massMatrixDubiner</a>(</span><span class="m-dox-wrap">std::size_t dof,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> vol)</span></span>
            </h3>
            <p>Compute the diagonal mass matrix for DG with Dubiner basis functions.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">dof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>vol&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Volume of element whose mass matrix is desired</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Diagonal of the mass matrix</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="aa210863fa60aeb1f1ca70797ec213179"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa210863fa60aeb1f1ca70797ec213179" class="m-dox-self">nonConservativeInt</a>(</span><span class="m-dox-wrap">const bool pref,
              std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::size_t nelem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannDeriv,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              Fields&amp; R,
              int intsharp)</span></span>
            </h3>
            <p>Compute volume integrals of non-conservative terms for multi-material DG.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">pref&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Indicator for p-adaptive algorithm</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>EOS material block</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>nelem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of elements</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitive quantities at recent time step</td>
                </tr>
                <tr>
                  <td>riemannDeriv&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Derivatives of partial-pressures and velocities computed from the Riemann solver for use in the non-conservative terms</td>
                </tr>
                <tr>
                  <td>ndofel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of local number of degrees of freedome</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector added to</td>
                </tr>
                <tr>
                  <td>intsharp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface reconstruction indicator</td>
                </tr>
              </tbody>
            </table>
<p>This is called for multi-material DG, computing volume integrals of terms in the volume fraction and energy equations, which do not exist in the single-material flow formulation (for <code>CompFlow</code> DG). For further details see Pelanti, M., &amp; Shyue, K. M. (2019). A numerical model for multiphase liquid–vapor–gas flows with interfaces and cavitation. International Journal of Multiphase Flow, 113, 208-230.</p>
          </div></section>
          <section class="m-dox-details" id="a840a0d1a42102ff7d58aa01e0398ca5f"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a840a0d1a42102ff7d58aa01e0398ca5f" class="m-dox-self">updateRhsNonCons</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t nmat,
              const std::size_t ndof,
              ] const std::size_t ndof_el,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::size_t e,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B,
              ] const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; dBdx,
              const std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; ncf,
              Fields&amp; R)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>ndof_el&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom for local element</td>
                </tr>
                <tr>
                  <td>wt&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Weight of gauss quadrature point</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element index</td>
                </tr>
                <tr>
                  <td>B&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Basis function evaluated at local quadrature point</td>
                </tr>
                <tr>
                  <td>dBdx&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of basis function derivatives</td>
                </tr>
                <tr>
                  <td>ncf&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of non-conservative terms</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="af3da9b77f4830ab02eea3bb29cf4208d"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af3da9b77f4830ab02eea3bb29cf4208d" class="m-dox-self">nonConservativeIntFV</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::size_t rdof,
              const std::size_t e,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; fn,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; var_riemann)</span></span>
            </h3>
            <p>Compute volume integrals of non-conservative terms for multi-material FV.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element for which contribution is to be calculated</td>
                </tr>
                <tr>
                  <td>fn&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face normal</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitive quantities at recent time step</td>
                </tr>
                <tr>
                  <td>var_riemann&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Riemann-values of partial-pressures and velocities computed from the Riemann solver for use in the non-conservative terms</td>
                </tr>
              </tbody>
            </table>
<p>This is called for multi-material FV, computing integrals of terms in the volume fraction and energy equations, which do not exist in the single-material flow formulation (for <code>CompFlow</code>). For further details see Pelanti, M., &amp; Shyue, K. M. (2019). A numerical model for multiphase liquid–vapor–gas flows with interfaces and cavitation. International Journal of Multiphase Flow, 113, 208-230.</p>
          </div></section>
          <section class="m-dox-details" id="ab908a31e5b594bc395420d89d4705312"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab908a31e5b594bc395420d89d4705312" class="m-dox-self">pressureRelaxationInt</a>(</span><span class="m-dox-wrap">const bool pref,
              std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::size_t nelem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> ct,
              Fields&amp; R,
              int intsharp)</span></span>
            </h3>
            <p>Compute volume integrals of pressure relaxation terms in multi-material DG.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">pref&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Indicator for p-adaptive algorithm</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>EOS material block</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>nelem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of elements</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitive quantities at recent time step</td>
                </tr>
                <tr>
                  <td>ndofel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of local number of degrees of freedome</td>
                </tr>
                <tr>
                  <td>ct&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pressure relaxation time-scale for this system</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector added to</td>
                </tr>
                <tr>
                  <td>intsharp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface reconstruction indicator</td>
                </tr>
              </tbody>
            </table>
<p>This is called for multi-material DG to compute volume integrals of finite pressure relaxation terms in the volume fraction and energy equations, which do not exist in the single-material flow formulation (for <code>CompFlow</code> DG). For further details see Dobrev, V. A., Kolev, T. V., Rieben, R. N., &amp; Tomov, V. Z. (2016). Multi‐material closure model for high‐order finite element Lagrangian hydrodynamics. International Journal for Numerical Methods in Fluids, 82(10), 689-706.</p>
          </div></section>
          <section class="m-dox-details" id="aad1a4bf50cd82a0249e72753d1beb5aa"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aad1a4bf50cd82a0249e72753d1beb5aa" class="m-dox-self">updateRhsPre</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              ] const std::size_t ndof_el,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::size_t e,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; ncf,
              Fields&amp; R)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>ndof_el&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom for local element</td>
                </tr>
                <tr>
                  <td>wt&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Weight of gauss quadrature point</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element index</td>
                </tr>
                <tr>
                  <td>B&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Basis function evaluated at local quadrature point</td>
                </tr>
                <tr>
                  <td>ncf&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of non-conservative terms</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a218c791cc73f982a80c04b99923b61f8"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a218c791cc73f982a80c04b99923b61f8" class="m-dox-self">pressureRelaxationIntFV</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t rdof,
              const std::size_t nelem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const Fields&amp; U,
              const Fields&amp; P,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> ct,
              Fields&amp; R)</span></span>
            </h3>
            <p>Compute volume integrals of pressure relaxation terms in multi-material FV.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>EOS material block</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>nelem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of elements</td>
                </tr>
                <tr>
                  <td>inpoel</td>
                  <td></td>
                </tr>
                <tr>
                  <td>coord</td>
                  <td></td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitive quantities at recent time step</td>
                </tr>
                <tr>
                  <td>ct&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Pressure relaxation time-scale for this system</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector added to</td>
                </tr>
              </tbody>
            </table>
<p>This is called for multi-material FV to compute volume integrals of finite pressure relaxation terms in the volume fraction and energy equations, which do not exist in the single-material flow formulation (for <code>CompFlow</code>). For further details see Dobrev, V. A., Kolev, T. V., Rieben, R. N., &amp; Tomov, V. Z. (2016). Multi‐material closure model for high‐order finite element Lagrangian hydrodynamics. International Journal for Numerical Methods in Fluids, 82(10), 689-706.</p>
          </div></section>
          <section class="m-dox-details" id="a0888955d3797d23fa3dd56876c12286c"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a0888955d3797d23fa3dd56876c12286c" class="m-dox-self">solvevriem</a>(</span><span class="m-dox-wrap">std::size_t nelem,
              const std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; vriem,
              const std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannLoc)</span></span>
            </h3>
            <p>Solve the reconstruct velocity used for volume fraction equation.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nelem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Numer of elements</td>
                </tr>
                <tr>
                  <td>vriem&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Vector of the riemann velocity</td>
                </tr>
                <tr>
                  <td>riemannLoc&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Vector of coordinates where Riemann velocity data is available</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Vector of Riemann velocity polynomial solution</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a7d5d3a55b5a44c20e94fd470383f807e"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a7d5d3a55b5a44c20e94fd470383f807e" class="m-dox-self">evaluRiemann</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const int e_left,
              const int e_right,
              const std::size_t nmat,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; fl,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; fn,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; gp,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 2&gt;&amp; state,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; vriem,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannLoc)</span></span>
            </h3>
            <p>Compute the riemann velociry at the interface.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>e_left&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Index for the left element</td>
                </tr>
                <tr>
                  <td>e_right&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Index for the right element</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>fl&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Surface flux</td>
                </tr>
                <tr>
                  <td>fn&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face/Surface normal</td>
                </tr>
                <tr>
                  <td>gp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Gauss points coordinates</td>
                </tr>
                <tr>
                  <td>state&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of state variables for left and right side</td>
                </tr>
                <tr>
                  <td>vriem&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Vector of the riemann velocity</td>
                </tr>
                <tr>
                  <td>riemannLoc&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Vector of coordinates where Riemann velocity data is available</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="ac5e880fa846ad14a270989bf6c40b6ca"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac5e880fa846ad14a270989bf6c40b6ca" class="m-dox-self">fluxTerms</a>(</span><span class="m-dox-wrap">std::size_t ncomp,
              std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp;,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; ugp)</span></span>
            </h3>
            <p>Compute the flux-function for the multimaterial PDEs.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of components in this PDE system</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>ugp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>State vector at the Gauss point at which flux is required</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Flux vectors for all components in multi-material PDE system</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a843d06b274313e564210eebe4ea2f90f"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a843d06b274313e564210eebe4ea2f90f" class="m-dox-self">NGvol</a>(</span><span class="m-dox-wrap">const std::size_t ndof) <span class="m-label m-primary">constexpr</span></span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
              </tbody>
            </table>
<p>Initialization of number of Gauss points for volume integration</p>
          </div></section>
          <section class="m-dox-details" id="a9eb1a7ff5bb94c367fbb50e4af142174"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a9eb1a7ff5bb94c367fbb50e4af142174" class="m-dox-self">NGfa</a>(</span><span class="m-dox-wrap">const std::size_t ndof) <span class="m-label m-primary">constexpr</span></span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
              </tbody>
            </table>
<p>Initialization of number of Gauss points for face integration</p>
          </div></section>
          <section class="m-dox-details" id="adabe655f67c84632f6883412875cf6af"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#adabe655f67c84632f6883412875cf6af" class="m-dox-self">NGdiag</a>(</span><span class="m-dox-wrap">const std::size_t ndof) <span class="m-label m-primary">constexpr</span></span></span>
            </h3>
            <p>Initialization of number of Gauss points for volume integration in error estimation.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="aa70f5775e02bd3a02ec039d85644337c"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::size_t tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aa70f5775e02bd3a02ec039d85644337c" class="m-dox-self">NGinit</a>(</span><span class="m-dox-wrap">const std::size_t ndof) <span class="m-label m-primary">constexpr</span></span></span>
            </h3>
            <p>Initialization of number of Gauss points for volume integration in DG initialization.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="aca6fb44879789ccaa13aedc3726b8105"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aca6fb44879789ccaa13aedc3726b8105" class="m-dox-self">GaussQuadratureTet</a>(</span><span class="m-dox-wrap">std::size_t NG,
              std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 3&gt;&amp; coordgp,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; wgp)</span></span>
            </h3>
            <p>Initialize Gaussian quadrature points locations and weights for a tetrahedron.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">NG&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>number of quadrature points</td>
                </tr>
                <tr>
                  <td>coordgp&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>3 spatial coordinates of quadrature points</td>
                </tr>
                <tr>
                  <td>wgp&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Weights of quadrature points</td>
                </tr>
              </tbody>
            </table>
<p>Initialize Gaussian quadrature points locations and weights for a tetrahedron</p>
          </div></section>
          <section class="m-dox-details" id="aacd73a16836192c36647a903548139b5"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#aacd73a16836192c36647a903548139b5" class="m-dox-self">GaussQuadratureTri</a>(</span><span class="m-dox-wrap">std::size_t NG,
              std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 2&gt;&amp; coordgp,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; wgp)</span></span>
            </h3>
            <p>Initialize Gaussian quadrature points locations and weights for a triangle.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">NG&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>number of quadrature points</td>
                </tr>
                <tr>
                  <td>coordgp&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>2 spatial coordinates of quadrature points</td>
                </tr>
                <tr>
                  <td>wgp&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Weights of quadrature points</td>
                </tr>
              </tbody>
            </table>
<p>Initialize Gaussian quadrature points locations and weights for a triangle</p>
          </div></section>
          <section class="m-dox-details" id="ac890f6a0863964d93c0961187f6b79af"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac890f6a0863964d93c0961187f6b79af" class="m-dox-self">solidTermsVolInt</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::size_t nelem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> dt,
              Fields&amp; R,
              int intsharp)</span></span>
            </h3>
            <p>Compute Solid Terms with volume integrals.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>EOS material block</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>nelem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of elements</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitives at recent time step</td>
                </tr>
                <tr>
                  <td>ndofel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of local number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>dt&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Delta time</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
                <tr>
                  <td>intsharp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface compression tag, an optional argument, with default 0, so that it is unused for single-material and transport.</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="acea01580b595b144a1e320f916d8fe14"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#acea01580b595b144a1e320f916d8fe14" class="m-dox-self">update_rhs</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::size_t ndof,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::size_t e,
              const std::size_t solidx,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; s,
              Fields&amp; R)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>ndof</td>
                  <td></td>
                </tr>
                <tr>
                  <td>wt&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Weight of gauss quadrature point</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element index</td>
                </tr>
                <tr>
                  <td>solidx&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Material index indicator</td>
                </tr>
                <tr>
                  <td>s&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Source term vector</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a6ce3351b679fc43d842fa90c6564a3d4"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a6ce3351b679fc43d842fa90c6564a3d4" class="m-dox-self">srcInt</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const std::size_t ndof,
              const std::size_t nelem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const <a href="namespacetk.html#a2cb83e9ba934b9ff1f9acc75c096e496" class="m-dox">SrcFn</a>&amp; src,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              Fields&amp; R,
              std::size_t nmat = 1)</span></span>
            </h3>
            <p>Compute source term integrals for DG.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Material block EOS</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Physical time</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>nelem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of elements</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>src&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Source function to use</td>
                </tr>
                <tr>
                  <td>ndofel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of local number of degrees of freedome</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials. A default is set to 1, so that calling code for single material systems primitive quantities does not need to specify this argument.</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a1a9be85b697a1036068e5d73c74b7e35"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a1a9be85b697a1036068e5d73c74b7e35" class="m-dox-self">update_rhs</a>(</span><span class="m-dox-wrap">const std::size_t ndof,
              const std::size_t ndof_el,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::size_t e,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; s,
              Fields&amp; R)</span></span>
            </h3>
            <p>Update the rhs by adding the source term integrals.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>ndof_el&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom for local element</td>
                </tr>
                <tr>
                  <td>wt&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Weight of gauss quadrature point</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element index</td>
                </tr>
                <tr>
                  <td>B&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of basis functions</td>
                </tr>
                <tr>
                  <td>s&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Source term vector</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a95996daa8d78162e4b44b81df971a7bb"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a95996daa8d78162e4b44b81df971a7bb" class="m-dox-self">srcIntFV</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const std::size_t nelem,
              const Fields&amp; geoElem,
              const <a href="namespacetk.html#a2cb83e9ba934b9ff1f9acc75c096e496" class="m-dox">SrcFn</a>&amp; src,
              Fields&amp; R,
              std::size_t nmat)</span></span>
            </h3>
            <p>Compute source term integrals for FV.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Material block EOS</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Physical time</td>
                </tr>
                <tr>
                  <td>nelem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of elements</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>src&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Source function to use</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials. A default is set to 1, so that calling code for single material systems primitive quantities does not need to specify this argument.</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a363af110ad72e8ef5ff5c17987fdf52e"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a363af110ad72e8ef5ff5c17987fdf52e" class="m-dox-self">surfInt</a>(</span><span class="m-dox-wrap">const bool pref,
              std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const std::vector&lt;std::size_t&gt;&amp;,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const <a href="classinciter_1_1_face_data.html" class="m-dox">inciter::<wbr />FaceData</a>&amp; fd,
              const Fields&amp; geoFace,
              const Fields&amp; geoElem,
              const <a href="namespacetk.html#ac36fb71a41ff5a1d9a41143652d61438" class="m-dox">RiemannFluxFn</a>&amp; flux,
              const <a href="namespacetk.html#ab96930c6425f28fde0af48eb346cc1ed" class="m-dox">VelFn</a>&amp; vel,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>,
              Fields&amp; R,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannDeriv,
              int intsharp)</span></span>
            </h3>
            <p>Compute internal surface flux integrals for DG.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">pref&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Indicator for p-adaptive algorithm</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>EOS material block</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Physical time</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>fd&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face connectivity and boundary conditions object</td>
                </tr>
                <tr>
                  <td>geoFace&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face geometry array</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>flux&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Riemann flux function to use</td>
                </tr>
                <tr>
                  <td>vel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Function to use to query prescribed velocity (if any)</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitives at recent time step</td>
                </tr>
                <tr>
                  <td>ndofel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of local number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
                <tr>
                  <td>riemannDeriv&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Derivatives of partial-pressures and velocities computed from the Riemann solver for use in the non-conservative terms. These derivatives are used only for multi-material hydro and unused for single-material compflow and linear transport.</td>
                </tr>
                <tr>
                  <td>intsharp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface compression tag, an optional argument, with default 0, so that it is unused for single-material and transport.</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="afffc8e3b481a3bcb24766e6941dbce24"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#afffc8e3b481a3bcb24766e6941dbce24" class="m-dox-self">update_rhs_fa</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              std::size_t nmat,
              const std::size_t ndof,
              const std::size_t ndof_l,
              const std::size_t ndof_r,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; fn,
              const std::size_t el,
              const std::size_t er,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; fl,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B_l,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&amp; B_r,
              Fields&amp; R,
              std::vector&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;&gt;&amp; riemannDeriv)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>ndof_l&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom for left element</td>
                </tr>
                <tr>
                  <td>ndof_r&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom for right element</td>
                </tr>
                <tr>
                  <td>wt&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Weight of gauss quadrature point</td>
                </tr>
                <tr>
                  <td>fn&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face/Surface normal</td>
                </tr>
                <tr>
                  <td>el&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Left element index</td>
                </tr>
                <tr>
                  <td>er&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Right element index</td>
                </tr>
                <tr>
                  <td>fl&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Surface flux</td>
                </tr>
                <tr>
                  <td>B_l&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Basis function for the left element</td>
                </tr>
                <tr>
                  <td>B_r&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Basis function for the right element</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
                <tr>
                  <td>riemannDeriv&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Derivatives of partial-pressures and velocities computed from the Riemann solver for use in the non-conservative terms. These derivatives are used only for multi-material hydro and unused for single-material compflow and linear transport.</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="ae94d519916ce36020b4bab7e4dd1acc0"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae94d519916ce36020b4bab7e4dd1acc0" class="m-dox-self">surfIntFV</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const std::size_t rdof,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const <a href="classinciter_1_1_face_data.html" class="m-dox">inciter::<wbr />FaceData</a>&amp; fd,
              const Fields&amp; geoFace,
              const Fields&amp; geoElem,
              const <a href="namespacetk.html#ac36fb71a41ff5a1d9a41143652d61438" class="m-dox">RiemannFluxFn</a>&amp; flux,
              const <a href="namespacetk.html#ab96930c6425f28fde0af48eb346cc1ed" class="m-dox">VelFn</a>&amp; vel,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;int&gt;&amp; srcFlag,
              Fields&amp; R,
              int intsharp)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>mat_blk</td>
                  <td></td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Physical time</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>fd&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face connectivity and boundary conditions object</td>
                </tr>
                <tr>
                  <td>geoFace&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face geometry array</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>flux&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Riemann flux function to use</td>
                </tr>
                <tr>
                  <td>vel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Function to use to query prescribed velocity (if any)</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitives at recent time step</td>
                </tr>
                <tr>
                  <td>srcFlag&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Whether the energy source was added</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
                <tr>
                  <td>intsharp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface compression tag, an optional argument, with default 0, so that it is unused for single-material and transport.</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="acf712f142d7648f0ce6fef3c19cdd2d4"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#acf712f142d7648f0ce6fef3c19cdd2d4" class="m-dox-self">surfIntViscousFV</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t rdof,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const <a href="classinciter_1_1_face_data.html" class="m-dox">inciter::<wbr />FaceData</a>&amp; fd,
              const Fields&amp; geoFace,
              const Fields&amp; geoElem,
              const Fields&amp; U,
              const Fields&amp; P,
              const Fields&amp; T,
              const std::vector&lt;int&gt;&amp; srcFlag,
              Fields&amp; R,
              int intsharp)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Material EOS block</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>fd&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face connectivity and boundary conditions object</td>
                </tr>
                <tr>
                  <td>geoFace&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face geometry array</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitives at recent time step</td>
                </tr>
                <tr>
                  <td>T&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of temperatures at recent time step</td>
                </tr>
                <tr>
                  <td>srcFlag&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Whether the energy source was added</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
                <tr>
                  <td>intsharp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface compression tag, an optional argument, with default 0, so that it is unused for single-material and transport.</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a8dd110ea94afea76ed15d89596b9251e"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a8dd110ea94afea76ed15d89596b9251e" class="m-dox-self">modifiedGradientViscousFlux</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              std::size_t ncomp,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&amp; fn,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;, 2&gt;&amp; centroids,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 2&gt;&amp; state,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 2&gt;&amp; cellAvgState,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 2&gt;&amp; cellAvgT,
              const std::array&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;, 3&gt; dudx,
              const std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&gt;&amp; dTdx)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials</td>
                </tr>
                <tr>
                  <td>ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of component equations in the PDE system</td>
                </tr>
                <tr>
                  <td>fn&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Face/Surface normal</td>
                </tr>
                <tr>
                  <td>centroids&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Left and right cell centroids</td>
                </tr>
                <tr>
                  <td>state&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Left and right unknown/state vector</td>
                </tr>
                <tr>
                  <td>cellAvgState&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Left and right cell-averaged unknown/state vector</td>
                </tr>
                <tr>
                  <td>cellAvgT&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Left and right cell-averaged temperature vector</td>
                </tr>
                <tr>
                  <td>dudx&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Average velocity gradient tensor</td>
                </tr>
                <tr>
                  <td>dTdx&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Average temperature gradient tensor</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Numerical viscous flux using the Modified Gradient approach.</td>
                </tr>
              </tfoot>
            </table>
<p>The average gradient is modified according to Weiss et al. to obtain a stable discretization (average results in unstable central central difference). Ref: Weiss, J. M., Maruszewski, J. P., &amp; Smith, W. A. (1999). Implicit solution of preconditioned Navier-Stokes equations using algebraic multigrid. AIAA journal, 37(1), 29-36.</p>
          </div></section>
          <section class="m-dox-details" id="a499b0b041aa0b276af0e2bb6873d7f66"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a499b0b041aa0b276af0e2bb6873d7f66" class="m-dox-self">volInt</a>(</span><span class="m-dox-wrap">std::size_t nmat,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> t,
              const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              const std::size_t ndof,
              const std::size_t rdof,
              const std::size_t nelem,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const <a href="namespacetk.html#ae5069d4cf4c8f3690d8f2ee0f0ada528" class="m-dox">FluxFn</a>&amp; flux,
              const <a href="namespacetk.html#ab96930c6425f28fde0af48eb346cc1ed" class="m-dox">VelFn</a>&amp; vel,
              const Fields&amp; U,
              const Fields&amp; P,
              const std::vector&lt;std::size_t&gt;&amp; ndofel,
              Fields&amp; R,
              int intsharp = 0)</span></span>
            </h3>
            <p>Compute volume integrals for DG.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Physical time</td>
                </tr>
                <tr>
                  <td>mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>EOS material block</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of degrees of freedom included reconstructed ones</td>
                </tr>
                <tr>
                  <td>nelem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of elements</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>flux&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Flux function to use</td>
                </tr>
                <tr>
                  <td>vel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Function to use to query prescribed velocity (if any)</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time step</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitives at recent time step</td>
                </tr>
                <tr>
                  <td>ndofel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of local number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector added to</td>
                </tr>
                <tr>
                  <td>intsharp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface compression tag, an optional argument, with default 0, so that it is unused for single-material and transport.</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="a880695db2108c697d970c8adf8f8212c"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a880695db2108c697d970c8adf8f8212c" class="m-dox-self">update_rhs</a>(</span><span class="m-dox-wrap"><a href="namespacetk.html#acdb0e09f7bd61edc926448eec770f176" class="m-dox">ncomp_<wbr />t</a> ncomp,
              const std::size_t ndof,
              const std::size_t ndof_el,
              const <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a> wt,
              const std::size_t e,
              const std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt;, 3&gt;&amp; dBdx,
              const std::vector&lt;std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>, 3&gt;&gt;&amp; fl,
              Fields&amp; R)</span></span>
            </h3>
            <p>Update the rhs by adding the source term integrals.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of scalar components in this PDE system</td>
                </tr>
                <tr>
                  <td>ndof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of degrees of freedom</td>
                </tr>
                <tr>
                  <td>ndof_el&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of degrees of freedom for local element</td>
                </tr>
                <tr>
                  <td>wt&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Weight of gauss quadrature point</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element index</td>
                </tr>
                <tr>
                  <td>dBdx&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of basis function derivatives</td>
                </tr>
                <tr>
                  <td>fl&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of numerical flux</td>
                </tr>
                <tr>
                  <td>R&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Right-hand side vector computed</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-dox-details" id="acb45afb1ba8be52d3e78def468b323d4"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#acb45afb1ba8be52d3e78def468b323d4" class="m-dox-self">recoLeastSqExtStencil</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t e,
              const std::map&lt;std::size_t, std::vector&lt;std::size_t&gt;&gt;&amp; esup,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const Fields&amp; geoElem,
              Fields&amp; W,
              const std::vector&lt;std::size_t&gt;&amp; varList)</span></span>
            </h3>
            <p>Reconstruct the second-order solution using least-squares approach from an extended stencil involving the node-neighbors.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Maximum number of reconstructed degrees of freedom</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element whoes solution is being reconstructed</td>
                </tr>
                <tr>
                  <td>esup&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Elements surrounding points</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>W&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Solution vector to be reconstructed at recent time step</td>
                </tr>
                <tr>
                  <td>varList&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>List of indices in W, that need to be reconstructed</td>
                </tr>
              </tbody>
            </table>
<p>A second-order (piecewise linear) solution polynomial is obtained from the first-order (piecewise constant) FV solutions by using a least-squares (LS) reconstruction process. This LS reconstruction function using the nodal-neighbors of a cell, to get an overdetermined system of equations for the derivatives of the solution. This overdetermined system is solved in the least-squares sense using the normal equations approach.</p>
          </div></section>
          <section class="m-dox-details" id="a80bfc61569a3b444de580d6bb4cb4b73"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a80bfc61569a3b444de580d6bb4cb4b73" class="m-dox-self">transform_P0P1</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              Fields&amp; W,
              const std::vector&lt;std::size_t&gt;&amp; varList)</span></span>
            </h3>
            <p>Transform the reconstructed P1-derivatives to the Dubiner dofs.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of reconstructed dofs</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element for which reconstruction is being calculated</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>W&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Second-order reconstructed vector which gets transformed to the Dubiner reference space</td>
                </tr>
                <tr>
                  <td>varList&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>List of indices in W, that need to be reconstructed</td>
                </tr>
              </tbody>
            </table>
<p>Since the DG solution (and the primitive quantities) are assumed to be stored in the Dubiner space, this transformation from Taylor coefficients to Dubiner coefficients is necessary.</p>
          </div></section>
          <section class="m-dox-details" id="a0deba99cc2316aa55db08d7eaffe3b05"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a0deba99cc2316aa55db08d7eaffe3b05" class="m-dox-self">THINCReco</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t nmat,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; ref_xp,
              const Fields&amp; U,
              const Fields&amp; P,
              bool intInd,
              const std::vector&lt;std::size_t&gt;&amp; matInt,
              ] const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; vfmin,
              ] const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; vfmax,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; state)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of reconstructed dofs</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of materials</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element for which interface reconstruction is being calculated</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>ref_xp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Quadrature point in reference space</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitives</td>
                </tr>
                <tr>
                  <td>intInd&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Boolean which indicates if the element contains a material interface</td>
                </tr>
                <tr>
                  <td>matInt&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array indicating which material has an interface</td>
                </tr>
                <tr>
                  <td>vfmin&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector containing min volume fractions for each material in this cell</td>
                </tr>
                <tr>
                  <td>vfmax&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector containing max volume fractions for each material in this cell</td>
                </tr>
                <tr>
                  <td>state&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Unknown/state vector at quadrature point, modified if near interfaces using THINC</td>
                </tr>
              </tbody>
            </table>
<p>This function is an interface for the multimat PDEs that use the algebraic multi-material THINC reconstruction. This particular function should only be called for multimat.</p>
          </div></section>
          <section class="m-dox-details" id="ae4b7fb2bec31f04ddabc239814c57523"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ae4b7fb2bec31f04ddabc239814c57523" class="m-dox-self">THINCRecoTransport</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; ref_xp,
              const Fields&amp; U,
              const Fields&amp;,
              ] const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; vfmin,
              ] const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; vfmax,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; state)</span></span>
            </h3>
            <p>Compute THINC reconstructions for linear advection (transport)</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of reconstructed dofs</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element for which interface reconstruction is being calculated</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>ref_xp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Quadrature point in reference space</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector</td>
                </tr>
                <tr>
                  <td>vfmin&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector containing min volume fractions for each material in this cell</td>
                </tr>
                <tr>
                  <td>vfmax&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector containing max volume fractions for each material in this cell</td>
                </tr>
                <tr>
                  <td>state&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Unknown/state vector at quadrature point, modified if near interfaces using THINC</td>
                </tr>
              </tbody>
            </table>
<p>This function is an interface for the transport PDEs that use the algebraic multi-material THINC reconstruction. This particular function should only be called for transport.</p>
          </div></section>
          <section class="m-dox-details" id="ab95e81d5ce7a25f8dabf6daf4b416c2b"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab95e81d5ce7a25f8dabf6daf4b416c2b" class="m-dox-self">THINCFunction</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t nmat,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; ref_xp,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> vol,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> bparam,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; alSol,
              bool intInd,
              const std::vector&lt;std::size_t&gt;&amp; matInt,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; alReco)</span></span>
            </h3>
            <p>Old THINC reconstruction function for volume fractions near interfaces.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of reconstructed dofs</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of materials</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element for which interface reconstruction is being calculated</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>ref_xp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Quadrature point in reference space</td>
                </tr>
                <tr>
                  <td>vol&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element volume</td>
                </tr>
                <tr>
                  <td>bparam&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>User specified Beta for THINC, from the input file</td>
                </tr>
                <tr>
                  <td>alSol&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Volume fraction solution vector for element e</td>
                </tr>
                <tr>
                  <td>intInd&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface indicator, true if e is interface element</td>
                </tr>
                <tr>
                  <td>matInt&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector indicating materials which constitute interface</td>
                </tr>
                <tr>
                  <td>alReco&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Unknown/state vector at quadrature point, which gets modified if near interface using MM-THINC</td>
                </tr>
              </tbody>
            </table>
<p>This function computes the interface reconstruction using the algebraic multi-material THINC reconstruction for each material at the given (ref_xp) quadrature point. This function is based on the following: Pandare A. K., Waltz J., &amp; Bakosi J. (2021) Multi-Material Hydrodynamics with Algebraic Sharp Interface Capturing. Computers &amp; Fluids, doi: <a href="https://doi.org/10.1016/j.compfluid.2020.104804">https:/<wbr />/<wbr />doi.org/<wbr />10.1016/<wbr />j.compfluid.2020.104804</a>. This function will be removed after the newer version (see THINCFunction_new) is sufficiently tested.</p>
          </div></section>
          <section class="m-dox-details" id="a25edfdeb9950dd5bafdb83c99ba2f652"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a25edfdeb9950dd5bafdb83c99ba2f652" class="m-dox-self">THINCFunction_new</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t nmat,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; ref_xp,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> vol,
              <a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a> bparam,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; alSol,
              bool intInd,
              const std::vector&lt;std::size_t&gt;&amp; matInt,
              std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; alReco)</span></span>
            </h3>
            <p>New THINC reconstruction function for volume fractions near interfaces.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of reconstructed dofs</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of materials</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element for which interface reconstruction is being calculated</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>ref_xp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Quadrature point in reference space</td>
                </tr>
                <tr>
                  <td>vol&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element volume</td>
                </tr>
                <tr>
                  <td>bparam&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>User specified Beta for THINC, from the input file</td>
                </tr>
                <tr>
                  <td>alSol&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Volume fraction solution vector for element e</td>
                </tr>
                <tr>
                  <td>intInd&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface indicator, true if e is interface element</td>
                </tr>
                <tr>
                  <td>matInt&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector indicating materials which constitute interface</td>
                </tr>
                <tr>
                  <td>alReco&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Unknown/state vector at quadrature point, which gets modified if near interface using MM-THINC</td>
                </tr>
              </tbody>
            </table>
<p>This function computes the interface reconstruction using the algebraic multi-material THINC reconstruction for each material at the given (ref_xp) quadrature point. This function succeeds the older version of the mm-THINC (see THINCFunction), but is still under testing and is currently experimental.</p>
          </div></section>
          <section class="m-dox-details" id="a3273188a20dab1aa8e45c75208b148c0"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a3273188a20dab1aa8e45c75208b148c0" class="m-dox-self">computeTemperaturesFV</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              std::size_t nmat,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">tk::<wbr />UnsMesh::<wbr />Coords</a>&amp; coord,
              const tk::Fields&amp; geoElem,
              const tk::Fields&amp; unk,
              const tk::Fields&amp; prim,
              const std::vector&lt;int&gt;&amp; srcFlag,
              tk::Fields&amp; T)</span></span>
            </h3>
            <p>Compute the temperatures based on FV conserved quantities.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>EOS material block</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of materials in this PDE system</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>unk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of conservative variables</td>
                </tr>
                <tr>
                  <td>prim&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of primitive variables</td>
                </tr>
                <tr>
                  <td>srcFlag&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Whether the energy source was added</td>
                </tr>
                <tr>
                  <td>T&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Array of material temperature dofs</td>
                </tr>
              </tbody>
            </table>
<p>This function computes the dofs of material temperatures based on conservative quantities from an FV scheme, using EOS calls. It uses the weak form m_{ij} T_i = \int T_{EOS}(rho, rhoE, u) B_j.</p>
          </div></section>
          <section class="m-dox-details" id="ac73cbceaded6427573280b5007a59e68"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac73cbceaded6427573280b5007a59e68" class="m-dox-self">evalPolynomialSol</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              int intsharp,
              std::size_t ncomp,
              std::size_t nprim,
              std::size_t rdof,
              std::size_t nmat,
              std::size_t e,
              std::size_t dof_e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; ref_gp,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; B,
              const Fields&amp; U,
              const Fields&amp; P)</span></span>
            </h3>
            <p>Evaluate polynomial solution at quadrature point.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>EOS material block</td>
                </tr>
                <tr>
                  <td>intsharp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface reconstruction indicator</td>
                </tr>
                <tr>
                  <td>ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of components in the PDE system</td>
                </tr>
                <tr>
                  <td>nprim&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of primitive quantities</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of reconstructed dofs</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of materials</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element for which polynomial solution is being evaluated</td>
                </tr>
                <tr>
                  <td>dof_e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Degrees of freedom for element</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>ref_gp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Quadrature point in reference space</td>
                </tr>
                <tr>
                  <td>B&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Basis function at given quadrature point</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitives</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>High-order unknown/state vector at quadrature point, modified if near interfaces using THINC</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="afd24a15bdc96fbe72fdb63e2e236f90e"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">tk::<wbr />real</a>&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#afd24a15bdc96fbe72fdb63e2e236f90e" class="m-dox-self">evalFVSol</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classinciter_1_1_e_o_s.html" class="m-dox">inciter::<wbr />EOS</a>&gt;&amp; mat_blk,
              int intsharp,
              std::size_t ncomp,
              std::size_t nprim,
              std::size_t rdof,
              std::size_t nmat,
              std::size_t e,
              const std::vector&lt;std::size_t&gt;&amp; inpoel,
              const <a href="classtk_1_1_uns_mesh.html#a2ed8d512b099636a98ba6b35b1118d6f" class="m-dox">UnsMesh::<wbr />Coords</a>&amp; coord,
              const Fields&amp; geoElem,
              const std::array&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>, 3&gt;&amp; ref_gp,
              const std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;&amp; B,
              const Fields&amp; U,
              const Fields&amp; P,
              int srcFlag)</span></span>
            </h3>
            <p>Evaluate second-order FV solution at quadrature point.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">mat_blk&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>EOS material block</td>
                </tr>
                <tr>
                  <td>intsharp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Interface reconstruction indicator</td>
                </tr>
                <tr>
                  <td>ncomp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of components in the PDE system</td>
                </tr>
                <tr>
                  <td>nprim&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of primitive quantities</td>
                </tr>
                <tr>
                  <td>rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of reconstructed dofs</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of materials</td>
                </tr>
                <tr>
                  <td>e&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element for which polynomial solution is being evaluated</td>
                </tr>
                <tr>
                  <td>inpoel&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element-node connectivity</td>
                </tr>
                <tr>
                  <td>coord&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Array of nodal coordinates</td>
                </tr>
                <tr>
                  <td>geoElem&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element geometry array</td>
                </tr>
                <tr>
                  <td>ref_gp&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Quadrature point in reference space</td>
                </tr>
                <tr>
                  <td>B&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Basis function at given quadrature point</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector</td>
                </tr>
                <tr>
                  <td>P&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of primitives</td>
                </tr>
                <tr>
                  <td>srcFlag&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Whether the energy source was added to element e</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>High-order unknown/state vector at quadrature point, modified if near interfaces using THINC</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="af11e7c9285b2517cda0e2f19b9e14476"><div>
            <h3>
              <span class="m-dox-wrap-bumper">void tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#af11e7c9285b2517cda0e2f19b9e14476" class="m-dox-self">safeReco</a>(</span><span class="m-dox-wrap">std::size_t rdof,
              std::size_t nmat,
              std::size_t el,
              int er,
              const Fields&amp; U,
              std::array&lt;std::vector&lt;<a href="namespacetk.html#a1a96ada94b7e2911ecca0a360f305575" class="m-dox">real</a>&gt;, 2&gt;&amp; state)</span></span>
            </h3>
            <p>Compute safe reconstructions near material interfaces.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">rdof&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of reconstructed dofs</td>
                </tr>
                <tr>
                  <td>nmat&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Total number of material is PDE system</td>
                </tr>
                <tr>
                  <td>el&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element on the left-side of face</td>
                </tr>
                <tr>
                  <td>er&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Element on the right-side of face</td>
                </tr>
                <tr>
                  <td>U&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Solution vector at recent time-stage</td>
                </tr>
                <tr>
                  <td>state&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Second-order reconstructed state, at cell-face, that is being modified for safety</td>
                </tr>
              </tbody>
            </table>
<p>When the consistent limiting is applied, there is a possibility that the material densities and energies violate TVD bounds. This function enforces the TVD bounds locally</p>
          </div></section>
          <section class="m-dox-details" id="a9911fa67ba7f72d5376474bc17869a0b"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a9911fa67ba7f72d5376474bc17869a0b" class="m-dox-self">serialize</a>(</span><span class="m-dox-wrap">std::size_t meshid,
              const std::vector&lt;<a href="classtk_1_1_uni_p_d_f.html" class="m-dox">tk::<wbr />UniPDF</a>&gt;&amp; u)</span></span>
            </h3>
            <p>Serialize univariate PDF to raw memory stream.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">meshid&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Mesh ID</td>
                </tr>
                <tr>
                  <td>u&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Univariate PDFs</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Pair of the length and the raw stream containing the serialized PDFs</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a24204b4ddfb41147330f02a8e6e7b760"><div>
            <h3>
              <span class="m-dox-wrap-bumper">CkReductionMsg* tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a24204b4ddfb41147330f02a8e6e7b760" class="m-dox-self">mergeUniPDFs</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs)</span></span>
            </h3>
            <p>Charm++ custom reducer for merging a univariate PDF during reduction across PEs.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmsg&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of messages in msgs</td>
                </tr>
                <tr>
                  <td>msgs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Charm++ reduction message containing the serialized PDF</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Aggregated PDF built for further aggregation if needed</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="a95434266ed0be6503251e90e0fe60823"><div>
            <h3>
              <span class="m-dox-wrap-bumper">std::pair&lt;int, std::unique_ptr&lt;char[]&gt;&gt; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#a95434266ed0be6503251e90e0fe60823" class="m-dox-self">serialize</a>(</span><span class="m-dox-wrap">const std::vector&lt;<a href="classtk_1_1_uni_p_d_f.html" class="m-dox">tk::<wbr />UniPDF</a>&gt;&amp; u,
              const std::vector&lt;<a href="classtk_1_1_bi_p_d_f.html" class="m-dox">tk::<wbr />BiPDF</a>&gt;&amp; b,
              const std::vector&lt;<a href="classtk_1_1_tri_p_d_f.html" class="m-dox">tk::<wbr />TriPDF</a>&gt;&amp; t)</span></span>
            </h3>
            <p>Serialize vectors of PDFs to raw memory stream.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">u&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of univariate PDFs</td>
                </tr>
                <tr>
                  <td>b&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of bivariate PDFs</td>
                </tr>
                <tr>
                  <td>t&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Vector of trivariate PDFs</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Pair of the length and the raw stream containing the serialized PDFs</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ab8753a2df233c9b1327d5682940ddcbf"><div>
            <h3>
              <span class="m-dox-wrap-bumper">CkReductionMsg* tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ab8753a2df233c9b1327d5682940ddcbf" class="m-dox-self">mergePDF</a>(</span><span class="m-dox-wrap">int nmsg,
              CkReductionMsg** msgs)</span></span>
            </h3>
            <p>Charm++ custom reducer for merging PDFs during reduction across PEs.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">nmsg&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Number of messages in msgs</td>
                </tr>
                <tr>
                  <td>msgs&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>Charm++ reduction message containing the serialized PDFs</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Aggregated PDFs built for further aggregation if needed</td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-dox-details" id="ac0a63cccd84b6bd8b998cb4282adac23"><div>
            <h3>
              <span class="m-dox-wrap-bumper">static std::ostream&amp; tk::<wbr /></span><span class="m-dox-wrap"><span class="m-dox-wrap-bumper"><a href="#ac0a63cccd84b6bd8b998cb4282adac23" class="m-dox-self">operator&lt;&lt;</a>(</span><span class="m-dox-wrap">std::ostream&amp; os,
              const <a href="classtk_1_1_uni_p_d_f.html" class="m-dox">tk::<wbr />UniPDF</a>&amp; p)</span></span>
            </h3>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">os&nbsp;<span class="m-label m-flat m-danger">in/out</span></td>
                  <td>Stream to output to</td>
                </tr>
                <tr>
                  <td>p&nbsp;<span class="m-label m-flat m-info">in</span></td>
                  <td>PDF to output</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>Updated stream</td>
                </tr>
              </tfoot>
            </table>
<p>Output univariate PDF to output stream</p><aside class="m-note m-info"><h4>Note</h4><p>Used for debugging.</p></aside>
          </div></section>
        </section>
        <section>
          <h2>Variable documentation</h2>
          <section class="m-dox-details" id="afc6a4dbf99954fbde58f895283a8de43"><div>
            <h3>
              const std::array&lt;std::size_t, 2&gt; tk::<wbr /><a href="#afc6a4dbf99954fbde58f895283a8de43" class="m-dox-self">ExoNnpe</a>
            </h3>
<p>ExodusII mesh cell number of nodes</p><p>List of number of nodes per element for different element types supported in the order of <a href="namespacetk.html#a3781b50ef71ead8dd0bd286455c6030c" class="m-dox">tk::<wbr />ExoElemType</a></p>
          </div></section>
          <section class="m-dox-details" id="a9445a95368496196e7c7560eccadbb09"><div>
            <h3>
              const std::array&lt;std::array&lt;std::size_t, 3&gt;, 4&gt; tk::<wbr /><a href="#a9445a95368496196e7c7560eccadbb09" class="m-dox-self">expofa</a>
            </h3>
<p>ExodusII face-node numbering for tetrahedron side sets</p><aside class="m-note m-default"><h4>See also</h4><p>ExodusII manual figure on &quot;Sideset side Numbering&quot;</p></aside>
          </div></section>
          <section class="m-dox-details" id="a6ad0280af8cd383252a1b894ac9b3c96"><div>
            <h3>
              const std::array&lt;<a href="classtk_1_1_uns_mesh.html#ae8262763c870433021affc6bb5a0f804" class="m-dox">UnsMesh::<wbr />Face</a>, 4&gt; tk::<wbr /><a href="#a6ad0280af8cd383252a1b894ac9b3c96" class="m-dox-self">lpofa</a>
            </h3>
<p>Const array defining the node ordering convention for tetrahedron faces</p><p>This two-dimensional array stores the naming/ordering convention of the node indices of a tetrahedron (tet) element. The dimensions are 4x3 as a tetrahedron has a total of 4 nodes and each (triangle) face has 3 nodes. Thus the array below associates tet node 0 with nodes {1,2,3}, tet node 1 with {2,0,3}, tet node 2 with {3,0,1}, and tet node 3 with {0,2,1}. Note that not only these mappings are important, but also the order of the nodes within the triplets as this specific order also defines the outwards normal of each face.</p>
          </div></section>
          <section class="m-dox-details" id="a07af9a3d86b90e1861bd16ded6a6ae87"><div>
            <h3>
              static highwayhash::HH_U64 tk::<wbr /><a href="#a07af9a3d86b90e1861bd16ded6a6ae87" class="m-dox-self">hh_key</a> <span class="m-label m-primary">constexpr</span>
            </h3>
<p>Highway hash &quot;secret&quot; key</p><aside class="m-note m-info"><h4>Note</h4><p>No reason for these particular numbers, taken from highwayhash tests.</p></aside>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-dox-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-dox-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-dox-search-content">
          <input type="search" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" />
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript. Enable it or <a href="https://google.com/search?q=site:quinoacomputing.github.io+">use an external search engine</a>.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            Search for symbols, directories, files, pages or modules. You can omit any
            prefix from the symbol or file path; adding a <code>:</code> or <code>/</code>
            suffix lists all members of given symbol or directory. Navigate through the
            list using <span class="m-label m-dim">&darr;</span> and
            <span class="m-label m-dim">&uarr;</span>, press
            <span class="m-label m-dim">Enter</span> to go.
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.<br />Maybe try a full-text <a href="#" id="search-external" data-search-engine="https://google.com/search?q=site:quinoacomputing.github.io+{query}">search with external engine</a>?</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search.js"></script>
<script src="searchdata.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Quinoa docs, part of the <a href="https://github.com/quinoacomputing/">Quinoa project</a>. Copyright © J. Bakosi 2012&ndash;2015, Los Alamos National Security, LLC, 2016&ndash;2018, <a href="https://www.triadns.org/">Triad National Security, LLC,</a> 2019-2024. Generated on Thursday, Feb 13, 2025 using <a href="http://doxygen.org/">Doxygen</a> and <a href="http://mcss.mosra.cz/">m.css</a>. Contact us via <a href="https://github.com/quinoacomputing/quinoa/issues">GitHub</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>