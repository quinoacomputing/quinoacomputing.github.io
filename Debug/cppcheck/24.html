
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cppcheck - HTML report - [<a href=https://github.com/quinoacomputing/quinoa/commit/-128-NOTFOUND>-128-NOTFOUND</a>]</title>
    <link rel="stylesheet" href="style.css">
    <style>
pre { line-height: 125%; margin: 0; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .ch { color: #888888 } /* Comment.Hashbang */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .cpf { color: #888888 } /* Comment.PreprocFile */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { background-color: #fff0f0 } /* Literal.String.Affix */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .vm { color: #996633 } /* Name.Variable.Magic */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
    </style>
    <script>
      function getStyle(el, styleProp) {
        var y;

        if (el.currentStyle) {
          y = el.currentStyle[styleProp];
        } else if (window.getComputedStyle) {
          y = document.defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);
        }

        return y;
      }

      function toggle() {
        var el = this.expandable_content;
        var mark = this.expandable_marker;

        if (el.style.display === "block") {
          el.style.display = "none";
          mark.textContent = "[+]";
        } else {
          el.style.display = "block";
          mark.textContent = "[-]";
        }
      }

      function initExpandables() {
        var elements = document.querySelectorAll(".expandable");

        for (var i = 0, len = elements.length; i < len; i++) {
          var el = elements[i];
          var clickable = el.querySelector("span");
          var marker = clickable.querySelector(".marker");
          var content = el.querySelector(".content");
          var width = clickable.clientWidth - parseInt(getStyle(content, "padding-left")) - parseInt(getStyle(content, "padding-right"));
          content.style.width = width + "px";
          clickable.expandable_content = content;
          clickable.expandable_marker = marker;
          clickable.addEventListener("click", toggle);
        }
      }

      function toggleDisplay(id) {
        var elements = document.querySelectorAll("." + id);

        for (var i = 0, len = elements.length; i < len; i++) {
          elements[i].classList.toggle("d-none");
        }
      }

      function toggleAll() {
        var elements = document.querySelectorAll("input");

        // starting from 1 since 0 is the "toggle all" input
        for (var i = 1, len = elements.length; i < len; i++) {
          var el = elements[i];

          if (el.checked) {
            el.checked = false;
          } else {
            el.checked = true;
          }

          toggleDisplay(el.id);
        }
      }
      window.addEventListener("load", initExpandables);
    </script>
  </head>
  <body>
    <div id="header" class="header">
      <h1>Cppcheck report - [<a href=https://github.com/quinoacomputing/quinoa/commit/-128-NOTFOUND>-128-NOTFOUND</a>]: /tmp/TeamCity-3/work/5ad443c8abe7fc0a/src/Mesh/Reorder.cpp</h1>
    </div>
    <div class="wrapper">
      <div id="menu">
       <p id="filename"><a href="index.html">Defects:</a> Reorder.cpp</p>
<a href="24.html#line-157"> useStlAlgorithm 157</a>
    </div>
    <div id="content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376</pre></div></td><td class="code"><div class="highlight"><pre><span></span><a name="line-1"></a><span class="c1">// *****************************************************************************</span>
<a name="line-2"></a><span class="cm">/*!</span>
<a name="line-3"></a><span class="cm">  \file      src/Mesh/Reorder.cpp</span>
<a name="line-4"></a><span class="cm">  \copyright 2012-2015 J. Bakosi,</span>
<a name="line-5"></a><span class="cm">             2016-2018 Los Alamos National Security, LLC.,</span>
<a name="line-6"></a><span class="cm">             2019-2021 Triad National Security, LLC.</span>
<a name="line-7"></a><span class="cm">             All rights reserved. See the LICENSE file for details.</span>
<a name="line-8"></a><span class="cm">  \brief     Mesh reordering routines for unstructured meshes</span>
<a name="line-9"></a><span class="cm">  \details   Mesh reordering routines for unstructured meshes.</span>
<a name="line-10"></a><span class="cm">*/</span>
<a name="line-11"></a><span class="c1">// *****************************************************************************</span>
<a name="line-12"></a>
<a name="line-13"></a><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<a name="line-14"></a><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<a name="line-15"></a><span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<a name="line-16"></a><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<a name="line-17"></a><span class="cp">#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp"></span>
<a name="line-18"></a><span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp"></span>
<a name="line-19"></a>
<a name="line-20"></a><span class="cp">#include</span> <span class="cpf">&quot;Reorder.hpp&quot;</span><span class="cp"></span>
<a name="line-21"></a><span class="cp">#include</span> <span class="cpf">&quot;Exception.hpp&quot;</span><span class="cp"></span>
<a name="line-22"></a><span class="cp">#include</span> <span class="cpf">&quot;ContainerUtil.hpp&quot;</span><span class="cp"></span>
<a name="line-23"></a><span class="cp">#include</span> <span class="cpf">&quot;Vector.hpp&quot;</span><span class="cp"></span>
<a name="line-24"></a>
<a name="line-25"></a><span class="k">namespace</span> <span class="n">tk</span> <span class="p">{</span>
<a name="line-26"></a>
<a name="line-27"></a><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span>
<a name="line-28"></a><span class="n">shiftToZero</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">inpoel</span> <span class="p">)</span>
<a name="line-29"></a><span class="c1">// *****************************************************************************</span>
<a name="line-30"></a><span class="c1">//  Shift node IDs to start with zero in element connectivity</span>
<a name="line-31"></a><span class="c1">//! \param[inout] inpoel Inteconnectivity of points and elements</span>
<a name="line-32"></a><span class="c1">//! \return Amount shifted</span>
<a name="line-33"></a><span class="c1">//! \details This function implements a simple reordering of the node ids of the</span>
<a name="line-34"></a><span class="c1">//!   element connectivity in inpoel by shifting the node ids so that the</span>
<a name="line-35"></a><span class="c1">//!   smallest is zero.</span>
<a name="line-36"></a><span class="c1">//! \note It is okay to call this function with an empty container; it will</span>
<a name="line-37"></a><span class="c1">//!    simply return without throwing an exception.</span>
<a name="line-38"></a><span class="c1">// *****************************************************************************</span>
<a name="line-39"></a><span class="p">{</span>
<a name="line-40"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">inpoel</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-41"></a>
<a name="line-42"></a>  <span class="c1">// find smallest node id</span>
<a name="line-43"></a>  <span class="k">auto</span> <span class="n">minId</span> <span class="o">=</span> <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">min_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">);</span>
<a name="line-44"></a>
<a name="line-45"></a>  <span class="c1">// shift node ids to start from zero</span>
<a name="line-46"></a>  <span class="c1">// cppcheck-suppress useStlAlgorithm</span>
<a name="line-47"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">inpoel</span><span class="p">)</span> <span class="n">n</span> <span class="o">-=</span> <span class="n">minId</span><span class="p">;</span>
<a name="line-48"></a>
<a name="line-49"></a>  <span class="k">return</span> <span class="n">minId</span><span class="p">;</span>
<a name="line-50"></a><span class="p">}</span>
<a name="line-51"></a>
<a name="line-52"></a><span class="kt">void</span>
<a name="line-53"></a><span class="n">remap</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">ids</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">map</span> <span class="p">)</span>
<a name="line-54"></a><span class="c1">// *****************************************************************************</span>
<a name="line-55"></a><span class="c1">//  Apply new maping to vector of indices</span>
<a name="line-56"></a><span class="c1">//! \param[inout] ids Vector of integer IDs to remap</span>
<a name="line-57"></a><span class="c1">//! \param[in] map Array of indices creating a new order</span>
<a name="line-58"></a><span class="c1">//! \details This function applies a mapping (reordering) to the integer IDs</span>
<a name="line-59"></a><span class="c1">//!   passed in using the map passed in. The mapping is expressed between the</span>
<a name="line-60"></a><span class="c1">//!   array index and its value. The function overwrites every value, i, of</span>
<a name="line-61"></a><span class="c1">//!   vector ids with map[i].</span>
<a name="line-62"></a><span class="c1">//! \note The sizes of ids and map need not equal. Only the maximum index in ids</span>
<a name="line-63"></a><span class="c1">//!   must be lower than the size of map.</span>
<a name="line-64"></a><span class="c1">//! \note It is okay to call this function with either of the containers empty;</span>
<a name="line-65"></a><span class="c1">//!   it will simply return without throwing an exception.</span>
<a name="line-66"></a><span class="c1">// *****************************************************************************</span>
<a name="line-67"></a><span class="p">{</span>
<a name="line-68"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">ids</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">map</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>
<a name="line-69"></a>
<a name="line-70"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">max_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="n">map</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
<a name="line-71"></a>          <span class="s">&quot;Indexing out of bounds&quot;</span> <span class="p">);</span>
<a name="line-72"></a>
<a name="line-73"></a>  <span class="c1">// remap integer IDs in vector ids</span>
<a name="line-74"></a>  <span class="c1">// cppcheck-suppress useStlAlgorithm</span>
<a name="line-75"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">ids</span><span class="p">)</span> <span class="n">i</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<a name="line-76"></a><span class="p">}</span>
<a name="line-77"></a>
<a name="line-78"></a><span class="kt">void</span>
<a name="line-79"></a><span class="n">remap</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span> <span class="o">&gt;&amp;</span> <span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">map</span> <span class="p">)</span>
<a name="line-80"></a><span class="c1">// *****************************************************************************</span>
<a name="line-81"></a><span class="c1">//  Apply new maping to vector of real numbers</span>
<a name="line-82"></a><span class="c1">//! \param[inout] r Vector of real numbers to remap</span>
<a name="line-83"></a><span class="c1">//! \param[in] map Array of indices creating a new order</span>
<a name="line-84"></a><span class="c1">//! \details This function applies a mapping (reordering) to the real values</span>
<a name="line-85"></a><span class="c1">//!   passed in using the map passed in. The mapping is expressed between the</span>
<a name="line-86"></a><span class="c1">//!   array index and its value. The function moves every value r[i] to</span>
<a name="line-87"></a><span class="c1">//!   r[ map[i] ].</span>
<a name="line-88"></a><span class="c1">//! \note The sizes of r and map must be equal and the maximum index in map must</span>
<a name="line-89"></a><span class="c1">//!   be lower than the size of map.</span>
<a name="line-90"></a><span class="c1">//! \note It is okay to call this function with either of the containers empty;</span>
<a name="line-91"></a><span class="c1">//!   it will simply return without throwing an exception.</span>
<a name="line-92"></a><span class="c1">// *****************************************************************************</span>
<a name="line-93"></a><span class="p">{</span>
<a name="line-94"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">map</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>
<a name="line-95"></a>
<a name="line-96"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">r</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">map</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;Size mismatch&quot;</span> <span class="p">);</span>
<a name="line-97"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">max_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">map</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="n">map</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
<a name="line-98"></a>          <span class="s">&quot;Indexing out of bounds&quot;</span> <span class="p">);</span>
<a name="line-99"></a>
<a name="line-100"></a>  <span class="c1">// remap real numbers in vector</span>
<a name="line-101"></a>  <span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
<a name="line-102"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">map</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">r</span><span class="p">[</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span> <span class="n">i</span> <span class="p">];</span>
<a name="line-103"></a><span class="p">}</span>
<a name="line-104"></a>
<a name="line-105"></a><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span>
<a name="line-106"></a><span class="n">remap</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">ids</span><span class="p">,</span>
<a name="line-107"></a>       <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">map</span> <span class="p">)</span>
<a name="line-108"></a><span class="c1">// *****************************************************************************</span>
<a name="line-109"></a><span class="c1">//  Create remapped vector of indices using a vector</span>
<a name="line-110"></a><span class="c1">//! \param[in] ids Vector of integer IDs to remap</span>
<a name="line-111"></a><span class="c1">//! \param[in] map Array of indices creating a new order</span>
<a name="line-112"></a><span class="c1">//! \return Remapped vector of ids</span>
<a name="line-113"></a><span class="c1">//! \details This function applies a mapping (reordering) to the integer IDs</span>
<a name="line-114"></a><span class="c1">//!   passed in using the map passed in. The mapping is expressed between the</span>
<a name="line-115"></a><span class="c1">//!   array index and its value. The function creates and returns a new container</span>
<a name="line-116"></a><span class="c1">//!   with remapped ids of identical size of the origin ids container.</span>
<a name="line-117"></a><span class="c1">//! \note The sizes of ids and map must be equal and the maximum index in map</span>
<a name="line-118"></a><span class="c1">//!   must be lower than the size of map.</span>
<a name="line-119"></a><span class="c1">//! \note It is okay to call this function with either of the containers empty;</span>
<a name="line-120"></a><span class="c1">//!   if ids is empty, it returns an empty container; if map is empty, it will</span>
<a name="line-121"></a><span class="c1">//!   return the original container.</span>
<a name="line-122"></a><span class="c1">// *****************************************************************************</span>
<a name="line-123"></a><span class="p">{</span>
<a name="line-124"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">ids</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="p">{};</span>
<a name="line-125"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="n">ids</span><span class="p">;</span>
<a name="line-126"></a>
<a name="line-127"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">max_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="n">map</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
<a name="line-128"></a>          <span class="s">&quot;Indexing out of bounds&quot;</span> <span class="p">);</span>
<a name="line-129"></a>
<a name="line-130"></a>  <span class="c1">// in terms of the in-place remap of a vector usinga vector</span>
<a name="line-131"></a>  <span class="k">auto</span> <span class="n">newids</span> <span class="o">=</span> <span class="n">ids</span><span class="p">;</span>
<a name="line-132"></a>  <span class="n">remap</span><span class="p">(</span> <span class="n">newids</span><span class="p">,</span> <span class="n">map</span> <span class="p">);</span>
<a name="line-133"></a>
<a name="line-134"></a>  <span class="k">return</span> <span class="n">newids</span><span class="p">;</span>
<a name="line-135"></a><span class="p">}</span>
<a name="line-136"></a>
<a name="line-137"></a><span class="kt">void</span>
<a name="line-138"></a><span class="n">remap</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">ids</span><span class="p">,</span>
<a name="line-139"></a>       <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">map</span> <span class="p">)</span>
<a name="line-140"></a><span class="c1">// *****************************************************************************</span>
<a name="line-141"></a><span class="c1">//  In-place remap vector of indices using a map</span>
<a name="line-142"></a><span class="c1">//! \param[in] ids Vector of integer IDs to remap</span>
<a name="line-143"></a><span class="c1">//! \param[in] map Hash-map of key-&gt;value creating a new order</span>
<a name="line-144"></a><span class="c1">//! \details This function applies a mapping (reordering) to the integer IDs</span>
<a name="line-145"></a><span class="c1">//!   passed in using the map passed in. The mapping is expressed as a hash-map</span>
<a name="line-146"></a><span class="c1">//!   of key-&gt;value pairs, where the key is the original and the value is the</span>
<a name="line-147"></a><span class="c1">//!   new ids of the mapping. The function overwrites the ids container with the</span>
<a name="line-148"></a><span class="c1">//!   remapped ids of identical size.</span>
<a name="line-149"></a><span class="c1">//! \note All ids in the input ids container must have a key in the map.</span>
<a name="line-150"></a><span class="c1">//!   Otherwise an exception is thrown.</span>
<a name="line-151"></a><span class="c1">//! \note It is okay to call this function with the ids container empty but not</span>
<a name="line-152"></a><span class="c1">//!   okay to pass an empty map.</span>
<a name="line-153"></a><span class="c1">// *****************************************************************************</span>
<a name="line-154"></a><span class="p">{</span>
<a name="line-155"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">map</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Map must not be empty&quot;</span> <span class="p">);</span>
<a name="line-156"></a>
<a name="line-157"></a><span class="hll">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">ids</span><span class="p">)</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span> <span class="n">map</span><span class="p">,</span> <span class="n">i</span> <span class="p">);</span><span class="error2">&lt;--- Consider using std::transform algorithm instead of a raw loop.</span>
</span><a name="line-158"></a><span class="p">}</span>
<a name="line-159"></a>
<a name="line-160"></a><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span>
<a name="line-161"></a><span class="n">remap</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">ids</span><span class="p">,</span>
<a name="line-162"></a>       <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">map</span> <span class="p">)</span>
<a name="line-163"></a><span class="c1">// *****************************************************************************</span>
<a name="line-164"></a><span class="c1">//  Create remapped vector of indices using a map</span>
<a name="line-165"></a><span class="c1">//! \param[in] ids Vector of integer IDs to create new container of ids from</span>
<a name="line-166"></a><span class="c1">//! \param[in] map Hash-map of key-&gt;value creating a new order</span>
<a name="line-167"></a><span class="c1">//! \return Remapped vector of ids</span>
<a name="line-168"></a><span class="c1">//! \details This function applies a mapping (reordering) to the integer IDs</span>
<a name="line-169"></a><span class="c1">//!   passed in using the map passed in. The mapping is expressed as a hash-map</span>
<a name="line-170"></a><span class="c1">//!   of key-&gt;value pairs, where the key is the original and the value is the</span>
<a name="line-171"></a><span class="c1">//!   new ids of the mapping. The function creates and returns a new container</span>
<a name="line-172"></a><span class="c1">//!   with the remapped ids of identical size of the original ids container.</span>
<a name="line-173"></a><span class="c1">//! \note All ids in the input ids container must have a key in the map.</span>
<a name="line-174"></a><span class="c1">//!   Otherwise an exception is thrown.</span>
<a name="line-175"></a><span class="c1">//! \note It is okay to call this function with the ids container empty but not</span>
<a name="line-176"></a><span class="c1">//!   okay to pass an empty map.</span>
<a name="line-177"></a><span class="c1">// *****************************************************************************</span>
<a name="line-178"></a><span class="p">{</span>
<a name="line-179"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">map</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Map must not be empty&quot;</span> <span class="p">);</span>
<a name="line-180"></a>
<a name="line-181"></a>  <span class="c1">// in terms of the in-place remap of a vector using a map</span>
<a name="line-182"></a>  <span class="k">auto</span> <span class="n">newids</span> <span class="o">=</span> <span class="n">ids</span><span class="p">;</span>
<a name="line-183"></a>  <span class="n">remap</span><span class="p">(</span> <span class="n">newids</span><span class="p">,</span> <span class="n">map</span> <span class="p">);</span>
<a name="line-184"></a>
<a name="line-185"></a>  <span class="k">return</span> <span class="n">newids</span><span class="p">;</span>
<a name="line-186"></a><span class="p">}</span>
<a name="line-187"></a>
<a name="line-188"></a><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<a name="line-189"></a><span class="n">remap</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">ids</span><span class="p">,</span>
<a name="line-190"></a>       <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">map</span> <span class="p">)</span>
<a name="line-191"></a><span class="c1">// *****************************************************************************</span>
<a name="line-192"></a><span class="c1">//  Create remapped map of vector of indices using a map</span>
<a name="line-193"></a><span class="c1">//! \param[in] ids Map of vector of integer IDs to create new container of ids</span>
<a name="line-194"></a><span class="c1">//!   from</span>
<a name="line-195"></a><span class="c1">//! \param[in] map Hash-map of key-&gt;value creating a new order</span>
<a name="line-196"></a><span class="c1">//! \return Remapped vector of ids</span>
<a name="line-197"></a><span class="c1">//! \details This function applies a mapping (reordering) to the map of integer</span>
<a name="line-198"></a><span class="c1">//!   IDs passed in using the map passed in by applying remap(vector,map) on</span>
<a name="line-199"></a><span class="c1">//!   each vector of ids. The keys in the returned map will be the same as in</span>
<a name="line-200"></a><span class="c1">//!   ids.</span>
<a name="line-201"></a><span class="c1">// *****************************************************************************</span>
<a name="line-202"></a><span class="p">{</span>
<a name="line-203"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">map</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Map must not be empty&quot;</span> <span class="p">);</span>
<a name="line-204"></a>
<a name="line-205"></a>  <span class="c1">// in terms of the in-place remap of a vector using a map</span>
<a name="line-206"></a>  <span class="k">auto</span> <span class="n">newids</span> <span class="o">=</span> <span class="n">ids</span><span class="p">;</span>
<a name="line-207"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">m</span> <span class="p">:</span> <span class="n">newids</span><span class="p">)</span> <span class="n">remap</span><span class="p">(</span> <span class="n">m</span><span class="p">.</span><span class="n">second</span><span class="p">,</span> <span class="n">map</span> <span class="p">);</span>
<a name="line-208"></a>
<a name="line-209"></a>  <span class="k">return</span> <span class="n">newids</span><span class="p">;</span>
<a name="line-210"></a><span class="p">}</span>
<a name="line-211"></a>
<a name="line-212"></a><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span>
<a name="line-213"></a><span class="n">renumber</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span>
<a name="line-214"></a>                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">psup</span> <span class="p">)</span>
<a name="line-215"></a><span class="c1">// *****************************************************************************</span>
<a name="line-216"></a><span class="c1">//  Reorder mesh points with the advancing front technique</span>
<a name="line-217"></a><span class="c1">//! \param[in] psup Points surrounding points</span>
<a name="line-218"></a><span class="c1">//! \return Mapping created by renumbering (reordering)</span>
<a name="line-219"></a><span class="c1">// *****************************************************************************</span>
<a name="line-220"></a><span class="p">{</span>
<a name="line-221"></a>  <span class="c1">// Find out number of nodes in graph</span>
<a name="line-222"></a>  <span class="k">auto</span> <span class="n">npoin</span> <span class="o">=</span> <span class="n">psup</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="mi">-1</span><span class="p">;</span>
<a name="line-223"></a>
<a name="line-224"></a>  <span class="c1">// Construct mapping using advancing front</span>
<a name="line-225"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">hpoin</span><span class="p">(</span> <span class="n">npoin</span><span class="p">,</span> <span class="mi">-1</span> <span class="p">),</span> <span class="n">lpoin</span><span class="p">(</span> <span class="n">npoin</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-226"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span> <span class="n">npoin</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<a name="line-227"></a>  <span class="n">hpoin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-228"></a>  <span class="n">lpoin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-229"></a>  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-230"></a>  <span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="n">npoin</span><span class="p">)</span> <span class="p">{</span>
<a name="line-231"></a>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-232"></a>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-233"></a>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">kpoin</span><span class="p">(</span> <span class="n">npoin</span><span class="p">,</span> <span class="mi">-1</span> <span class="p">);</span>
<a name="line-234"></a>    <span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
<a name="line-235"></a>    <span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">hpoin</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">{</span>
<a name="line-236"></a>      <span class="o">++</span><span class="n">i</span><span class="p">;</span>
<a name="line-237"></a>      <span class="k">auto</span> <span class="n">P</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">p</span> <span class="p">);</span>
<a name="line-238"></a>      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span><span class="o">=</span><span class="n">psup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">P</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">psup</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">P</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
<a name="line-239"></a>        <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">psup</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<a name="line-240"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">lpoin</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// consider points not yet counted</span>
<a name="line-241"></a>          <span class="n">map</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++</span><span class="p">;</span>
<a name="line-242"></a>          <span class="n">kpoin</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">q</span> <span class="p">);</span> <span class="c1">// register point as counted</span>
<a name="line-243"></a>          <span class="n">lpoin</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>                         <span class="c1">// register the point as counted</span>
<a name="line-244"></a>          <span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
<a name="line-245"></a>        <span class="p">}</span>
<a name="line-246"></a>      <span class="p">}</span>
<a name="line-247"></a>    <span class="p">}</span>
<a name="line-248"></a>    <span class="n">hpoin</span> <span class="o">=</span> <span class="n">kpoin</span><span class="p">;</span>
<a name="line-249"></a>  <span class="p">}</span>
<a name="line-250"></a>
<a name="line-251"></a><span class="c1">//   // Construct new-&gt;old id map</span>
<a name="line-252"></a><span class="c1">//   std::size_t i = 0;</span>
<a name="line-253"></a><span class="c1">//   std::vector&lt; std::size_t &gt; oldmap( npoin );</span>
<a name="line-254"></a><span class="c1">//   for (auto n : map) oldmap[n] = i++;</span>
<a name="line-255"></a>
<a name="line-256"></a>  <span class="c1">// Return old-&gt;new and new-&gt;old maps</span>
<a name="line-257"></a>  <span class="k">return</span> <span class="n">map</span><span class="p">;</span>
<a name="line-258"></a><span class="p">}</span>
<a name="line-259"></a>
<a name="line-260"></a><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span>
<a name="line-261"></a><span class="n">assignLid</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">gid</span> <span class="p">)</span>
<a name="line-262"></a><span class="c1">// *****************************************************************************</span>
<a name="line-263"></a><span class="c1">//  Assign local ids to global ids</span>
<a name="line-264"></a><span class="c1">//! \param[in] gid Global ids</span>
<a name="line-265"></a><span class="c1">//! \return Map associating global ids to local ids</span>
<a name="line-266"></a><span class="c1">// *****************************************************************************</span>
<a name="line-267"></a><span class="p">{</span>
<a name="line-268"></a>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">lid</span><span class="p">;</span>
<a name="line-269"></a>  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-270"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">gid</span><span class="p">)</span> <span class="n">lid</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">++</span><span class="p">;</span>
<a name="line-271"></a>  <span class="k">return</span> <span class="n">lid</span><span class="p">;</span>
<a name="line-272"></a><span class="p">}</span>
<a name="line-273"></a>
<a name="line-274"></a><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span>
<a name="line-275"></a>            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">,</span>
<a name="line-276"></a>            <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<a name="line-277"></a><span class="n">global2local</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">ginpoel</span> <span class="p">)</span>
<a name="line-278"></a><span class="c1">// *****************************************************************************</span>
<a name="line-279"></a><span class="c1">//  Generate element connectivity of local node IDs from connectivity of global</span>
<a name="line-280"></a><span class="c1">//  node IDs also returning the mapping between local to global IDs</span>
<a name="line-281"></a><span class="c1">//! \param[in] ginpoel Element connectivity with global node IDs</span>
<a name="line-282"></a><span class="c1">//! \return Tuple of (1) element connectivity with local node IDs, (2) the</span>
<a name="line-283"></a><span class="c1">//!   vector of unique global node IDs (i.e., the mapping between local to</span>
<a name="line-284"></a><span class="c1">//!   global node IDs), and (3) mapping between global to local node IDs.</span>
<a name="line-285"></a><span class="c1">// *****************************************************************************</span>
<a name="line-286"></a><span class="p">{</span>
<a name="line-287"></a>  <span class="c1">// Make a copy of the element connectivity with global node ids</span>
<a name="line-288"></a>  <span class="k">auto</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">ginpoel</span><span class="p">;</span>
<a name="line-289"></a>
<a name="line-290"></a>  <span class="c1">// Generate a vector that holds only the unique global mesh node ids</span>
<a name="line-291"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span> <span class="n">gid</span> <span class="p">);</span>
<a name="line-292"></a>
<a name="line-293"></a>  <span class="c1">// Assign local node ids to global node ids</span>
<a name="line-294"></a>  <span class="k">const</span> <span class="k">auto</span> <span class="n">lid</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">assignLid</span><span class="p">(</span> <span class="n">gid</span> <span class="p">);</span>
<a name="line-295"></a>
<a name="line-296"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">gid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">lid</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;Size mismatch&quot;</span> <span class="p">);</span>
<a name="line-297"></a>
<a name="line-298"></a>  <span class="c1">// Generate element connectivity using local node ids</span>
<a name="line-299"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">inpoel</span><span class="p">(</span> <span class="n">ginpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
<a name="line-300"></a>  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-301"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">ginpoel</span><span class="p">)</span> <span class="n">inpoel</span><span class="p">[</span> <span class="n">j</span><span class="o">++</span> <span class="p">]</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span> <span class="n">lid</span><span class="p">,</span> <span class="n">p</span> <span class="p">);</span>
<a name="line-302"></a>
<a name="line-303"></a>  <span class="c1">// Return element connectivty with local node IDs</span>
<a name="line-304"></a>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">,</span> <span class="n">gid</span><span class="p">,</span> <span class="n">lid</span> <span class="p">);</span>
<a name="line-305"></a><span class="p">}</span>
<a name="line-306"></a>
<a name="line-307"></a><span class="kt">bool</span>
<a name="line-308"></a><span class="n">positiveJacobians</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">inpoel</span><span class="p">,</span>
<a name="line-309"></a>                   <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">real</span> <span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span> <span class="o">&gt;&amp;</span> <span class="n">coord</span> <span class="p">)</span>
<a name="line-310"></a><span class="c1">// *****************************************************************************</span>
<a name="line-311"></a><span class="c1">// Test for positivity of the Jacobian for all cells in mesh</span>
<a name="line-312"></a><span class="c1">//! \param[in] inpoel Element connectivity (zero-based, i.e., local if parallel)</span>
<a name="line-313"></a><span class="c1">//! \param[in] coord Node coordinates</span>
<a name="line-314"></a><span class="c1">//! \return True if Jacobians of all mesh cells are positive</span>
<a name="line-315"></a><span class="c1">// *****************************************************************************</span>
<a name="line-316"></a><span class="p">{</span>
<a name="line-317"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">inpoel</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Mesh connectivity empty&quot;</span> <span class="p">);</span>
<a name="line-318"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
<a name="line-319"></a>          <span class="s">&quot;Mesh connectivity size must be divisible by 4 &quot;</span> <span class="p">);</span>
<a name="line-320"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">tk</span><span class="o">::</span><span class="n">uniquecopy</span><span class="p">(</span><span class="n">inpoel</span><span class="p">).</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;Number of unique &quot;</span>
<a name="line-321"></a>          <span class="s">&quot;nodes in mesh connectivity must equal the number of nodes to which &quot;</span>
<a name="line-322"></a>          <span class="s">&quot;coordinates have been supplied&quot;</span> <span class="p">);</span>
<a name="line-323"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">tk</span><span class="o">::</span><span class="n">uniquecopy</span><span class="p">(</span><span class="n">inpoel</span><span class="p">).</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;Number of unique &quot;</span>
<a name="line-324"></a>          <span class="s">&quot;nodes in mesh connectivity must equal the number of nodes to which &quot;</span>
<a name="line-325"></a>          <span class="s">&quot;coordinates have been supplied&quot;</span> <span class="p">);</span>
<a name="line-326"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">tk</span><span class="o">::</span><span class="n">uniquecopy</span><span class="p">(</span><span class="n">inpoel</span><span class="p">).</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;Number of unique &quot;</span>
<a name="line-327"></a>          <span class="s">&quot;nodes in mesh connectivity must equal the number of nodes to which &quot;</span>
<a name="line-328"></a>          <span class="s">&quot;coordinates have been supplied&quot;</span> <span class="p">);</span>
<a name="line-329"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">inpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">inpoel</span><span class="p">)</span> <span class="p">).</span><span class="n">first</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
<a name="line-330"></a>          <span class="s">&quot;node ids should start from zero&quot;</span> <span class="p">);</span>
<a name="line-331"></a>
<a name="line-332"></a>  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<a name="line-333"></a>  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<a name="line-334"></a>  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">z</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<a name="line-335"></a>
<a name="line-336"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">inpoel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
<a name="line-337"></a>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="mi">4</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">{{</span> <span class="n">inpoel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">0</span><span class="p">],</span> <span class="n">inpoel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
<a name="line-338"></a>                                           <span class="n">inpoel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="n">inpoel</span><span class="p">[</span><span class="n">e</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="p">}};</span>
<a name="line-339"></a>    <span class="c1">// compute element Jacobi determinant / (5/120) = element volume * 4</span>
<a name="line-340"></a>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="n">tk</span><span class="o">::</span><span class="n">real</span><span class="p">,</span> <span class="mi">3</span> <span class="o">&gt;</span>
<a name="line-341"></a>      <span class="n">ba</span><span class="p">{{</span> <span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">z</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">}},</span>
<a name="line-342"></a>      <span class="n">ca</span><span class="p">{{</span> <span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">z</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">}},</span>
<a name="line-343"></a>      <span class="n">da</span><span class="p">{{</span> <span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">z</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">}};</span>
<a name="line-344"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">tk</span><span class="o">::</span><span class="n">triple</span><span class="p">(</span> <span class="n">ba</span><span class="p">,</span> <span class="n">ca</span><span class="p">,</span> <span class="n">da</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<a name="line-345"></a> <span class="p">}</span>
<a name="line-346"></a>
<a name="line-347"></a> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<a name="line-348"></a><span class="p">}</span>
<a name="line-349"></a>
<a name="line-350"></a><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<a name="line-351"></a><span class="n">bfacenodes</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">bface</span><span class="p">,</span>
<a name="line-352"></a>            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">triinpoel</span> <span class="p">)</span>
<a name="line-353"></a><span class="c1">// *****************************************************************************</span>
<a name="line-354"></a><span class="c1">// Generate nodes of side set faces</span>
<a name="line-355"></a><span class="c1">//! \param[in] bface Boundary-faces mapped to side set ids</span>
<a name="line-356"></a><span class="c1">//! \param[in] triinpoel Boundary-face connectivity</span>
<a name="line-357"></a><span class="c1">//! \return Nodes of side set faces for each side set passed in</span>
<a name="line-358"></a><span class="c1">// *****************************************************************************</span>
<a name="line-359"></a><span class="p">{</span>
<a name="line-360"></a>  <span class="k">auto</span> <span class="n">bfn</span> <span class="o">=</span> <span class="n">bface</span><span class="p">;</span>
<a name="line-361"></a>
<a name="line-362"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">:</span> <span class="n">bfn</span><span class="p">)</span> <span class="p">{</span>
<a name="line-363"></a>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="n">nodes</span><span class="p">;</span>
<a name="line-364"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
<a name="line-365"></a>      <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">triinpoel</span><span class="p">[</span><span class="n">f</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>
<a name="line-366"></a>      <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">triinpoel</span><span class="p">[</span><span class="n">f</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
<a name="line-367"></a>      <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">triinpoel</span><span class="p">[</span><span class="n">f</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="p">);</span>
<a name="line-368"></a>    <span class="p">}</span>
<a name="line-369"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span> <span class="n">nodes</span> <span class="p">);</span>
<a name="line-370"></a>    <span class="n">b</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">nodes</span> <span class="p">);</span>
<a name="line-371"></a>  <span class="p">}</span>
<a name="line-372"></a>
<a name="line-373"></a>  <span class="k">return</span> <span class="n">bfn</span><span class="p">;</span>
<a name="line-374"></a><span class="p">}</span>
<a name="line-375"></a>
<a name="line-376"></a><span class="p">}</span> <span class="c1">// tk::</span>
</pre></div>
</td></tr></table>
      </div> <!-- /.wrapper -->
    </div>
    <div id="footer" class="footer">
      <p>
        Cppcheck 2.3 - a tool for static C/C++ code analysis<br>
        <br>
        Internet: <a href="http://cppcheck.net">http://cppcheck.net</a><br>
        IRC: <a href="irc://irc.freenode.net/cppcheck">irc://irc.freenode.net/cppcheck</a><br>
      </p>
    </div>
  </body>
</html>
