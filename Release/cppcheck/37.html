
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cppcheck - HTML report - [<a href=https://github.com/quinoacomputing/quinoa/commit/-128-NOTFOUND>-128-NOTFOUND</a>]</title>
    <link rel="stylesheet" href="style.css">
    <style>
pre { line-height: 125%; margin: 0; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .ch { color: #888888 } /* Comment.Hashbang */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .cpf { color: #888888 } /* Comment.PreprocFile */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { background-color: #fff0f0 } /* Literal.String.Affix */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .vm { color: #996633 } /* Name.Variable.Magic */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
    </style>
    <script>
      function getStyle(el, styleProp) {
        var y;

        if (el.currentStyle) {
          y = el.currentStyle[styleProp];
        } else if (window.getComputedStyle) {
          y = document.defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);
        }

        return y;
      }

      function toggle() {
        var el = this.expandable_content;
        var mark = this.expandable_marker;

        if (el.style.display === "block") {
          el.style.display = "none";
          mark.textContent = "[+]";
        } else {
          el.style.display = "block";
          mark.textContent = "[-]";
        }
      }

      function initExpandables() {
        var elements = document.querySelectorAll(".expandable");

        for (var i = 0, len = elements.length; i < len; i++) {
          var el = elements[i];
          var clickable = el.querySelector("span");
          var marker = clickable.querySelector(".marker");
          var content = el.querySelector(".content");
          var width = clickable.clientWidth - parseInt(getStyle(content, "padding-left")) - parseInt(getStyle(content, "padding-right"));
          content.style.width = width + "px";
          clickable.expandable_content = content;
          clickable.expandable_marker = marker;
          clickable.addEventListener("click", toggle);
        }
      }

      function toggleDisplay(id) {
        var elements = document.querySelectorAll("." + id);

        for (var i = 0, len = elements.length; i < len; i++) {
          elements[i].classList.toggle("d-none");
        }
      }

      function toggleAll() {
        var elements = document.querySelectorAll("input");

        // starting from 1 since 0 is the "toggle all" input
        for (var i = 1, len = elements.length; i < len; i++) {
          var el = elements[i];

          if (el.checked) {
            el.checked = false;
          } else {
            el.checked = true;
          }

          toggleDisplay(el.id);
        }
      }
      window.addEventListener("load", initExpandables);
    </script>
  </head>
  <body>
    <div id="header" class="header">
      <h1>Cppcheck report - [<a href=https://github.com/quinoacomputing/quinoa/commit/-128-NOTFOUND>-128-NOTFOUND</a>]: /tmp/TeamCity-3/work/5ad443c8abe7fc0a/src/Inciter/Sorter.cpp</h1>
    </div>
    <div class="wrapper">
      <div id="menu">
       <p id="filename"><a href="index.html">Defects:</a> Sorter.cpp</p>
<a href="37.html#line-127"> unreadVariable 127</a><a href="37.html#line-569"> useStlAlgorithm 569</a>
    </div>
    <div id="content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622</pre></div></td><td class="code"><div class="highlight"><pre><span></span><a name="line-1"></a><span class="c1">// *****************************************************************************</span>
<a name="line-2"></a><span class="cm">/*!</span>
<a name="line-3"></a><span class="cm">  \file      src/Inciter/Sorter.cpp</span>
<a name="line-4"></a><span class="cm">  \copyright 2012-2015 J. Bakosi,</span>
<a name="line-5"></a><span class="cm">             2016-2018 Los Alamos National Security, LLC.,</span>
<a name="line-6"></a><span class="cm">             2019-2021 Triad National Security, LLC.</span>
<a name="line-7"></a><span class="cm">             All rights reserved. See the LICENSE file for details.</span>
<a name="line-8"></a><span class="cm">  \brief     Mesh sorter for global distributed mesh reordering</span>
<a name="line-9"></a><span class="cm">  \see       Sorter.h for more info.</span>
<a name="line-10"></a><span class="cm">*/</span>
<a name="line-11"></a><span class="c1">// *****************************************************************************</span>
<a name="line-12"></a>
<a name="line-13"></a><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<a name="line-14"></a><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<a name="line-15"></a>
<a name="line-16"></a><span class="cp">#include</span> <span class="cpf">&quot;Sorter.hpp&quot;</span><span class="cp"></span>
<a name="line-17"></a><span class="cp">#include</span> <span class="cpf">&quot;Reorder.hpp&quot;</span><span class="cp"></span>
<a name="line-18"></a><span class="cp">#include</span> <span class="cpf">&quot;DerivedData.hpp&quot;</span><span class="cp"></span>
<a name="line-19"></a><span class="cp">#include</span> <span class="cpf">&quot;Inciter/InputDeck/InputDeck.hpp&quot;</span><span class="cp"></span>
<a name="line-20"></a>
<a name="line-21"></a><span class="k">namespace</span> <span class="n">inciter</span> <span class="p">{</span>
<a name="line-22"></a>
<a name="line-23"></a><span class="k">extern</span> <span class="n">ctr</span><span class="o">::</span><span class="n">InputDeck</span> <span class="n">g_inputdeck</span><span class="p">;</span>
<a name="line-24"></a>
<a name="line-25"></a><span class="p">}</span> <span class="c1">// inciter::</span>
<a name="line-26"></a>
<a name="line-27"></a><span class="k">using</span> <span class="n">inciter</span><span class="o">::</span><span class="n">Sorter</span><span class="p">;</span>
<a name="line-28"></a>
<a name="line-29"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">Sorter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">meshid</span><span class="p">,</span>
<a name="line-30"></a>                <span class="k">const</span> <span class="n">CProxy_Transporter</span><span class="o">&amp;</span> <span class="n">transporter</span><span class="p">,</span>
<a name="line-31"></a>                <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">CProxy_MeshWriter</span><span class="o">&amp;</span> <span class="n">meshwriter</span><span class="p">,</span>
<a name="line-32"></a>                <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">SorterCallback</span><span class="o">&amp;</span> <span class="n">cbs</span><span class="p">,</span>
<a name="line-33"></a>                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">Scheme</span> <span class="o">&gt;&amp;</span> <span class="n">scheme</span><span class="p">,</span>
<a name="line-34"></a>                <span class="n">CkCallback</span> <span class="n">reorderRefiner</span><span class="p">,</span>
<a name="line-35"></a>                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">ginpoel</span><span class="p">,</span>
<a name="line-36"></a>                <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">CoordMap</span><span class="o">&amp;</span> <span class="n">coordmap</span><span class="p">,</span>
<a name="line-37"></a>                <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Chunk</span><span class="o">&amp;</span> <span class="n">el</span><span class="p">,</span>
<a name="line-38"></a>                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">bface</span><span class="p">,</span>
<a name="line-39"></a>                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">triinpoel</span><span class="p">,</span>
<a name="line-40"></a>                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">bnode</span><span class="p">,</span>
<a name="line-41"></a>                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span>
<a name="line-42"></a>                  <span class="n">elemblockid</span><span class="p">,</span>
<a name="line-43"></a>                <span class="kt">int</span> <span class="n">nchare</span> <span class="p">)</span> <span class="o">:</span>
<a name="line-44"></a>  <span class="n">m_meshid</span><span class="p">(</span> <span class="n">meshid</span> <span class="p">),</span>
<a name="line-45"></a>  <span class="n">m_host</span><span class="p">(</span> <span class="n">transporter</span> <span class="p">),</span>
<a name="line-46"></a>  <span class="n">m_meshwriter</span><span class="p">(</span> <span class="n">meshwriter</span> <span class="p">),</span>
<a name="line-47"></a>  <span class="n">m_cbs</span><span class="p">(</span> <span class="n">cbs</span> <span class="p">),</span>
<a name="line-48"></a>  <span class="n">m_scheme</span><span class="p">(</span> <span class="n">scheme</span> <span class="p">),</span>
<a name="line-49"></a>  <span class="n">m_reorderRefiner</span><span class="p">(</span> <span class="n">reorderRefiner</span> <span class="p">),</span>
<a name="line-50"></a>  <span class="n">m_ginpoel</span><span class="p">(</span> <span class="n">ginpoel</span> <span class="p">),</span>
<a name="line-51"></a>  <span class="n">m_coordmap</span><span class="p">(</span> <span class="n">coordmap</span> <span class="p">),</span>
<a name="line-52"></a>  <span class="n">m_el</span><span class="p">(</span> <span class="n">el</span> <span class="p">),</span>
<a name="line-53"></a>  <span class="n">m_nbnd</span><span class="p">(</span> <span class="mi">0</span> <span class="p">),</span>
<a name="line-54"></a>  <span class="n">m_bface</span><span class="p">(</span> <span class="n">bface</span> <span class="p">),</span>
<a name="line-55"></a>  <span class="n">m_triinpoel</span><span class="p">(</span> <span class="n">triinpoel</span> <span class="p">),</span>
<a name="line-56"></a>  <span class="n">m_bnode</span><span class="p">(</span> <span class="n">bnode</span> <span class="p">),</span>
<a name="line-57"></a>  <span class="n">m_elemblockid</span><span class="p">(</span> <span class="n">elemblockid</span> <span class="p">),</span>
<a name="line-58"></a>  <span class="n">m_nchare</span><span class="p">(</span> <span class="n">nchare</span> <span class="p">),</span>
<a name="line-59"></a>  <span class="n">m_nodeset</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">ginpoel</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">ginpoel</span><span class="p">)</span> <span class="p">),</span>
<a name="line-60"></a>  <span class="n">m_noffset</span><span class="p">(</span> <span class="mi">0</span> <span class="p">),</span>
<a name="line-61"></a>  <span class="n">m_nodech</span><span class="p">(),</span>
<a name="line-62"></a>  <span class="n">m_chnode</span><span class="p">(),</span>
<a name="line-63"></a>  <span class="n">m_edgech</span><span class="p">(),</span>
<a name="line-64"></a>  <span class="n">m_chedge</span><span class="p">(),</span>
<a name="line-65"></a>  <span class="n">m_msum</span><span class="p">(),</span>
<a name="line-66"></a>  <span class="n">m_reordcomm</span><span class="p">(),</span>
<a name="line-67"></a>  <span class="n">m_start</span><span class="p">(</span> <span class="mi">0</span> <span class="p">),</span>
<a name="line-68"></a>  <span class="n">m_newnodes</span><span class="p">(),</span>
<a name="line-69"></a>  <span class="n">m_newcoordmap</span><span class="p">(),</span>
<a name="line-70"></a>  <span class="n">m_reqnodes</span><span class="p">(),</span>
<a name="line-71"></a>  <span class="n">m_lower</span><span class="p">(</span> <span class="mi">0</span> <span class="p">),</span>
<a name="line-72"></a>  <span class="n">m_upper</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span>
<a name="line-73"></a><span class="c1">// *****************************************************************************</span>
<a name="line-74"></a><span class="c1">//  Constructor: prepare owned mesh node IDs for reordering</span>
<a name="line-75"></a><span class="c1">//! \param[in] meshid Mesh ID</span>
<a name="line-76"></a><span class="c1">//! \param[in] transporter Transporter (host) Charm++ proxy</span>
<a name="line-77"></a><span class="c1">//! \param[in] meshwriter Mesh writer Charm++ proxy</span>
<a name="line-78"></a><span class="c1">//! \param[in] cbs Charm++ callbacks for Sorter</span>
<a name="line-79"></a><span class="c1">//! \param[in] scheme Discretization schemes (one per mesh)</span>
<a name="line-80"></a><span class="c1">//! \param[in] reorderRefiner Callback to use to send reordered mesh to Refiner</span>
<a name="line-81"></a><span class="c1">//! \param[in] ginpoel Mesh connectivity (this chare) using global node IDs</span>
<a name="line-82"></a><span class="c1">//! \param[in] coordmap Mesh node coordinates (this chare) for global node IDs</span>
<a name="line-83"></a><span class="c1">//! \param[in] bface Face lists mapped to side set ids</span>
<a name="line-84"></a><span class="c1">//! \param[in] triinpoel Interconnectivity of points and boundary-faces</span>
<a name="line-85"></a><span class="c1">//! \param[in] bnode Node ids mapped to side set ids</span>
<a name="line-86"></a><span class="c1">//! \param[in] elemblockid Local tet ids associated to mesh block ids</span>
<a name="line-87"></a><span class="c1">//! \param[in] nchare Total number of Charm++ worker chares</span>
<a name="line-88"></a><span class="c1">// *****************************************************************************</span>
<a name="line-89"></a><span class="p">{</span>
<a name="line-90"></a>  <span class="c1">// Ensure boundary face ids will not index out of face connectivity</span>
<a name="line-91"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">m_bface</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">m_bface</span><span class="p">),</span>
<a name="line-92"></a>            <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
<a name="line-93"></a>            <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">),</span>
<a name="line-94"></a>                       <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">f</span><span class="p">){</span> <span class="k">return</span> <span class="n">f</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">m_triinpoel</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span> <span class="p">);</span> <span class="p">}</span> <span class="p">),</span>
<a name="line-95"></a>          <span class="s">&quot;Boundary face data structures inconsistent&quot;</span> <span class="p">);</span>
<a name="line-96"></a><span class="p">}</span>
<a name="line-97"></a>
<a name="line-98"></a><span class="kt">void</span>
<a name="line-99"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">setup</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">npoin</span> <span class="p">)</span>
<a name="line-100"></a><span class="c1">// *****************************************************************************</span>
<a name="line-101"></a><span class="c1">// Setup chare mesh boundary node communication map</span>
<a name="line-102"></a><span class="c1">//! \param[in] npoin Total number of mesh points in mesh. Note that the number</span>
<a name="line-103"></a><span class="c1">//!   of mesh points does not have to be exactly the total number of points in</span>
<a name="line-104"></a><span class="c1">//!   the mesh. It can be a larger number, but not less. This is only used here</span>
<a name="line-105"></a><span class="c1">//!   to assign nodes to workers that will assign ids to mesh nodes during node</span>
<a name="line-106"></a><span class="c1">//!   reordering.</span>
<a name="line-107"></a><span class="c1">// *****************************************************************************</span>
<a name="line-108"></a><span class="p">{</span>
<a name="line-109"></a>  <span class="c1">// Compute the number of nodes (chunksize) a chare will build a node</span>
<a name="line-110"></a>  <span class="c1">// communication map for. We compute two values of chunksize: one for when</span>
<a name="line-111"></a>  <span class="c1">// the global node ids are abounded between [0...npoin-1], inclusive, and</span>
<a name="line-112"></a>  <span class="c1">// another one for when the global node ids are assigned by a hash algorithm</span>
<a name="line-113"></a>  <span class="c1">// during initial mesh refinement. In the latter case, the maximum</span>
<a name="line-114"></a>  <span class="c1">// representable value of a std::size_t is assumed to be the large global node</span>
<a name="line-115"></a>  <span class="c1">// id and is used to compute the chunksize. To compute the bin id, we attempt</span>
<a name="line-116"></a>  <span class="c1">// to use the first chunksize first: if it gives a chare id that is</span>
<a name="line-117"></a>  <span class="c1">// (strictly) lower than the number of chares, that&#39;s good. If not, we compute</span>
<a name="line-118"></a>  <span class="c1">// the bin id based on the second chunksize, which almost always will give a</span>
<a name="line-119"></a>  <span class="c1">// bin id strictly lower than the number of chares, except if the global node</span>
<a name="line-120"></a>  <span class="c1">// id assigned by the hash algorithm in Refiner hits the maximum</span>
<a name="line-121"></a>  <span class="c1">// representable number in std::size_t. If that is the case, we just assign</span>
<a name="line-122"></a>  <span class="c1">// that node to the last chare.</span>
<a name="line-123"></a>  <span class="k">auto</span> <span class="n">N</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">m_nchare</span> <span class="p">);</span>
<a name="line-124"></a>  <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">chunksize</span><span class="p">{{</span>
<a name="line-125"></a>     <span class="n">npoin</span> <span class="o">/</span> <span class="n">N</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">N</span> <span class="p">}};</span>
<a name="line-126"></a>
<a name="line-127"></a><span class="hll">  <span class="k">const</span> <span class="k">auto</span> <span class="n">scheme</span> <span class="o">=</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">discr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">scheme</span> <span class="o">&gt;</span><span class="p">();</span><span class="error2">&lt;--- Variable 'scheme' is assigned a value that is never used.</span>
</span><a name="line-128"></a>
<a name="line-129"></a>  <span class="c1">// Find chare-boundary nodes and edges of our mesh chunk. This algorithm</span>
<a name="line-130"></a>  <span class="c1">// collects the global mesh node ids and edges on the chare boundary. A node</span>
<a name="line-131"></a>  <span class="c1">// is on a chare boundary if it belongs to a face of a tetrahedron that has</span>
<a name="line-132"></a>  <span class="c1">// no neighbor tet at a face. The edge is on the chare boundary if its first</span>
<a name="line-133"></a>  <span class="c1">// edge-end point is on a chare boundary. The nodes are categorized to bins</span>
<a name="line-134"></a>  <span class="c1">// that will be sent to different chares to build point-to-point</span>
<a name="line-135"></a>  <span class="c1">// communication maps across all chares. The binning is determined by the</span>
<a name="line-136"></a>  <span class="c1">// global node id divided by the chunksizes. See discussion above on how we</span>
<a name="line-137"></a>  <span class="c1">// use two chunksizes for global node ids assigned by the hash algorithm in</span>
<a name="line-138"></a>  <span class="c1">// Refiner (if initial mesh refinement has been done).</span>
<a name="line-139"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">CommMaps</span> <span class="n">chbnd</span><span class="p">;</span>
<a name="line-140"></a>  <span class="k">auto</span> <span class="n">el</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">global2local</span><span class="p">(</span> <span class="n">m_ginpoel</span> <span class="p">);</span>      <span class="c1">// generate local mesh data</span>
<a name="line-141"></a>  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">inpoel</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">el</span> <span class="p">);</span>     <span class="c1">// local connectivity</span>
<a name="line-142"></a>  <span class="k">auto</span> <span class="n">esup</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">genEsup</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>         <span class="c1">// elements surrounding points</span>
<a name="line-143"></a>  <span class="k">auto</span> <span class="n">esuel</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">genEsuelTet</span><span class="p">(</span> <span class="n">inpoel</span><span class="p">,</span> <span class="n">esup</span> <span class="p">);</span> <span class="c1">// elems surrounding elements</span>
<a name="line-144"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">e</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">e</span><span class="o">&lt;</span><span class="n">esuel</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
<a name="line-145"></a>    <span class="k">auto</span> <span class="n">mark</span> <span class="o">=</span> <span class="n">e</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
<a name="line-146"></a>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">f</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">f</span><span class="p">)</span>
<a name="line-147"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">esuel</span><span class="p">[</span><span class="n">mark</span><span class="o">+</span><span class="n">f</span><span class="p">]</span> <span class="o">==</span> <span class="mi">-1</span><span class="p">)</span>
<a name="line-148"></a>        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<a name="line-149"></a>          <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">m_ginpoel</span><span class="p">[</span> <span class="n">mark</span><span class="o">+</span><span class="n">tk</span><span class="o">::</span><span class="n">lpofa</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="p">];</span>
<a name="line-150"></a>          <span class="k">auto</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="n">chunksize</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<a name="line-151"></a>          <span class="k">if</span> <span class="p">(</span><span class="n">bin</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">)</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">g</span> <span class="o">/</span> <span class="n">chunksize</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<a name="line-152"></a>          <span class="k">if</span> <span class="p">(</span><span class="n">bin</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">)</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-153"></a>          <span class="n">Assert</span><span class="p">(</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">,</span> <span class="s">&quot;Will index out of number of chares&quot;</span> <span class="p">);</span>
<a name="line-154"></a>          <span class="k">auto</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">chbnd</span><span class="p">[</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">bin</span> <span class="p">)</span> <span class="p">];</span>
<a name="line-155"></a>          <span class="n">b</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">node</span> <span class="o">&gt;</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span> <span class="n">g</span> <span class="p">);</span>
<a name="line-156"></a>          <span class="k">if</span> <span class="p">(</span><span class="n">scheme</span> <span class="o">==</span> <span class="n">ctr</span><span class="o">::</span><span class="n">SchemeType</span><span class="o">::</span><span class="n">ALECG</span><span class="p">)</span> <span class="p">{</span>
<a name="line-157"></a>            <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">m_ginpoel</span><span class="p">[</span> <span class="n">mark</span> <span class="o">+</span> <span class="n">tk</span><span class="o">::</span><span class="n">lpofa</span><span class="p">[</span> <span class="n">f</span> <span class="p">][</span> <span class="n">tk</span><span class="o">::</span><span class="n">lpoet</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="p">];</span>
<a name="line-158"></a>            <span class="n">b</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">edge</span> <span class="o">&gt;</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">h</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">h</span><span class="p">)</span> <span class="p">}</span> <span class="p">);</span>
<a name="line-159"></a>          <span class="p">}</span>
<a name="line-160"></a>        <span class="p">}</span>
<a name="line-161"></a>  <span class="p">}</span>
<a name="line-162"></a>
<a name="line-163"></a>  <span class="c1">// Send boundary data in bins to chares that will compute communication maps</span>
<a name="line-164"></a>  <span class="c1">// for the data in the bin. These bins form a distributed table.  Note that</span>
<a name="line-165"></a>  <span class="c1">// we only send data to those chares that have data to work on. The receiving</span>
<a name="line-166"></a>  <span class="c1">// sides do not know in advance if they receive messages or not.  Completion</span>
<a name="line-167"></a>  <span class="c1">// is detected by having the receiver respond back and counting the responses</span>
<a name="line-168"></a>  <span class="c1">// on the sender side, i.e., this chare.</span>
<a name="line-169"></a>  <span class="n">m_nbnd</span> <span class="o">=</span> <span class="n">chbnd</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<a name="line-170"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">m_nbnd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<a name="line-171"></a>    <span class="n">contribute</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">m_meshid</span><span class="p">,</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">nop</span><span class="p">,</span>
<a name="line-172"></a>                <span class="n">m_cbs</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">queried</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
<a name="line-173"></a>  <span class="k">else</span>
<a name="line-174"></a>    <span class="nf">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span> <span class="n">targetchare</span><span class="p">,</span> <span class="n">bnd</span> <span class="p">]</span> <span class="o">:</span> <span class="n">chbnd</span><span class="p">)</span>
<a name="line-175"></a>      <span class="n">thisProxy</span><span class="p">[</span> <span class="n">targetchare</span> <span class="p">].</span><span class="n">query</span><span class="p">(</span> <span class="n">thisIndex</span><span class="p">,</span> <span class="n">bnd</span> <span class="p">);</span>
<a name="line-176"></a><span class="p">}</span>
<a name="line-177"></a>
<a name="line-178"></a><span class="kt">void</span>
<a name="line-179"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">query</span><span class="p">(</span> <span class="kt">int</span> <span class="n">fromch</span><span class="p">,</span> <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">AllCommMaps</span><span class="o">&amp;</span> <span class="n">bnd</span> <span class="p">)</span>
<a name="line-180"></a><span class="c1">// *****************************************************************************</span>
<a name="line-181"></a><span class="c1">// Incoming query for a list of mesh nodes for which this chare compiles node</span>
<a name="line-182"></a><span class="c1">// communication maps</span>
<a name="line-183"></a><span class="c1">//! \param[in] fromch Sender chare ID</span>
<a name="line-184"></a><span class="c1">//! \param[in] bnd Chare-boundary data from another chare</span>
<a name="line-185"></a><span class="c1">// *****************************************************************************</span>
<a name="line-186"></a><span class="p">{</span>
<a name="line-187"></a>  <span class="c1">// Store incoming nodes in node-&gt;chare and its inverse, chare-&gt;node, maps</span>
<a name="line-188"></a>  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">bnd</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">node</span> <span class="o">&gt;</span><span class="p">();</span>
<a name="line-189"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">nodes</span><span class="p">)</span> <span class="n">m_nodech</span><span class="p">[</span> <span class="n">n</span> <span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">fromch</span> <span class="p">);</span>
<a name="line-190"></a>  <span class="n">m_chnode</span><span class="p">[</span> <span class="n">fromch</span> <span class="p">].</span><span class="n">insert</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="p">);</span>
<a name="line-191"></a>
<a name="line-192"></a>  <span class="c1">// Store incoming edges in edge-&gt;chare and its inverse, chare-&gt;edge, maps</span>
<a name="line-193"></a>  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">bnd</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">edge</span> <span class="o">&gt;</span><span class="p">();</span>
<a name="line-194"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">edges</span><span class="p">)</span> <span class="n">m_edgech</span><span class="p">[</span> <span class="n">e</span> <span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">fromch</span> <span class="p">);</span>
<a name="line-195"></a>  <span class="n">m_chedge</span><span class="p">[</span> <span class="n">fromch</span> <span class="p">].</span><span class="n">insert</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="p">);</span>
<a name="line-196"></a>
<a name="line-197"></a>  <span class="c1">// Report back to chare message received from</span>
<a name="line-198"></a>  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">fromch</span> <span class="p">].</span><span class="n">recvquery</span><span class="p">();</span>
<a name="line-199"></a><span class="p">}</span>
<a name="line-200"></a>
<a name="line-201"></a><span class="kt">void</span>
<a name="line-202"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">recvquery</span><span class="p">()</span>
<a name="line-203"></a><span class="c1">// *****************************************************************************</span>
<a name="line-204"></a><span class="c1">// Receive receipt of boundary node lists to query</span>
<a name="line-205"></a><span class="c1">// *****************************************************************************</span>
<a name="line-206"></a><span class="p">{</span>
<a name="line-207"></a>  <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">m_nbnd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<a name="line-208"></a>    <span class="n">contribute</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">m_meshid</span><span class="p">,</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">nop</span><span class="p">,</span>
<a name="line-209"></a>                <span class="n">m_cbs</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">queried</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
<a name="line-210"></a><span class="p">}</span>
<a name="line-211"></a>
<a name="line-212"></a><span class="kt">void</span>
<a name="line-213"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">response</span><span class="p">()</span>
<a name="line-214"></a><span class="c1">// *****************************************************************************</span>
<a name="line-215"></a><span class="c1">//  Respond to boundary node list queries</span>
<a name="line-216"></a><span class="c1">// *****************************************************************************</span>
<a name="line-217"></a><span class="p">{</span>
<a name="line-218"></a>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">CommMaps</span> <span class="o">&gt;</span> <span class="n">exp</span><span class="p">;</span>
<a name="line-219"></a>
<a name="line-220"></a>  <span class="c1">// Compute node communication map to be sent back to chares</span>
<a name="line-221"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span> <span class="n">neighborchare</span><span class="p">,</span> <span class="n">bndnodes</span> <span class="p">]</span> <span class="o">:</span> <span class="n">m_chnode</span><span class="p">)</span> <span class="p">{</span>
<a name="line-222"></a>    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">exp</span><span class="p">[</span> <span class="n">neighborchare</span> <span class="p">];</span>
<a name="line-223"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">bndnodes</span><span class="p">)</span>
<a name="line-224"></a>      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">d</span> <span class="p">:</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span><span class="n">m_nodech</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<a name="line-225"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">!=</span> <span class="n">neighborchare</span><span class="p">)</span>
<a name="line-226"></a>          <span class="n">nc</span><span class="p">[</span><span class="n">d</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">node</span> <span class="o">&gt;</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span> <span class="n">n</span> <span class="p">);</span>
<a name="line-227"></a>  <span class="p">}</span>
<a name="line-228"></a>
<a name="line-229"></a>  <span class="c1">// Compute edge communication map to be sent back to chares</span>
<a name="line-230"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span> <span class="n">neighborchare</span><span class="p">,</span> <span class="n">bndedges</span> <span class="p">]</span> <span class="o">:</span> <span class="n">m_chedge</span><span class="p">)</span> <span class="p">{</span>
<a name="line-231"></a>    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">ec</span> <span class="o">=</span> <span class="n">exp</span><span class="p">[</span> <span class="n">neighborchare</span> <span class="p">];</span>
<a name="line-232"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">bndedges</span><span class="p">)</span>
<a name="line-233"></a>      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">d</span> <span class="p">:</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span><span class="n">m_edgech</span><span class="p">,</span><span class="n">e</span><span class="p">))</span>
<a name="line-234"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">!=</span> <span class="n">neighborchare</span><span class="p">)</span>
<a name="line-235"></a>          <span class="n">ec</span><span class="p">[</span><span class="n">d</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">edge</span> <span class="o">&gt;</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span> <span class="n">e</span> <span class="p">);</span>
<a name="line-236"></a>  <span class="p">}</span>
<a name="line-237"></a>
<a name="line-238"></a>  <span class="c1">// Send communication maps to chares that issued a query to us. Communication</span>
<a name="line-239"></a>  <span class="c1">// maps were computed above for those chares that queried this map from us.</span>
<a name="line-240"></a>  <span class="c1">// This data form a distributed table and we only work on a chunk of it. Note</span>
<a name="line-241"></a>  <span class="c1">// that we only send data back to those chares that have queried us. The</span>
<a name="line-242"></a>  <span class="c1">// receiving sides do not know in advance if the receive messages or not.</span>
<a name="line-243"></a>  <span class="c1">// Completion is detected by having the receiver respond back and counting</span>
<a name="line-244"></a>  <span class="c1">// the responses on the sender side, i.e., this chare.</span>
<a name="line-245"></a>  <span class="n">m_nbnd</span> <span class="o">=</span> <span class="n">exp</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<a name="line-246"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">m_nbnd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<a name="line-247"></a>    <span class="n">contribute</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">m_meshid</span><span class="p">,</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">nop</span><span class="p">,</span>
<a name="line-248"></a>                <span class="n">m_cbs</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">responded</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
<a name="line-249"></a>  <span class="k">else</span>
<a name="line-250"></a>    <span class="nf">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span> <span class="n">targetchare</span><span class="p">,</span> <span class="n">maps</span> <span class="p">]</span> <span class="o">:</span> <span class="n">exp</span><span class="p">)</span>
<a name="line-251"></a>      <span class="n">thisProxy</span><span class="p">[</span> <span class="n">targetchare</span> <span class="p">].</span><span class="n">bnd</span><span class="p">(</span> <span class="n">thisIndex</span><span class="p">,</span> <span class="n">maps</span> <span class="p">);</span>
<a name="line-252"></a><span class="p">}</span>
<a name="line-253"></a>
<a name="line-254"></a><span class="kt">void</span>
<a name="line-255"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">bnd</span><span class="p">(</span> <span class="kt">int</span> <span class="n">fromch</span><span class="p">,</span> <span class="k">const</span> <span class="n">tk</span><span class="o">::</span><span class="n">CommMaps</span><span class="o">&amp;</span> <span class="n">msum</span> <span class="p">)</span>
<a name="line-256"></a><span class="c1">// *****************************************************************************</span>
<a name="line-257"></a><span class="c1">// Receive boundary node communication maps for our mesh chunk</span>
<a name="line-258"></a><span class="c1">//! \param[in] fromch Sender chare ID</span>
<a name="line-259"></a><span class="c1">//! \param[in] msum Communication map(s) assembled by chare fromch</span>
<a name="line-260"></a><span class="c1">// *****************************************************************************</span>
<a name="line-261"></a><span class="p">{</span>
<a name="line-262"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span> <span class="n">neighborchare</span><span class="p">,</span> <span class="n">maps</span> <span class="p">]</span> <span class="o">:</span> <span class="n">msum</span><span class="p">)</span> <span class="p">{</span>
<a name="line-263"></a>    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">m_msum</span><span class="p">[</span> <span class="n">neighborchare</span> <span class="p">];</span>
<a name="line-264"></a>    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">nodemap</span> <span class="o">=</span> <span class="n">maps</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">node</span> <span class="o">&gt;</span><span class="p">();</span>
<a name="line-265"></a>    <span class="n">m</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">node</span> <span class="o">&gt;</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">nodemap</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">nodemap</span><span class="p">)</span> <span class="p">);</span>
<a name="line-266"></a>    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">edgemap</span> <span class="o">=</span> <span class="n">maps</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">edge</span> <span class="o">&gt;</span><span class="p">();</span>
<a name="line-267"></a>    <span class="n">m</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">edge</span> <span class="o">&gt;</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">edgemap</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">edgemap</span><span class="p">)</span> <span class="p">);</span>
<a name="line-268"></a>  <span class="p">}</span>
<a name="line-269"></a>
<a name="line-270"></a>  <span class="c1">// Report back to chare message received from</span>
<a name="line-271"></a>  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">fromch</span> <span class="p">].</span><span class="n">recvbnd</span><span class="p">();</span>
<a name="line-272"></a><span class="p">}</span>
<a name="line-273"></a>
<a name="line-274"></a><span class="kt">void</span>
<a name="line-275"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">recvbnd</span><span class="p">()</span>
<a name="line-276"></a><span class="c1">// *****************************************************************************</span>
<a name="line-277"></a><span class="c1">// Receive receipt of boundary node communication map</span>
<a name="line-278"></a><span class="c1">// *****************************************************************************</span>
<a name="line-279"></a><span class="p">{</span>
<a name="line-280"></a>  <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">m_nbnd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<a name="line-281"></a>    <span class="n">contribute</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">m_meshid</span><span class="p">,</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">nop</span><span class="p">,</span>
<a name="line-282"></a>                <span class="n">m_cbs</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">responded</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
<a name="line-283"></a><span class="p">}</span>
<a name="line-284"></a>
<a name="line-285"></a><span class="kt">void</span>
<a name="line-286"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">start</span><span class="p">()</span>
<a name="line-287"></a><span class="c1">// *****************************************************************************</span>
<a name="line-288"></a><span class="c1">//  Start reordering (if enabled)</span>
<a name="line-289"></a><span class="c1">// *****************************************************************************</span>
<a name="line-290"></a><span class="p">{</span>
<a name="line-291"></a>  <span class="c1">// Keep only those edges in edge comm map whose both end-points are in the</span>
<a name="line-292"></a>  <span class="c1">// node comm map</span>
<a name="line-293"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span> <span class="n">neighborchare</span><span class="p">,</span> <span class="n">maps</span> <span class="p">]</span> <span class="o">:</span> <span class="n">m_msum</span><span class="p">)</span> <span class="p">{</span>
<a name="line-294"></a>    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">maps</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">node</span> <span class="o">&gt;</span><span class="p">();</span>
<a name="line-295"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">EdgeSet</span> <span class="n">edges</span><span class="p">;</span>
<a name="line-296"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">maps</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">edge</span> <span class="o">&gt;</span><span class="p">())</span>
<a name="line-297"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nodes</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
<a name="line-298"></a>        <span class="n">edges</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">e</span> <span class="p">);</span>
<a name="line-299"></a>    <span class="n">maps</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">edge</span> <span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">edges</span><span class="p">);</span>
<a name="line-300"></a>  <span class="p">}</span>
<a name="line-301"></a>
<a name="line-302"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">feedback</span> <span class="o">&gt;</span><span class="p">())</span> <span class="n">m_host</span><span class="p">.</span><span class="n">chcomm</span><span class="p">();</span>
<a name="line-303"></a>
<a name="line-304"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_nodech</span> <span class="p">);</span>
<a name="line-305"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_chnode</span> <span class="p">);</span>
<a name="line-306"></a>
<a name="line-307"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">discr</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">pelocal_reorder</span> <span class="o">&gt;</span><span class="p">())</span>
<a name="line-308"></a>    <span class="n">mask</span><span class="p">();</span>   <span class="c1">// continue with mesh node reordering if requested (or required)</span>
<a name="line-309"></a>  <span class="k">else</span>
<a name="line-310"></a>    <span class="nf">createDiscWorkers</span><span class="p">();</span>  <span class="c1">// skip mesh node reordering</span>
<a name="line-311"></a><span class="p">}</span>
<a name="line-312"></a>
<a name="line-313"></a><span class="kt">void</span>
<a name="line-314"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">mask</span><span class="p">()</span>
<a name="line-315"></a><span class="c1">// *****************************************************************************</span>
<a name="line-316"></a><span class="c1">//  Start preparing for mesh node reordering in parallel</span>
<a name="line-317"></a><span class="c1">// *****************************************************************************</span>
<a name="line-318"></a><span class="p">{</span>
<a name="line-319"></a>  <span class="c1">// Compute asymmetric communcation map that will be used for reordering. This</span>
<a name="line-320"></a>  <span class="c1">// communication map is asymmetric because it associates global mesh node IDs</span>
<a name="line-321"></a>  <span class="c1">// to chares only with lower IDs than thisIndex. That is because this chare</span>
<a name="line-322"></a>  <span class="c1">// will need to receive new (reorderd) node IDs only from chares with lower</span>
<a name="line-323"></a>  <span class="c1">// IDs than thisIndex during node reordering. Since it only stores data for</span>
<a name="line-324"></a>  <span class="c1">// lower chare IDs, it is asymmetric. Note that because of this algorithm the</span>
<a name="line-325"></a>  <span class="c1">// type of m_msum is an ordered map, because of the std::none_of() algorithm</span>
<a name="line-326"></a>  <span class="c1">// needs to look at ALL chares this chare potentially communicates nodes with</span>
<a name="line-327"></a>  <span class="c1">// that have lower chare IDs that thisIndex. Since the map is ordered, it can</span>
<a name="line-328"></a>  <span class="c1">// walk through from the beginning of m_msum until the outer loop variable c,</span>
<a name="line-329"></a>  <span class="c1">// which is the chare ID the outer loop works on in a given cycle.</span>
<a name="line-330"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">c</span><span class="o">=</span><span class="n">m_msum</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="n">c</span><span class="o">!=</span><span class="n">m_msum</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span>
<a name="line-331"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">thisIndex</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
<a name="line-332"></a>      <span class="k">auto</span><span class="o">&amp;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m_reordcomm</span><span class="p">[</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">first</span> <span class="p">];</span>
<a name="line-333"></a>      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">j</span> <span class="p">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">node</span> <span class="o">&gt;</span><span class="p">())</span>
<a name="line-334"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">none_of</span><span class="p">(</span> <span class="n">m_msum</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">c</span><span class="p">,</span>
<a name="line-335"></a>             <span class="p">[</span><span class="n">j</span><span class="p">](</span> <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">s</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-336"></a>               <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">nodemap</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">node</span> <span class="o">&gt;</span><span class="p">();</span>
<a name="line-337"></a>               <span class="k">return</span> <span class="n">nodemap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">nodemap</span><span class="p">);</span> <span class="p">}</span> <span class="p">))</span>
<a name="line-338"></a>        <span class="p">{</span>
<a name="line-339"></a>          <span class="n">n</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
<a name="line-340"></a>        <span class="p">}</span>
<a name="line-341"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">m_reordcomm</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">first</span> <span class="p">);</span>
<a name="line-342"></a>    <span class="p">}</span>
<a name="line-343"></a>
<a name="line-344"></a>  <span class="c1">// Count up total number of nodes this chare will need to receive</span>
<a name="line-345"></a>  <span class="k">auto</span> <span class="n">nrecv</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">sumvalsize</span><span class="p">(</span> <span class="n">m_reordcomm</span> <span class="p">);</span>
<a name="line-346"></a>
<a name="line-347"></a>  <span class="k">if</span> <span class="p">(</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">feedback</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">)</span> <span class="n">m_host</span><span class="p">.</span><span class="n">chmask</span><span class="p">();</span>
<a name="line-348"></a>
<a name="line-349"></a>  <span class="c1">// Compute number of mesh node IDs we will assign IDs to</span>
<a name="line-350"></a>  <span class="k">auto</span> <span class="n">nuniq</span> <span class="o">=</span> <span class="n">m_nodeset</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">nrecv</span><span class="p">;</span>
<a name="line-351"></a>
<a name="line-352"></a>  <span class="c1">// Start computing offsets for node reordering</span>
<a name="line-353"></a>  <span class="n">thisProxy</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span> <span class="n">thisIndex</span><span class="p">,</span> <span class="n">nuniq</span> <span class="p">);</span>
<a name="line-354"></a><span class="p">}</span>
<a name="line-355"></a>
<a name="line-356"></a><span class="kt">void</span>
<a name="line-357"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">offset</span><span class="p">(</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">u</span> <span class="p">)</span>
<a name="line-358"></a><span class="c1">// *****************************************************************************</span>
<a name="line-359"></a><span class="c1">//  Receive number of uniquely assigned global mesh node IDs from chares with</span>
<a name="line-360"></a><span class="c1">//  lower IDs than thisIndex</span>
<a name="line-361"></a><span class="c1">//! \param[in] c Chare ID</span>
<a name="line-362"></a><span class="c1">//! \param[in] u Number of mesh node IDs chare c will assign IDs to</span>
<a name="line-363"></a><span class="c1">//! \details This function computes the offset each chare will need to start</span>
<a name="line-364"></a><span class="c1">//!   assigning its new node IDs from. The offset for a chare is the</span>
<a name="line-365"></a><span class="c1">//!   offset for the previous chare plus the number of node IDs the previous</span>
<a name="line-366"></a><span class="c1">//!   chare (uniquely) assigns new IDs for minus the number of node IDs the</span>
<a name="line-367"></a><span class="c1">//!   previous chare receives from others (lower chares). This is computed here</span>
<a name="line-368"></a><span class="c1">//!   in a parallel/distributed fashion by each chare sending its number of node</span>
<a name="line-369"></a><span class="c1">//!   IDs (that it uniquely assigns) to all chares. Note that each chare would</span>
<a name="line-370"></a><span class="c1">//!   only need to send this information to chares with higher IDs, but instead</span>
<a name="line-371"></a><span class="c1">//!   this function is called in a broadcast fashion, because that is more</span>
<a name="line-372"></a><span class="c1">//!   efficient than individual calls to only chares with higher IDs. Therefore</span>
<a name="line-373"></a><span class="c1">//!   when computing the offsets, we only count the lower chares. When this is</span>
<a name="line-374"></a><span class="c1">//!   done, we have the precise asymmetric communication map as well as the</span>
<a name="line-375"></a><span class="c1">//!   start offset on all chares and so we can start the distributed global mesh</span>
<a name="line-376"></a><span class="c1">//!   node ID reordering.</span>
<a name="line-377"></a><span class="c1">// *****************************************************************************</span>
<a name="line-378"></a><span class="p">{</span>
<a name="line-379"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">thisIndex</span><span class="p">)</span> <span class="n">m_start</span> <span class="o">+=</span> <span class="n">u</span><span class="p">;</span>
<a name="line-380"></a>  <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">m_noffset</span> <span class="o">==</span> <span class="n">m_nchare</span><span class="p">)</span> <span class="n">reorder</span><span class="p">();</span>
<a name="line-381"></a><span class="p">}</span>
<a name="line-382"></a>
<a name="line-383"></a><span class="kt">void</span>
<a name="line-384"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">reorder</span><span class="p">()</span>
<a name="line-385"></a><span class="c1">// *****************************************************************************</span>
<a name="line-386"></a><span class="c1">//  Reorder global mesh node IDs</span>
<a name="line-387"></a><span class="c1">// *****************************************************************************</span>
<a name="line-388"></a><span class="p">{</span>
<a name="line-389"></a>  <span class="c1">// Activate SDAG waits for arriving requests from other chares requesting new</span>
<a name="line-390"></a>  <span class="c1">// node IDs for node IDs we assign new IDs to during reordering; and for</span>
<a name="line-391"></a>  <span class="c1">// computing/receiving lower and upper bounds of global node IDs our chare&#39;s</span>
<a name="line-392"></a>  <span class="c1">// linear system will operate on after reordering.</span>
<a name="line-393"></a>  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4prep</span><span class="p">();</span>
<a name="line-394"></a>
<a name="line-395"></a>  <span class="c1">// Send out request for new global node IDs for nodes we do not reorder</span>
<a name="line-396"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span> <span class="n">targetchare</span><span class="p">,</span> <span class="n">nodes</span> <span class="p">]</span> <span class="o">:</span> <span class="n">m_reordcomm</span><span class="p">)</span>
<a name="line-397"></a>    <span class="n">thisProxy</span><span class="p">[</span> <span class="n">targetchare</span> <span class="p">].</span><span class="n">request</span><span class="p">(</span> <span class="n">thisIndex</span><span class="p">,</span> <span class="n">nodes</span> <span class="p">);</span>
<a name="line-398"></a>
<a name="line-399"></a>  <span class="c1">// Lambda to decide if node is assigned a new ID by this chare. If node is not</span>
<a name="line-400"></a>  <span class="c1">// found in the asymmetric communication map, it is owned, i.e., this chare</span>
<a name="line-401"></a>  <span class="c1">// assigns its new id.</span>
<a name="line-402"></a>  <span class="k">auto</span> <span class="n">ownnode</span> <span class="o">=</span> <span class="p">[</span> <span class="k">this</span> <span class="p">](</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">p</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-403"></a>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span> <span class="n">m_reordcomm</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">m_reordcomm</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span>
<a name="line-404"></a>                        <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
<a name="line-405"></a>                        <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="p">}</span> <span class="p">);</span>
<a name="line-406"></a>  <span class="p">};</span>
<a name="line-407"></a>
<a name="line-408"></a>  <span class="c1">// Reorder our chunk of the mesh node IDs. Looping through all of our node</span>
<a name="line-409"></a>  <span class="c1">// IDs, we test if we are to assign a new ID to a node ID, and if so, we</span>
<a name="line-410"></a>  <span class="c1">// assign a new ID, i.e., reorder, by constructing a map associating new to</span>
<a name="line-411"></a>  <span class="c1">// old IDs (m_newnodes). We also count up the reordered nodes, which serves as</span>
<a name="line-412"></a>  <span class="c1">// the new node id. We also store the node coordinates associated to the new</span>
<a name="line-413"></a>  <span class="c1">// node ID.</span>
<a name="line-414"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">m_nodeset</span><span class="p">)</span>
<a name="line-415"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">ownnode</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<a name="line-416"></a>      <span class="n">m_newnodes</span><span class="p">[</span> <span class="n">p</span> <span class="p">]</span> <span class="o">=</span> <span class="n">m_start</span><span class="p">;</span>        <span class="c1">// assign new node ID (reorder)</span>
<a name="line-417"></a>      <span class="n">m_newcoordmap</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span> <span class="n">m_start</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span><span class="n">m_coordmap</span><span class="p">,</span><span class="n">p</span><span class="p">)</span> <span class="p">);</span>
<a name="line-418"></a>      <span class="o">++</span><span class="n">m_start</span><span class="p">;</span>
<a name="line-419"></a>    <span class="p">}</span>
<a name="line-420"></a>
<a name="line-421"></a>  <span class="c1">// Trigger SDAG wait indicating that reordering our node IDs are complete</span>
<a name="line-422"></a>  <span class="n">reorderowned_complete</span><span class="p">();</span>
<a name="line-423"></a>
<a name="line-424"></a>  <span class="c1">// If all our nodes have new IDs assigned, reordering complete on this chare</span>
<a name="line-425"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">m_newnodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">m_nodeset</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">finish</span><span class="p">();</span>
<a name="line-426"></a><span class="p">}</span>
<a name="line-427"></a>
<a name="line-428"></a><span class="kt">void</span>
<a name="line-429"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">request</span><span class="p">(</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">nd</span> <span class="p">)</span>
<a name="line-430"></a><span class="c1">// *****************************************************************************</span>
<a name="line-431"></a><span class="c1">//  Request new global node IDs for old node IDs</span>
<a name="line-432"></a><span class="c1">//! \param[in] c Chare request coming from and to which we send new IDs to</span>
<a name="line-433"></a><span class="c1">//! \param[in] nd Set of old node IDs whose new IDs are requested</span>
<a name="line-434"></a><span class="c1">// *****************************************************************************</span>
<a name="line-435"></a><span class="p">{</span>
<a name="line-436"></a>  <span class="c1">// Queue up requesting chare and node IDs</span>
<a name="line-437"></a>  <span class="n">m_reqnodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="p">{</span> <span class="n">c</span><span class="p">,</span> <span class="n">nd</span> <span class="p">}</span> <span class="p">);</span>
<a name="line-438"></a>  <span class="c1">// Trigger SDAG wait signaling that node IDs have been requested from us</span>
<a name="line-439"></a>  <span class="n">nodes_requested_complete</span><span class="p">();</span>
<a name="line-440"></a><span class="p">}</span>
<a name="line-441"></a>
<a name="line-442"></a><span class="kt">void</span>
<a name="line-443"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">prepare</span><span class="p">()</span>
<a name="line-444"></a><span class="c1">// *****************************************************************************</span>
<a name="line-445"></a><span class="c1">//  Find new node IDs for old ones and return them to the requestor(s)</span>
<a name="line-446"></a><span class="c1">// *****************************************************************************</span>
<a name="line-447"></a><span class="p">{</span>
<a name="line-448"></a>  <span class="c1">// Find and return new node IDs to sender</span>
<a name="line-449"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span> <span class="n">requestorchare</span><span class="p">,</span> <span class="n">nodes</span> <span class="p">]</span> <span class="o">:</span> <span class="n">m_reqnodes</span><span class="p">)</span> <span class="p">{</span>
<a name="line-450"></a>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span>
<a name="line-451"></a>      <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Coord</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">;</span>
<a name="line-452"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">nodes</span><span class="p">)</span> <span class="p">{</span>
<a name="line-453"></a>      <span class="k">auto</span> <span class="n">newid</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span> <span class="n">m_newnodes</span><span class="p">,</span> <span class="n">p</span> <span class="p">);</span>
<a name="line-454"></a>      <span class="n">n</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span> <span class="n">p</span><span class="p">,</span>
<a name="line-455"></a>        <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span> <span class="n">newid</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span><span class="n">m_newcoordmap</span><span class="p">,</span><span class="n">newid</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
<a name="line-456"></a>    <span class="p">}</span>
<a name="line-457"></a>    <span class="n">thisProxy</span><span class="p">[</span> <span class="n">requestorchare</span> <span class="p">].</span><span class="n">neworder</span><span class="p">(</span> <span class="n">n</span> <span class="p">);</span>
<a name="line-458"></a>  <span class="p">}</span>
<a name="line-459"></a>
<a name="line-460"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_reqnodes</span> <span class="p">);</span> <span class="c1">// Clear queue of requests just fulfilled</span>
<a name="line-461"></a>
<a name="line-462"></a>  <span class="c1">// Re-enable SDAG wait for preparing new node requests</span>
<a name="line-463"></a>  <span class="n">thisProxy</span><span class="p">[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">wait4prep</span><span class="p">();</span>
<a name="line-464"></a>
<a name="line-465"></a>  <span class="c1">// Re-enable trigger signaling that reordering of owned node IDs are</span>
<a name="line-466"></a>  <span class="c1">// complete right away</span>
<a name="line-467"></a>  <span class="n">reorderowned_complete</span><span class="p">();</span>
<a name="line-468"></a><span class="p">}</span>
<a name="line-469"></a>
<a name="line-470"></a><span class="kt">void</span>
<a name="line-471"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">neworder</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span>
<a name="line-472"></a>                        <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">Coord</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">nodes</span> <span class="p">)</span>
<a name="line-473"></a><span class="c1">// *****************************************************************************</span>
<a name="line-474"></a><span class="c1">//  Receive new (reordered) global node IDs</span>
<a name="line-475"></a><span class="c1">//! \param[in] nodes Map associating new to old node IDs</span>
<a name="line-476"></a><span class="c1">// *****************************************************************************</span>
<a name="line-477"></a><span class="p">{</span>
<a name="line-478"></a>  <span class="c1">// Store new node IDs associated to old ones, and node coordinates associated</span>
<a name="line-479"></a>  <span class="c1">// to new node IDs.</span>
<a name="line-480"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span> <span class="n">oldid</span><span class="p">,</span> <span class="n">newnodes</span> <span class="p">]</span> <span class="o">:</span> <span class="n">nodes</span><span class="p">)</span> <span class="p">{</span>
<a name="line-481"></a>    <span class="k">auto</span> <span class="n">newid</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">newnodes</span> <span class="p">);</span>
<a name="line-482"></a>    <span class="n">m_newnodes</span><span class="p">[</span> <span class="n">oldid</span> <span class="p">]</span> <span class="o">=</span> <span class="n">newid</span><span class="p">;</span>
<a name="line-483"></a>    <span class="n">m_newcoordmap</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span> <span class="n">newid</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">newnodes</span> <span class="p">)</span> <span class="p">);</span>
<a name="line-484"></a>  <span class="p">}</span>
<a name="line-485"></a>
<a name="line-486"></a>  <span class="c1">// If all our nodes have new IDs assigned, reorder complete on this PE</span>
<a name="line-487"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">m_newnodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">m_nodeset</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">finish</span><span class="p">();</span>
<a name="line-488"></a><span class="p">}</span>
<a name="line-489"></a>
<a name="line-490"></a><span class="kt">void</span>
<a name="line-491"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">finish</span><span class="p">()</span>
<a name="line-492"></a><span class="c1">// *****************************************************************************</span>
<a name="line-493"></a><span class="c1">//  Compute final result of reordering</span>
<a name="line-494"></a><span class="c1">//! \details Reordering is now complete on this chare. We now remap all mesh</span>
<a name="line-495"></a><span class="c1">//!   data to reflect the new ordering.</span>
<a name="line-496"></a><span class="c1">// *****************************************************************************</span>
<a name="line-497"></a><span class="p">{</span>
<a name="line-498"></a>  <span class="c1">// Update elem connectivity with the reordered node IDs</span>
<a name="line-499"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">remap</span><span class="p">(</span> <span class="n">m_ginpoel</span><span class="p">,</span> <span class="n">m_newnodes</span> <span class="p">);</span>
<a name="line-500"></a>
<a name="line-501"></a>  <span class="c1">// Update node coordinate map with the reordered IDs</span>
<a name="line-502"></a>  <span class="n">m_coordmap</span> <span class="o">=</span> <span class="n">m_newcoordmap</span><span class="p">;</span>
<a name="line-503"></a>
<a name="line-504"></a>  <span class="c1">// Update mesh chunk data structure held in our state with new node order</span>
<a name="line-505"></a>  <span class="n">m_el</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">global2local</span><span class="p">(</span> <span class="n">m_ginpoel</span> <span class="p">);</span>
<a name="line-506"></a>
<a name="line-507"></a>  <span class="c1">// Update symmetric chare-node communication map with the reordered IDs</span>
<a name="line-508"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span> <span class="n">neighborchare</span><span class="p">,</span> <span class="n">maps</span> <span class="p">]</span> <span class="o">:</span> <span class="n">m_msum</span><span class="p">)</span> <span class="p">{</span>
<a name="line-509"></a>
<a name="line-510"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">NodeSet</span> <span class="n">n</span><span class="p">;</span>
<a name="line-511"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">maps</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">node</span> <span class="o">&gt;</span><span class="p">())</span>
<a name="line-512"></a>      <span class="n">n</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span> <span class="n">m_newnodes</span><span class="p">,</span> <span class="n">p</span> <span class="p">)</span> <span class="p">);</span>
<a name="line-513"></a>    <span class="n">maps</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">node</span> <span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">n</span> <span class="p">);</span>
<a name="line-514"></a>
<a name="line-515"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">EdgeSet</span> <span class="n">e</span><span class="p">;</span>
<a name="line-516"></a>    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">ed</span> <span class="p">:</span> <span class="n">maps</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">edge</span> <span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
<a name="line-517"></a>      <span class="n">e</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="p">{</span> <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span><span class="n">m_newnodes</span><span class="p">,</span><span class="n">ed</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
<a name="line-518"></a>                  <span class="n">tk</span><span class="o">::</span><span class="n">cref_find</span><span class="p">(</span><span class="n">m_newnodes</span><span class="p">,</span><span class="n">ed</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">}</span> <span class="p">);</span>
<a name="line-519"></a>    <span class="p">}</span>
<a name="line-520"></a>    <span class="n">maps</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">edge</span> <span class="o">&gt;</span><span class="p">()</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">e</span> <span class="p">);</span>
<a name="line-521"></a>
<a name="line-522"></a>  <span class="p">}</span>
<a name="line-523"></a>
<a name="line-524"></a>  <span class="c1">// Update boundary face-node connectivity with the reordered node IDs</span>
<a name="line-525"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">remap</span><span class="p">(</span> <span class="n">m_triinpoel</span><span class="p">,</span> <span class="n">m_newnodes</span> <span class="p">);</span>
<a name="line-526"></a>
<a name="line-527"></a>  <span class="c1">// Update boundary node lists with the reordered node IDs</span>
<a name="line-528"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span> <span class="n">setid</span><span class="p">,</span> <span class="n">nodes</span> <span class="p">]</span> <span class="o">:</span> <span class="n">m_bnode</span><span class="p">)</span> <span class="n">tk</span><span class="o">::</span><span class="n">remap</span><span class="p">(</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">m_newnodes</span> <span class="p">);</span>
<a name="line-529"></a>
<a name="line-530"></a>  <span class="c1">// Update mesh in Refiner after reordering</span>
<a name="line-531"></a>  <span class="n">m_reorderRefiner</span><span class="p">.</span><span class="n">send</span><span class="p">();</span>
<a name="line-532"></a>
<a name="line-533"></a>  <span class="c1">// Progress report to host</span>
<a name="line-534"></a>  <span class="k">if</span> <span class="p">(</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">feedback</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">)</span> <span class="n">m_host</span><span class="p">.</span><span class="n">chreordered</span><span class="p">();</span>
<a name="line-535"></a>
<a name="line-536"></a>  <span class="n">createDiscWorkers</span><span class="p">();</span>
<a name="line-537"></a><span class="p">}</span>
<a name="line-538"></a>
<a name="line-539"></a><span class="kt">void</span>
<a name="line-540"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">mesh</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">ginpoel</span><span class="p">,</span>
<a name="line-541"></a>              <span class="n">tk</span><span class="o">::</span><span class="n">UnsMesh</span><span class="o">::</span><span class="n">CoordMap</span><span class="o">&amp;</span> <span class="n">coordmap</span><span class="p">,</span>
<a name="line-542"></a>              <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;&amp;</span> <span class="n">triinpoel</span><span class="p">,</span>
<a name="line-543"></a>              <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">bnode</span> <span class="p">)</span>
<a name="line-544"></a><span class="c1">// *****************************************************************************</span>
<a name="line-545"></a><span class="c1">// Update mesh data we hold for whoever calls this function</span>
<a name="line-546"></a><span class="c1">//! \param[in,out] ginpoel Mesh connectivity using global IDs</span>
<a name="line-547"></a><span class="c1">//! \param[in,out] coordmap Map of mesh node coordinates</span>
<a name="line-548"></a><span class="c1">//! \param[in,out] triinpoel Boundary face-node connectivity</span>
<a name="line-549"></a><span class="c1">//! \param[in] bnode Node lists of side sets</span>
<a name="line-550"></a><span class="c1">// *****************************************************************************</span>
<a name="line-551"></a><span class="p">{</span>
<a name="line-552"></a>  <span class="n">ginpoel</span> <span class="o">=</span> <span class="n">m_ginpoel</span><span class="p">;</span>
<a name="line-553"></a>  <span class="n">coordmap</span> <span class="o">=</span> <span class="n">m_coordmap</span><span class="p">;</span>
<a name="line-554"></a>  <span class="n">triinpoel</span> <span class="o">=</span> <span class="n">m_triinpoel</span><span class="p">;</span>
<a name="line-555"></a>  <span class="n">bnode</span> <span class="o">=</span> <span class="n">m_bnode</span><span class="p">;</span>
<a name="line-556"></a><span class="p">}</span>
<a name="line-557"></a>
<a name="line-558"></a><span class="kt">void</span>
<a name="line-559"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">createDiscWorkers</span><span class="p">()</span>
<a name="line-560"></a><span class="c1">// *****************************************************************************</span>
<a name="line-561"></a><span class="c1">//  Create Discretization chare array elements on this PE</span>
<a name="line-562"></a><span class="c1">//! \details We create chare array elements by calling the insert() member</span>
<a name="line-563"></a><span class="c1">//!   function, which allows specifying the PE on which the array element is</span>
<a name="line-564"></a><span class="c1">//!   created. and we send each chare array element the chunk of mesh it will</span>
<a name="line-565"></a><span class="c1">//!   operate on.</span>
<a name="line-566"></a><span class="c1">// *****************************************************************************</span>
<a name="line-567"></a><span class="p">{</span>
<a name="line-568"></a>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">CProxy_Discretization</span> <span class="o">&gt;</span> <span class="n">disc</span><span class="p">;</span>
<a name="line-569"></a><span class="hll">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">d</span> <span class="p">:</span> <span class="n">m_scheme</span><span class="p">)</span> <span class="n">disc</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">d</span><span class="p">.</span><span class="n">disc</span><span class="p">()</span> <span class="p">);</span><span class="error2">&lt;--- Consider using std::transform algorithm instead of a raw loop.</span>
</span><a name="line-570"></a>
<a name="line-571"></a>  <span class="c1">// Create worker array element using Charm++ dynamic chare array element</span>
<a name="line-572"></a>  <span class="c1">// insertion: last arg: PE chare is created on. See also Charm++ manual, Sec.</span>
<a name="line-573"></a>  <span class="c1">// &quot;Dynamic Insertion&quot;.</span>
<a name="line-574"></a>
<a name="line-575"></a>  <span class="n">m_scheme</span><span class="p">[</span><span class="n">m_meshid</span><span class="p">].</span><span class="n">disc</span><span class="p">()[</span> <span class="n">thisIndex</span> <span class="p">].</span><span class="n">insert</span><span class="p">(</span> <span class="n">m_meshid</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span>
<a name="line-576"></a>    <span class="n">m_scheme</span><span class="p">[</span><span class="n">m_meshid</span><span class="p">].</span><span class="n">fct</span><span class="p">(),</span> <span class="n">m_scheme</span><span class="p">[</span><span class="n">m_meshid</span><span class="p">].</span><span class="n">ale</span><span class="p">(),</span>
<a name="line-577"></a>    <span class="n">m_scheme</span><span class="p">[</span><span class="n">m_meshid</span><span class="p">].</span><span class="n">conjugategradients</span><span class="p">(),</span> <span class="n">m_host</span><span class="p">,</span> <span class="n">m_meshwriter</span><span class="p">,</span> <span class="n">m_coordmap</span><span class="p">,</span>
<a name="line-578"></a>    <span class="n">m_el</span><span class="p">,</span> <span class="n">m_msum</span><span class="p">,</span> <span class="n">m_bface</span><span class="p">,</span> <span class="n">m_triinpoel</span><span class="p">,</span> <span class="n">m_elemblockid</span><span class="p">,</span> <span class="n">m_nchare</span> <span class="p">);</span>
<a name="line-579"></a>
<a name="line-580"></a>  <span class="n">contribute</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">m_meshid</span><span class="p">,</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">nop</span><span class="p">,</span>
<a name="line-581"></a>              <span class="n">m_cbs</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">discinserted</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
<a name="line-582"></a><span class="p">}</span>
<a name="line-583"></a>
<a name="line-584"></a><span class="kt">void</span>
<a name="line-585"></a><span class="n">Sorter</span><span class="o">::</span><span class="n">createWorkers</span><span class="p">()</span>
<a name="line-586"></a><span class="c1">// *****************************************************************************</span>
<a name="line-587"></a><span class="c1">//  Create worker chare array element</span>
<a name="line-588"></a><span class="c1">// *****************************************************************************</span>
<a name="line-589"></a><span class="p">{</span>
<a name="line-590"></a>  <span class="c1">// Make sure (bound) base is already created and accessible</span>
<a name="line-591"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">m_scheme</span><span class="p">[</span><span class="n">m_meshid</span><span class="p">].</span><span class="n">disc</span><span class="p">()[</span><span class="n">thisIndex</span><span class="p">].</span><span class="n">ckLocal</span><span class="p">()</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">,</span>
<a name="line-592"></a>          <span class="s">&quot;About to pass nullptr&quot;</span> <span class="p">);</span>
<a name="line-593"></a>
<a name="line-594"></a>  <span class="c1">// Create worker array element using Charm++ dynamic chare array element</span>
<a name="line-595"></a>  <span class="c1">// insertion: 1st arg: chare id, other args: Discretization&#39;s child ctor args.</span>
<a name="line-596"></a>  <span class="c1">// See also Charm++ manual, Sec. &quot;Dynamic Insertion&quot;.</span>
<a name="line-597"></a>
<a name="line-598"></a>  <span class="n">m_scheme</span><span class="p">[</span><span class="n">m_meshid</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span> <span class="n">thisIndex</span><span class="p">,</span> <span class="n">m_scheme</span><span class="p">[</span><span class="n">m_meshid</span><span class="p">].</span><span class="n">disc</span><span class="p">(),</span>
<a name="line-599"></a>    <span class="n">m_scheme</span><span class="p">[</span><span class="n">m_meshid</span><span class="p">].</span><span class="n">ghosts</span><span class="p">(),</span> <span class="n">m_bface</span><span class="p">,</span> <span class="n">m_bnode</span><span class="p">,</span> <span class="n">m_triinpoel</span> <span class="p">);</span>
<a name="line-600"></a>
<a name="line-601"></a>  <span class="k">if</span> <span class="p">(</span> <span class="n">g_inputdeck</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">cmd</span><span class="p">,</span> <span class="n">tag</span><span class="o">::</span><span class="n">feedback</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">)</span> <span class="n">m_host</span><span class="p">.</span><span class="n">chcreated</span><span class="p">();</span>
<a name="line-602"></a>
<a name="line-603"></a>  <span class="n">contribute</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">m_meshid</span><span class="p">,</span> <span class="n">CkReduction</span><span class="o">::</span><span class="n">nop</span><span class="p">,</span>
<a name="line-604"></a>              <span class="n">m_cbs</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span> <span class="n">tag</span><span class="o">::</span><span class="n">workinserted</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
<a name="line-605"></a>
<a name="line-606"></a>  <span class="c1">// Free up some memory</span>
<a name="line-607"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_ginpoel</span> <span class="p">);</span>
<a name="line-608"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_coordmap</span> <span class="p">);</span>
<a name="line-609"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_bface</span> <span class="p">);</span>
<a name="line-610"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_triinpoel</span> <span class="p">);</span>
<a name="line-611"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_elemblockid</span> <span class="p">);</span>
<a name="line-612"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_bnode</span> <span class="p">);</span>
<a name="line-613"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_nodeset</span> <span class="p">);</span>
<a name="line-614"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_nodech</span> <span class="p">);</span>
<a name="line-615"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_chnode</span> <span class="p">);</span>
<a name="line-616"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_msum</span> <span class="p">);</span>
<a name="line-617"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_reordcomm</span> <span class="p">);</span>
<a name="line-618"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_newnodes</span> <span class="p">);</span>
<a name="line-619"></a>  <span class="n">tk</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span> <span class="n">m_reqnodes</span> <span class="p">);</span>
<a name="line-620"></a><span class="p">}</span>
<a name="line-621"></a>
<a name="line-622"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/sorter.def.h&quot;</span><span class="cp"></span>
</pre></div>
</td></tr></table>
      </div> <!-- /.wrapper -->
    </div>
    <div id="footer" class="footer">
      <p>
        Cppcheck 2.3 - a tool for static C/C++ code analysis<br>
        <br>
        Internet: <a href="http://cppcheck.net">http://cppcheck.net</a><br>
        IRC: <a href="irc://irc.freenode.net/cppcheck">irc://irc.freenode.net/cppcheck</a><br>
      </p>
    </div>
  </body>
</html>
