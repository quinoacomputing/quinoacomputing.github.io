
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cppcheck - HTML report - [<a href=https://github.com/quinoacomputing/quinoa/commit/-128-NOTFOUND>-128-NOTFOUND</a>]</title>
    <link rel="stylesheet" href="style.css">
    <style>
pre { line-height: 125%; margin: 0; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .ch { color: #888888 } /* Comment.Hashbang */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .cpf { color: #888888 } /* Comment.PreprocFile */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { background-color: #fff0f0 } /* Literal.String.Affix */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .vm { color: #996633 } /* Name.Variable.Magic */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
    </style>
    <script>
      function getStyle(el, styleProp) {
        var y;

        if (el.currentStyle) {
          y = el.currentStyle[styleProp];
        } else if (window.getComputedStyle) {
          y = document.defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);
        }

        return y;
      }

      function toggle() {
        var el = this.expandable_content;
        var mark = this.expandable_marker;

        if (el.style.display === "block") {
          el.style.display = "none";
          mark.textContent = "[+]";
        } else {
          el.style.display = "block";
          mark.textContent = "[-]";
        }
      }

      function initExpandables() {
        var elements = document.querySelectorAll(".expandable");

        for (var i = 0, len = elements.length; i < len; i++) {
          var el = elements[i];
          var clickable = el.querySelector("span");
          var marker = clickable.querySelector(".marker");
          var content = el.querySelector(".content");
          var width = clickable.clientWidth - parseInt(getStyle(content, "padding-left")) - parseInt(getStyle(content, "padding-right"));
          content.style.width = width + "px";
          clickable.expandable_content = content;
          clickable.expandable_marker = marker;
          clickable.addEventListener("click", toggle);
        }
      }

      function toggleDisplay(id) {
        var elements = document.querySelectorAll("." + id);

        for (var i = 0, len = elements.length; i < len; i++) {
          elements[i].classList.toggle("d-none");
        }
      }

      function toggleAll() {
        var elements = document.querySelectorAll("input");

        // starting from 1 since 0 is the "toggle all" input
        for (var i = 1, len = elements.length; i < len; i++) {
          var el = elements[i];

          if (el.checked) {
            el.checked = false;
          } else {
            el.checked = true;
          }

          toggleDisplay(el.id);
        }
      }
      window.addEventListener("load", initExpandables);
    </script>
  </head>
  <body>
    <div id="header" class="header">
      <h1>Cppcheck report - [<a href=https://github.com/quinoacomputing/quinoa/commit/-128-NOTFOUND>-128-NOTFOUND</a>]: /tmp/TeamCity-1/work/5ad443c8abe7fc0a/src/Base/ContainerUtil.hpp</h1>
    </div>
    <div class="wrapper">
      <div id="menu">
       <p id="filename"><a href="index.html">Defects:</a> ContainerUtil.hpp</p>
<a href="6.html#line-38"> unsignedPositive 38</a><a href="6.html#line-66"> throwInNoexceptFunction 66</a><a href="6.html#line-81"> throwInNoexceptFunction 81</a>
    </div>
    <div id="content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331</pre></div></td><td class="code"><div class="highlight"><pre><span></span><a name="line-1"></a><span class="c1">// *****************************************************************************</span>
<a name="line-2"></a><span class="cm">/*!</span>
<a name="line-3"></a><span class="cm">  \file      src/Base/ContainerUtil.hpp</span>
<a name="line-4"></a><span class="cm">  \copyright 2012-2015 J. Bakosi,</span>
<a name="line-5"></a><span class="cm">             2016-2018 Los Alamos National Security, LLC.,</span>
<a name="line-6"></a><span class="cm">             2019-2021 Triad National Security, LLC.</span>
<a name="line-7"></a><span class="cm">             All rights reserved. See the LICENSE file for details.</span>
<a name="line-8"></a><span class="cm">  \brief     Various STL container utilities</span>
<a name="line-9"></a><span class="cm">  \details   Various STL container utilities.</span>
<a name="line-10"></a><span class="cm">*/</span>
<a name="line-11"></a><span class="c1">// *****************************************************************************</span>
<a name="line-12"></a><span class="cp">#ifndef ContainerUtil_h</span>
<a name="line-13"></a><span class="cp">#define ContainerUtil_h</span>
<a name="line-14"></a>
<a name="line-15"></a><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<a name="line-16"></a><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<a name="line-17"></a><span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<a name="line-18"></a><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<a name="line-19"></a><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<a name="line-20"></a><span class="cp">#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp"></span>
<a name="line-21"></a><span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp"></span>
<a name="line-22"></a><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<a name="line-23"></a><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<a name="line-24"></a>
<a name="line-25"></a><span class="cp">#include</span> <span class="cpf">&quot;Exception.hpp&quot;</span><span class="cp"></span>
<a name="line-26"></a>
<a name="line-27"></a><span class="k">namespace</span> <span class="n">tk</span> <span class="p">{</span>
<a name="line-28"></a>
<a name="line-29"></a><span class="c1">//! Make elements of container unique (in-place, overwriting source container)</span>
<a name="line-30"></a><span class="c1">//! \param[in,out] c Container</span>
<a name="line-31"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Container</span> <span class="o">&gt;</span>
<a name="line-32"></a><span class="kt">void</span>
<a name="line-33"></a><span class="n">unique</span><span class="p">(</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span> <span class="p">)</span>
<a name="line-34"></a><span class="p">{</span>
<a name="line-35"></a>  <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">);</span>
<a name="line-36"></a>  <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">);</span>
<a name="line-37"></a>  <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">it</span> <span class="p">);</span>
<a name="line-38"></a><span class="hll">  <span class="n">Assert</span><span class="p">(</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Distance must be non-negative in tk::unique()&quot;</span> <span class="p">);</span><span class="error2">&lt;--- Unsigned positive</span>
</span><a name="line-39"></a>  <span class="n">c</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span> <span class="p">);</span>
<a name="line-40"></a><span class="p">}</span>
<a name="line-41"></a>
<a name="line-42"></a><span class="c1">//! Make elements of container unique (on a copy, leaving the source as is)</span>
<a name="line-43"></a><span class="c1">//! \param[in] src Container</span>
<a name="line-44"></a><span class="c1">//! \return Container containing only unique elements compared to src</span>
<a name="line-45"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Container</span> <span class="o">&gt;</span>
<a name="line-46"></a><span class="n">Container</span>
<a name="line-47"></a><span class="n">uniquecopy</span><span class="p">(</span> <span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">src</span> <span class="p">)</span>
<a name="line-48"></a><span class="p">{</span>
<a name="line-49"></a>  <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
<a name="line-50"></a>  <span class="n">unique</span><span class="p">(</span> <span class="n">c</span> <span class="p">);</span>
<a name="line-51"></a>  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<a name="line-52"></a><span class="p">}</span>
<a name="line-53"></a>
<a name="line-54"></a><span class="c1">//! \brief Find and return a constant reference to value for key in container</span>
<a name="line-55"></a><span class="c1">//!   that provides a find() member function with error handling</span>
<a name="line-56"></a><span class="c1">//! \param[in] map Map associating values to keys</span>
<a name="line-57"></a><span class="c1">//! \param[in] key Key to search for</span>
<a name="line-58"></a><span class="c1">//! \return A constant reference to the value associated to the key in map</span>
<a name="line-59"></a><span class="c1">//! \note If key is not found an exception is thrown.</span>
<a name="line-60"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">Container</span> <span class="o">&gt;</span>
<a name="line-61"></a><span class="k">auto</span> <span class="n">cref_find</span><span class="p">(</span> <span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">map</span><span class="p">,</span> <span class="k">const</span> <span class="k">typename</span> <span class="nc">Container</span><span class="o">::</span><span class="n">key_type</span><span class="o">&amp;</span> <span class="n">key</span> <span class="p">)</span>
<a name="line-62"></a><span class="k">noexcept</span><span class="p">(</span><span class="n">ndebug</span><span class="p">)</span>
<a name="line-63"></a>  <span class="o">-&gt;</span> <span class="k">const</span> <span class="k">typename</span> <span class="nc">Container</span><span class="o">::</span><span class="n">mapped_type</span><span class="o">&amp;</span>
<a name="line-64"></a><span class="p">{</span>
<a name="line-65"></a>  <span class="k">const</span> <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">key</span> <span class="p">);</span>
<a name="line-66"></a><span class="hll">  <span class="n">Assert</span><span class="p">(</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">map</span><span class="p">),</span> <span class="s">&quot;Can&#39;t find key&quot;</span> <span class="p">);</span><span class="error2">&lt;--- Exception thrown in function declared not to throw exceptions.</span>
</span><a name="line-67"></a>  <span class="k">return</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<a name="line-68"></a><span class="p">}</span>
<a name="line-69"></a>
<a name="line-70"></a><span class="c1">//! \brief Find and return a reference to value for key in a container that</span>
<a name="line-71"></a><span class="c1">//!   provides a find() member function with error handling</span>
<a name="line-72"></a><span class="c1">//! \param[in] map Map associating values to keys</span>
<a name="line-73"></a><span class="c1">//! \param[in] key Key to search for</span>
<a name="line-74"></a><span class="c1">//! \return A reference to the value associated to the key in map</span>
<a name="line-75"></a><span class="c1">//! \note If key is not found an exception is thrown.</span>
<a name="line-76"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">Container</span> <span class="o">&gt;</span>
<a name="line-77"></a><span class="k">auto</span> <span class="n">ref_find</span><span class="p">(</span> <span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">map</span><span class="p">,</span> <span class="k">const</span> <span class="k">typename</span> <span class="nc">Container</span><span class="o">::</span><span class="n">key_type</span><span class="o">&amp;</span> <span class="n">key</span> <span class="p">)</span>
<a name="line-78"></a><span class="k">noexcept</span><span class="p">(</span><span class="n">ndebug</span><span class="p">)</span>
<a name="line-79"></a>  <span class="o">-&gt;</span> <span class="k">typename</span> <span class="nc">Container</span><span class="o">::</span><span class="n">mapped_type</span><span class="o">&amp;</span>
<a name="line-80"></a><span class="p">{</span>
<a name="line-81"></a><span class="hll">  <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">Container</span><span class="o">::</span><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">cref_find</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="p">);</span><span class="error2">&lt;--- Exception thrown in function declared not to throw exceptions.</span>
</span><a name="line-82"></a><span class="p">}</span>
<a name="line-83"></a>
<a name="line-84"></a><span class="c1">//! \brief Return minimum and maximum values of a vector</span>
<a name="line-85"></a><span class="c1">//! \param[in] vec Vector whose extents to compute</span>
<a name="line-86"></a><span class="c1">//! \return Array of two values with the minimum and maximum values</span>
<a name="line-87"></a><span class="c1">//! \note This function should not be called with heavy T types, as the a copy</span>
<a name="line-88"></a><span class="c1">//!   of a std::array&lt; T, 2 &gt; is created and returned.</span>
<a name="line-89"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">T</span> <span class="o">&gt;</span>
<a name="line-90"></a><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="mi">2</span> <span class="o">&gt;</span>
<a name="line-91"></a><span class="n">extents</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;&amp;</span> <span class="n">vec</span> <span class="p">)</span>
<a name="line-92"></a><span class="p">{</span>
<a name="line-93"></a>  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="p">);</span>
<a name="line-94"></a>  <span class="k">return</span> <span class="p">{{</span> <span class="o">*</span><span class="n">x</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">.</span><span class="n">second</span> <span class="p">}};</span>
<a name="line-95"></a><span class="p">}</span>
<a name="line-96"></a>
<a name="line-97"></a><span class="c1">//! \brief Find and return minimum and maximum values in associative container</span>
<a name="line-98"></a><span class="c1">//! \param[in] map Map whose extents of values to find </span>
<a name="line-99"></a><span class="c1">//! \return Array of two values with the minimum and maximum values in the map</span>
<a name="line-100"></a><span class="c1">//! \note This function should not be called with heavy Value types, as the a</span>
<a name="line-101"></a><span class="c1">//!   copy of a std::array&lt; Value, 2 &gt; is created and returned.</span>
<a name="line-102"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">Container</span> <span class="o">&gt;</span>
<a name="line-103"></a><span class="k">auto</span> <span class="n">extents</span><span class="p">(</span> <span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">map</span> <span class="p">)</span>
<a name="line-104"></a>  <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">Container</span><span class="o">::</span><span class="n">mapped_type</span><span class="p">,</span> <span class="mi">2</span> <span class="o">&gt;</span>
<a name="line-105"></a><span class="p">{</span>
<a name="line-106"></a>  <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">map</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">map</span><span class="p">),</span>
<a name="line-107"></a>             <span class="p">[](</span> <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">b</span> <span class="p">)</span>
<a name="line-108"></a>             <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
<a name="line-109"></a>  <span class="k">return</span> <span class="p">{{</span> <span class="n">x</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">second</span> <span class="p">}};</span>
<a name="line-110"></a><span class="p">}</span>
<a name="line-111"></a>
<a name="line-112"></a><span class="c1">//! Add all elements of an array to those of another one</span>
<a name="line-113"></a><span class="c1">//! \param[in,out] dst Destination array, i.e., left-hand side of a1 += a2</span>
<a name="line-114"></a><span class="c1">//! \param[in] src Source array, i.e., righ-hand side of a1 += a2</span>
<a name="line-115"></a><span class="c1">//! \return Destination containing a1[0] += a2[0], a1[1] += a2[1], ...</span>
<a name="line-116"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span> <span class="o">&gt;</span>
<a name="line-117"></a><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span> <span class="o">&gt;&amp;</span>
<a name="line-118"></a><span class="k">operator</span><span class="o">+=</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span> <span class="o">&gt;&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span> <span class="o">&gt;&amp;</span> <span class="n">src</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-119"></a>  <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">dst</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">dst</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
<a name="line-120"></a>                  <span class="p">[](</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">d</span> <span class="p">){</span> <span class="k">return</span> <span class="n">d</span> <span class="o">+=</span> <span class="n">s</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
<a name="line-121"></a>  <span class="k">return</span> <span class="n">dst</span><span class="p">;</span>
<a name="line-122"></a><span class="p">}</span>
<a name="line-123"></a>
<a name="line-124"></a><span class="c1">//! Add all elements of a vector to those of another one</span>
<a name="line-125"></a><span class="c1">//! \param[in,out] dst Destination vector, i.e., left-hand side of v1 += v2</span>
<a name="line-126"></a><span class="c1">//! \param[in] src Source vector, i.e., righ-hand side of v1 += v2</span>
<a name="line-127"></a><span class="c1">//! \return Destination containing v1[0] += v2[0], v1[1] += v2[1], ...</span>
<a name="line-128"></a><span class="c1">//! \details If src.size() &gt; dst.size() will grow dst to that of src.size()</span>
<a name="line-129"></a><span class="c1">//!   padding with zeros.</span>
<a name="line-130"></a><span class="c1">//! \note Will throw exception in DEBUG if src is empty (to warn on no-op), and</span>
<a name="line-131"></a><span class="c1">//!   if src.size() &lt; dst.size() (to warn on loosing data).</span>
<a name="line-132"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">&gt;</span>
<a name="line-133"></a><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span> <span class="o">&gt;&amp;</span>
<a name="line-134"></a><span class="k">operator</span><span class="o">+=</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span> <span class="o">&gt;&amp;</span> <span class="n">dst</span><span class="p">,</span>
<a name="line-135"></a>            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span> <span class="o">&gt;&amp;</span> <span class="n">src</span> <span class="p">)</span>
<a name="line-136"></a><span class="p">{</span>
<a name="line-137"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">src</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;src empty in std::vector&lt;T,Allocator&gt;::operator+=()&quot;</span> <span class="p">);</span>
<a name="line-138"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">dst</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;src.size() &lt; dst.size() would loose data &quot;</span>
<a name="line-139"></a>          <span class="s">&quot;in std::vector&lt;T,Allocator&gt;::operator+=()&quot;</span> <span class="p">);</span>
<a name="line-140"></a>  <span class="n">dst</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
<a name="line-141"></a>  <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">dst</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">dst</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
<a name="line-142"></a>                  <span class="p">[](</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">d</span> <span class="p">){</span> <span class="k">return</span> <span class="n">d</span> <span class="o">+=</span> <span class="n">s</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
<a name="line-143"></a>  <span class="k">return</span> <span class="n">dst</span><span class="p">;</span>
<a name="line-144"></a><span class="p">}</span>
<a name="line-145"></a>
<a name="line-146"></a><span class="c1">//! Divide all elements of a vector with those of another one</span>
<a name="line-147"></a><span class="c1">//! \param[in,out] dst Destination vector, i.e., left-hand side of v1 /= v2</span>
<a name="line-148"></a><span class="c1">//! \param[in] src Source vector, i.e., righ-hand side of v1 /= v2</span>
<a name="line-149"></a><span class="c1">//! \return Destination containing v1[0] /= v2[0], v1[1] /= v2[1], ...</span>
<a name="line-150"></a><span class="c1">//! \details If src.size() &gt; dst.size() will grow dst to that of src.size()</span>
<a name="line-151"></a><span class="c1">//!   padding with zeros.</span>
<a name="line-152"></a><span class="c1">//! \note Will throw exception in DEBUG if src is empty (to warn on no-op), and</span>
<a name="line-153"></a><span class="c1">//!   if src.size() &lt; dst.size() (to warn on loosing data).</span>
<a name="line-154"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">&gt;</span>
<a name="line-155"></a><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span> <span class="o">&gt;&amp;</span>
<a name="line-156"></a><span class="k">operator</span><span class="o">/=</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span> <span class="o">&gt;&amp;</span> <span class="n">dst</span><span class="p">,</span>
<a name="line-157"></a>            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span> <span class="o">&gt;&amp;</span> <span class="n">src</span> <span class="p">)</span>
<a name="line-158"></a><span class="p">{</span>
<a name="line-159"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="o">!</span><span class="n">src</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;src empty in std::vector&lt;T,Allocator&gt;::operator/=()&quot;</span> <span class="p">);</span>
<a name="line-160"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">dst</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;src.size() &lt; dst.size() would loose data &quot;</span>
<a name="line-161"></a>          <span class="s">&quot;in std::vector&lt;T,Allocator&gt;::operator/=()&quot;</span> <span class="p">);</span>
<a name="line-162"></a>  <span class="n">dst</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
<a name="line-163"></a>  <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">dst</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">dst</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
<a name="line-164"></a>                  <span class="p">[](</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">d</span> <span class="p">){</span> <span class="k">return</span> <span class="n">d</span> <span class="o">/=</span> <span class="n">s</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
<a name="line-165"></a>  <span class="k">return</span> <span class="n">dst</span><span class="p">;</span>
<a name="line-166"></a><span class="p">}</span>
<a name="line-167"></a>
<a name="line-168"></a><span class="c1">//! Test if all keys of two associative containers are equal</span>
<a name="line-169"></a><span class="c1">//! \param[in] a 1st container to compare</span>
<a name="line-170"></a><span class="c1">//! \param[in] b 2nd container to compare</span>
<a name="line-171"></a><span class="c1">//! \return True if the containers have the same size and all keys (and only the</span>
<a name="line-172"></a><span class="c1">//!   keys) of the two containers are equal</span>
<a name="line-173"></a><span class="c1">//! \note It is an error to call this function with unequal-size containers,</span>
<a name="line-174"></a><span class="c1">//!   triggering an exception in DEBUG mode.</span>
<a name="line-175"></a><span class="c1">//! \note Operator != is used to compare the container keys.</span>
<a name="line-176"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">C1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">C2</span> <span class="o">&gt;</span>
<a name="line-177"></a><span class="kt">bool</span> <span class="n">keyEqual</span><span class="p">(</span> <span class="k">const</span> <span class="n">C1</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">C2</span><span class="o">&amp;</span> <span class="n">b</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-178"></a>  <span class="n">Assert</span><span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;Size mismatch comparing containers&quot;</span> <span class="p">);</span>
<a name="line-179"></a>  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">C1</span><span class="o">::</span><span class="n">key_type</span> <span class="o">&gt;</span> <span class="n">sorted_keys_of_a</span><span class="p">;</span>
<a name="line-180"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">a</span><span class="p">)</span> <span class="n">sorted_keys_of_a</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">c</span><span class="p">.</span><span class="n">first</span> <span class="p">);</span>
<a name="line-181"></a>  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">C2</span><span class="o">::</span><span class="n">key_type</span> <span class="o">&gt;</span> <span class="n">sorted_keys_of_b</span><span class="p">;</span>
<a name="line-182"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">b</span><span class="p">)</span> <span class="n">sorted_keys_of_b</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">c</span><span class="p">.</span><span class="n">first</span> <span class="p">);</span>
<a name="line-183"></a>  <span class="k">return</span> <span class="n">sorted_keys_of_a</span> <span class="o">==</span> <span class="n">sorted_keys_of_b</span><span class="p">;</span>
<a name="line-184"></a><span class="p">}</span>
<a name="line-185"></a>
<a name="line-186"></a><span class="c1">//! Compute the sum of the sizes of a container of containers</span>
<a name="line-187"></a><span class="c1">//! \param[in] c Container of containers</span>
<a name="line-188"></a><span class="c1">//! \return Sum of the sizes of the containers of the container</span>
<a name="line-189"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Container</span> <span class="o">&gt;</span>
<a name="line-190"></a><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sumsize</span><span class="p">(</span> <span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-191"></a>  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-192"></a>  <span class="c1">// cppcheck-suppress useStlAlgorithm</span>
<a name="line-193"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">c</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<a name="line-194"></a>  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<a name="line-195"></a><span class="p">}</span>
<a name="line-196"></a>
<a name="line-197"></a><span class="c1">//! Compute the number of unique values in a container of containers</span>
<a name="line-198"></a><span class="c1">//! \param[in] c Container of containers</span>
<a name="line-199"></a><span class="c1">//! \return Number of unique values in a container of containers</span>
<a name="line-200"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Container</span> <span class="o">&gt;</span>
<a name="line-201"></a><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">numunique</span><span class="p">(</span> <span class="k">const</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-202"></a>  <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">Container</span><span class="o">::</span><span class="n">value_type</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
<a name="line-203"></a>  <span class="k">static_assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
<a name="line-204"></a>    <span class="s">&quot;Container::value_type::value_type must be an integral type.&quot;</span> <span class="p">);</span>
<a name="line-205"></a>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span> <span class="n">value_type</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">;</span>
<a name="line-206"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">r</span> <span class="p">:</span> <span class="n">c</span><span class="p">)</span> <span class="n">u</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">);</span>
<a name="line-207"></a>  <span class="k">return</span> <span class="n">u</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<a name="line-208"></a><span class="p">}</span>
<a name="line-209"></a>
<a name="line-210"></a><span class="c1">//! Compute the sum of the sizes of the values of an associative container</span>
<a name="line-211"></a><span class="c1">//! \tparam Map Container of containers type</span>
<a name="line-212"></a><span class="c1">//! \param[in] c Container of containers</span>
<a name="line-213"></a><span class="c1">//! \return Sum of the sizes of the values of the associative container</span>
<a name="line-214"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Map</span> <span class="o">&gt;</span>
<a name="line-215"></a><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sumvalsize</span><span class="p">(</span> <span class="k">const</span> <span class="n">Map</span><span class="o">&amp;</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-216"></a>  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-217"></a>  <span class="c1">// cppcheck-suppress useStlAlgorithm</span>
<a name="line-218"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">c</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<a name="line-219"></a>  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<a name="line-220"></a><span class="p">}</span>
<a name="line-221"></a>
<a name="line-222"></a><span class="c1">//! Free memory of a container</span>
<a name="line-223"></a><span class="c1">//! \param[in] c Container defining a swap() member function</span>
<a name="line-224"></a><span class="c1">//! \details See http://stackoverflow.com/a/10465032 as to why this is done with</span>
<a name="line-225"></a><span class="c1">//!   the swap() member function of the container.</span>
<a name="line-226"></a><span class="c1">//! \see Specializations of std::swap are documented at</span>
<a name="line-227"></a><span class="c1">//!   http://en.cppreference.com/w/cpp/algorithm/swap</span>
<a name="line-228"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Container</span> <span class="o">&gt;</span>
<a name="line-229"></a><span class="kt">void</span> <span class="n">destroy</span><span class="p">(</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-230"></a>  <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;::</span><span class="n">type</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span> <span class="n">c</span> <span class="p">);</span>
<a name="line-231"></a><span class="p">}</span>
<a name="line-232"></a>
<a name="line-233"></a><span class="c1">//! Remove items from container based on predicate</span>
<a name="line-234"></a><span class="c1">//! \tparam Container Type of container to remove from</span>
<a name="line-235"></a><span class="c1">//! \tparam Predicate Type for functor defining the predicate</span>
<a name="line-236"></a><span class="c1">//! \param items Container object to remove from</span>
<a name="line-237"></a><span class="c1">//! \param predicate Predicate object instance to use</span>
<a name="line-238"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Predicate</span> <span class="o">&gt;</span>
<a name="line-239"></a><span class="kt">void</span> <span class="n">erase_if</span><span class="p">(</span> <span class="n">Container</span><span class="o">&amp;</span> <span class="n">items</span><span class="p">,</span> <span class="k">const</span> <span class="n">Predicate</span><span class="o">&amp;</span> <span class="n">predicate</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-240"></a>  <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">items</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-241"></a>    <span class="k">if</span> <span class="p">(</span> <span class="n">predicate</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span> <span class="p">)</span> <span class="n">it</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
<a name="line-242"></a>    <span class="k">else</span> <span class="o">++</span><span class="n">it</span><span class="p">;</span>
<a name="line-243"></a>  <span class="p">}</span>
<a name="line-244"></a><span class="p">}</span>
<a name="line-245"></a>
<a name="line-246"></a><span class="c1">//! Concatenate vectors of T</span>
<a name="line-247"></a><span class="c1">//! \tparam T Vector value type</span>
<a name="line-248"></a><span class="c1">//! \param[in,out] src Source vector (moved from)</span>
<a name="line-249"></a><span class="c1">//! \param[in,out] dst Destination vector</span>
<a name="line-250"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">&gt;</span>
<a name="line-251"></a><span class="kt">void</span> <span class="n">concat</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;&amp;&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;&amp;</span> <span class="n">dst</span> <span class="p">)</span>
<a name="line-252"></a><span class="p">{</span>
<a name="line-253"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<a name="line-254"></a>    <span class="n">dst</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
<a name="line-255"></a>  <span class="k">else</span> <span class="p">{</span>
<a name="line-256"></a>    <span class="n">dst</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span> <span class="n">dst</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">src</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
<a name="line-257"></a>    <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="p">);</span>
<a name="line-258"></a>    <span class="n">src</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<a name="line-259"></a>  <span class="p">}</span>
<a name="line-260"></a><span class="p">}</span>
<a name="line-261"></a>
<a name="line-262"></a><span class="c1">//! Overwrite vectors of pair&lt; bool, tk::real &gt;</span>
<a name="line-263"></a><span class="c1">//! \tparam T Vector value type</span>
<a name="line-264"></a><span class="c1">//! \param[in,out] src Source vector (moved from)</span>
<a name="line-265"></a><span class="c1">//! \param[in,out] dst Destination vector</span>
<a name="line-266"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">&gt;</span>
<a name="line-267"></a><span class="kt">void</span> <span class="n">concat</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;&amp;</span> <span class="n">src</span><span class="p">,</span>
<a name="line-268"></a>             <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">dst</span> <span class="p">)</span>
<a name="line-269"></a><span class="p">{</span>
<a name="line-270"></a>  <span class="n">dst</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
<a name="line-271"></a><span class="p">}</span>
<a name="line-272"></a>
<a name="line-273"></a><span class="c1">//! Concatenate unordered sets</span>
<a name="line-274"></a><span class="c1">//! \tparam Key Set key</span>
<a name="line-275"></a><span class="c1">//! \tparam Hash Set hasher</span>
<a name="line-276"></a><span class="c1">//! \tparam Eq Set equality operator</span>
<a name="line-277"></a><span class="c1">//! \param[in,out] src Source set (moved from)</span>
<a name="line-278"></a><span class="c1">//! \param[in,out] dst Destination set</span>
<a name="line-279"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
<a name="line-280"></a>          <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span> <span class="n">Key</span> <span class="o">&gt;</span><span class="p">,</span>
<a name="line-281"></a>          <span class="k">class</span> <span class="nc">Eq</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span> <span class="n">Key</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<a name="line-282"></a><span class="kt">void</span> <span class="n">concat</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span><span class="n">Eq</span> <span class="o">&gt;&amp;&amp;</span> <span class="n">src</span><span class="p">,</span>
<a name="line-283"></a>             <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Eq</span> <span class="o">&gt;&amp;</span> <span class="n">dst</span> <span class="p">)</span>
<a name="line-284"></a><span class="p">{</span>
<a name="line-285"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<a name="line-286"></a>    <span class="n">dst</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
<a name="line-287"></a>  <span class="k">else</span> <span class="p">{</span>
<a name="line-288"></a>    <span class="n">dst</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span> <span class="n">dst</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">src</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
<a name="line-289"></a>    <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">inserter</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="n">end</span><span class="p">(</span><span class="n">dst</span><span class="p">))</span> <span class="p">);</span>
<a name="line-290"></a>    <span class="n">src</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<a name="line-291"></a>  <span class="p">}</span>
<a name="line-292"></a><span class="p">}</span>
<a name="line-293"></a>
<a name="line-294"></a><span class="c1">//! Operator &lt;&lt; for writing value_type of a standard map to output streams</span>
<a name="line-295"></a><span class="c1">//! \param[in,out] os Output stream to write to</span>
<a name="line-296"></a><span class="c1">//! \param[in] v value_type entry of a map</span>
<a name="line-297"></a><span class="c1">//! \return Updated output stream</span>
<a name="line-298"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Value</span> <span class="o">&gt;</span>
<a name="line-299"></a><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span>
<a name="line-300"></a><span class="k">operator</span><span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="k">const</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Value</span>  <span class="o">&gt;&amp;</span> <span class="n">v</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-301"></a>  <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<a name="line-302"></a>  <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<a name="line-303"></a><span class="p">}</span>
<a name="line-304"></a>
<a name="line-305"></a><span class="c1">//! \brief Convert and return value as string</span>
<a name="line-306"></a><span class="c1">//! \tparam T Value type for input</span>
<a name="line-307"></a><span class="c1">//! \param[in] v Value for input to return as a string</span>
<a name="line-308"></a><span class="c1">//! \return String for input value</span>
<a name="line-309"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">T</span> <span class="o">&gt;</span>
<a name="line-310"></a><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">parameter</span><span class="p">(</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-311"></a>  <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">s</span><span class="p">;</span>
<a name="line-312"></a>  <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">;</span>
<a name="line-313"></a>  <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<a name="line-314"></a><span class="p">}</span>
<a name="line-315"></a>
<a name="line-316"></a><span class="c1">//! \brief Convert and return values from container as string</span>
<a name="line-317"></a><span class="c1">//! \tparam V Container range for works on</span>
<a name="line-318"></a><span class="c1">//! \param[in] v Container whose components to return as a string</span>
<a name="line-319"></a><span class="c1">//! \return Concatenated string of values read from a container</span>
<a name="line-320"></a><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">V</span> <span class="o">&gt;</span>
<a name="line-321"></a><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">parameters</span><span class="p">(</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-322"></a>  <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">s</span><span class="p">;</span>
<a name="line-323"></a>  <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;{ &quot;</span><span class="p">;</span>
<a name="line-324"></a>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
<a name="line-325"></a>  <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;}&quot;</span><span class="p">;</span>
<a name="line-326"></a>  <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<a name="line-327"></a><span class="p">}</span>
<a name="line-328"></a>
<a name="line-329"></a><span class="p">}</span> <span class="c1">// tk::</span>
<a name="line-330"></a>
<a name="line-331"></a><span class="cp">#endif </span><span class="c1">// ContainerUtil_h</span>
</pre></div>
</td></tr></table>
      </div> <!-- /.wrapper -->
    </div>
    <div id="footer" class="footer">
      <p>
        Cppcheck 2.3 - a tool for static C/C++ code analysis<br>
        <br>
        Internet: <a href="http://cppcheck.net">http://cppcheck.net</a><br>
        IRC: <a href="irc://irc.freenode.net/cppcheck">irc://irc.freenode.net/cppcheck</a><br>
      </p>
    </div>
  </body>
</html>
