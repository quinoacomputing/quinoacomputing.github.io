
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cppcheck - HTML report - [<a href=https://github.com/quinoacomputing/quinoa/commit/-128-NOTFOUND>-128-NOTFOUND</a>]</title>
    <link rel="stylesheet" href="style.css">
    <style>
pre { line-height: 125%; margin: 0; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .ch { color: #888888 } /* Comment.Hashbang */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .cpf { color: #888888 } /* Comment.PreprocFile */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { background-color: #fff0f0 } /* Literal.String.Affix */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .vm { color: #996633 } /* Name.Variable.Magic */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
    </style>
    <script>
      function getStyle(el, styleProp) {
        var y;

        if (el.currentStyle) {
          y = el.currentStyle[styleProp];
        } else if (window.getComputedStyle) {
          y = document.defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);
        }

        return y;
      }

      function toggle() {
        var el = this.expandable_content;
        var mark = this.expandable_marker;

        if (el.style.display === "block") {
          el.style.display = "none";
          mark.textContent = "[+]";
        } else {
          el.style.display = "block";
          mark.textContent = "[-]";
        }
      }

      function initExpandables() {
        var elements = document.querySelectorAll(".expandable");

        for (var i = 0, len = elements.length; i < len; i++) {
          var el = elements[i];
          var clickable = el.querySelector("span");
          var marker = clickable.querySelector(".marker");
          var content = el.querySelector(".content");
          var width = clickable.clientWidth - parseInt(getStyle(content, "padding-left")) - parseInt(getStyle(content, "padding-right"));
          content.style.width = width + "px";
          clickable.expandable_content = content;
          clickable.expandable_marker = marker;
          clickable.addEventListener("click", toggle);
        }
      }

      function toggleDisplay(id) {
        var elements = document.querySelectorAll("." + id);

        for (var i = 0, len = elements.length; i < len; i++) {
          elements[i].classList.toggle("d-none");
        }
      }

      function toggleAll() {
        var elements = document.querySelectorAll("input");

        // starting from 1 since 0 is the "toggle all" input
        for (var i = 1, len = elements.length; i < len; i++) {
          var el = elements[i];

          if (el.checked) {
            el.checked = false;
          } else {
            el.checked = true;
          }

          toggleDisplay(el.id);
        }
      }
      window.addEventListener("load", initExpandables);
    </script>
  </head>
  <body>
    <div id="header" class="header">
      <h1>Cppcheck report - [<a href=https://github.com/quinoacomputing/quinoa/commit/-128-NOTFOUND>-128-NOTFOUND</a>]: /tmp/TeamCity-1/work/5ad443c8abe7fc0a/src/Inciter/Scheme.hpp</h1>
    </div>
    <div class="wrapper">
      <div id="menu">
       <p id="filename"><a href="index.html">Defects:</a> Scheme.hpp</p>
<a href="31.html#line-175"> constParameter 175</a><a href="31.html#line-236"> constParameter 236</a><a href="31.html#line-282"> constParameter 282</a>
    </div>
    <div id="content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326</pre></div></td><td class="code"><div class="highlight"><pre><span></span><a name="line-1"></a><span class="c1">// *****************************************************************************</span>
<a name="line-2"></a><span class="cm">/*!</span>
<a name="line-3"></a><span class="cm">  \file      src/Inciter/Scheme.hpp</span>
<a name="line-4"></a><span class="cm">  \copyright 2012-2015 J. Bakosi,</span>
<a name="line-5"></a><span class="cm">             2016-2018 Los Alamos National Security, LLC.,</span>
<a name="line-6"></a><span class="cm">             2019-2021 Triad National Security, LLC.</span>
<a name="line-7"></a><span class="cm">             All rights reserved. See the LICENSE file for details.</span>
<a name="line-8"></a><span class="cm">  \brief     Polymorphic glue for calling Charm++ entry methods to base class</span>
<a name="line-9"></a><span class="cm">    Discretization, its children implementing specific discretization schemes,</span>
<a name="line-10"></a><span class="cm">    and helper classes</span>
<a name="line-11"></a><span class="cm">  \details</span>
<a name="line-12"></a><span class="cm">    The purpose of this class is to hide, behind a single type, different</span>
<a name="line-13"></a><span class="cm">    Charm++  proxy types that model a single concept, i.e., define some common</span>
<a name="line-14"></a><span class="cm">    functions as Charm++ entry methods that can be used in either a broadcast</span>
<a name="line-15"></a><span class="cm">    and/or in a way of addressing a single array element. As a result, member</span>
<a name="line-16"></a><span class="cm">    functions can be invoked by client code without knowing the underlying type</span>
<a name="line-17"></a><span class="cm">    or any specifics to the underlying differences of the classes that model the</span>
<a name="line-18"></a><span class="cm">    same concept, i.e., expose the same member functions. The idea is very</span>
<a name="line-19"></a><span class="cm">    similar to inheritance and runtime polymorphism with base classes and</span>
<a name="line-20"></a><span class="cm">    virtual functions: some member functions and data are common to all types</span>
<a name="line-21"></a><span class="cm">    modeled (and thus are not repeated and/or copied), while some are specific.</span>
<a name="line-22"></a><span class="cm">    A difference is that the &quot;base&quot; and &quot;child&quot; classes are Charm++ proxies.</span>
<a name="line-23"></a><span class="cm">    Note that while Charm++ does support inheritance and runtime polymorphism</span>
<a name="line-24"></a><span class="cm">    with chare arrays, we still prefer the implementation below because it uses</span>
<a name="line-25"></a><span class="cm">    entirely value semantics (inside and in client code) and thus it keeps the</span>
<a name="line-26"></a><span class="cm">    complexity of the dispatch behind this class and does not expose it to</span>
<a name="line-27"></a><span class="cm">    client code.</span>
<a name="line-28"></a>
<a name="line-29"></a><span class="cm">    The advantages of this class over traditional runtime polymorphism are (1)</span>
<a name="line-30"></a><span class="cm">    value semantics (both internally and to client code), (2) not templated,</span>
<a name="line-31"></a><span class="cm">    and (3) PUPable, i.e., an instance of Scheme can be sent across the network</span>
<a name="line-32"></a><span class="cm">    using Charm++&#39;s pup framework. Also, since the class only holds a couple of</span>
<a name="line-33"></a><span class="cm">    chare proxies, it is lightweight.</span>
<a name="line-34"></a>
<a name="line-35"></a><span class="cm">    Example usage from client code:</span>
<a name="line-36"></a>
<a name="line-37"></a><span class="cm">    \code{.cpp}</span>
<a name="line-38"></a><span class="cm">      // Instantiate a Scheme object</span>
<a name="line-39"></a><span class="cm">      Scheme s( ctr::SchemeType::DG );  // see Control/Inciter/Options/Scheme.h</span>
<a name="line-40"></a>
<a name="line-41"></a><span class="cm">      // Issue broadcast to child scheme entry method</span>
<a name="line-42"></a><span class="cm">      s.bcast&lt; Scheme::setup &gt;(...);</span>
<a name="line-43"></a>
<a name="line-44"></a><span class="cm">      // Issue broadcast to base (Discretization) entry method</span>
<a name="line-45"></a><span class="cm">      s.disc().totalvol();</span>
<a name="line-46"></a><span class="cm">    \endcode</span>
<a name="line-47"></a>
<a name="line-48"></a><span class="cm">    Organization, implementation details, end extension of the class:</span>
<a name="line-49"></a>
<a name="line-50"></a><span class="cm">    Scheme contains (at least) two Charm++ proxies: discproxy and proxy. The</span>
<a name="line-51"></a><span class="cm">    former contains data and functionality common to all discretizations, and</span>
<a name="line-52"></a><span class="cm">    this can be considered as an equivalent to a base class in the OOP sense.</span>
<a name="line-53"></a><span class="cm">    The latter, proxy, contains data and functionality specific to a particular</span>
<a name="line-54"></a><span class="cm">    discretization. When instantiated, Scheme is configured for a single</span>
<a name="line-55"></a><span class="cm">    specific discretization which must be selected from the list of types in</span>
<a name="line-56"></a><span class="cm">    SchemeBase::Proxy.</span>
<a name="line-57"></a>
<a name="line-58"></a><span class="cm">    The underlying type of proxy is a variant, which allows storing exactly one</span>
<a name="line-59"></a><span class="cm">    object. A variant is a type-safe union. An instance of a variant at any</span>
<a name="line-60"></a><span class="cm">    given time either holds a value of one of its alternative types. Read more</span>
<a name="line-61"></a><span class="cm">    on std::variant on how they work.</span>
<a name="line-62"></a>
<a name="line-63"></a><span class="cm">    Adding a new child scheme is done by</span>
<a name="line-64"></a><span class="cm">    (1) Adding a new type of Charm++ chare array proxy to Scheme::Proxy,</span>
<a name="line-65"></a><span class="cm">    (2) Adding a new type of Charm++ chare array element proxy to</span>
<a name="line-66"></a><span class="cm">        Scheme::ProxyElem, and</span>
<a name="line-67"></a><span class="cm">    (3) Adding a new branch to the if test in Scheme&#39;s constructor.</span>
<a name="line-68"></a>
<a name="line-69"></a><span class="cm">  \see A talk on &quot;Concept-based runtime polymorphism with Charm++ chare arrays</span>
<a name="line-70"></a><span class="cm">    using value semantics given by J. Bakosi at the 16th Annual Workshop on</span>
<a name="line-71"></a><span class="cm">    Charm++ and its Applications, April 2018, discussing an earlier, more</span>
<a name="line-72"></a><span class="cm">    verbose implementation of the idea, using C++11.</span>
<a name="line-73"></a><span class="cm">*/</span>
<a name="line-74"></a><span class="c1">// *****************************************************************************</span>
<a name="line-75"></a><span class="cp">#ifndef Scheme_h</span>
<a name="line-76"></a><span class="cp">#define Scheme_h</span>
<a name="line-77"></a>
<a name="line-78"></a><span class="cp">#include</span> <span class="cpf">&quot;Exception.hpp&quot;</span><span class="cp"></span>
<a name="line-79"></a><span class="cp">#include</span> <span class="cpf">&quot;PUPUtil.hpp&quot;</span><span class="cp"></span>
<a name="line-80"></a><span class="cp">#include</span> <span class="cpf">&quot;Inciter/Options/Scheme.hpp&quot;</span><span class="cp"></span>
<a name="line-81"></a>
<a name="line-82"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/discretization.decl.h&quot;</span><span class="cp"></span>
<a name="line-83"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/diagcg.decl.h&quot;</span><span class="cp"></span>
<a name="line-84"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/alecg.decl.h&quot;</span><span class="cp"></span>
<a name="line-85"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/distfct.decl.h&quot;</span><span class="cp"></span>
<a name="line-86"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/dg.decl.h&quot;</span><span class="cp"></span>
<a name="line-87"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/fv.decl.h&quot;</span><span class="cp"></span>
<a name="line-88"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/ale.decl.h&quot;</span><span class="cp"></span>
<a name="line-89"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/conjugategradients.decl.h&quot;</span><span class="cp"></span>
<a name="line-90"></a><span class="cp">#include</span> <span class="cpf">&quot;NoWarning/ghosts.decl.h&quot;</span><span class="cp"></span>
<a name="line-91"></a>
<a name="line-92"></a><span class="k">namespace</span> <span class="n">inciter</span> <span class="p">{</span>
<a name="line-93"></a>
<a name="line-94"></a><span class="c1">//! Base class for generic forwarding interface to discretization proxies</span>
<a name="line-95"></a><span class="k">class</span> <span class="nc">Scheme</span> <span class="p">{</span>
<a name="line-96"></a>
<a name="line-97"></a>  <span class="k">private</span><span class="o">:</span>
<a name="line-98"></a>    <span class="c1">//! Variant type listing all chare proxy types modeling the same concept</span>
<a name="line-99"></a>    <span class="k">using</span> <span class="n">Proxy</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span> <span class="n">CProxy_DiagCG</span>
<a name="line-100"></a>                              <span class="p">,</span> <span class="n">CProxy_DG</span>
<a name="line-101"></a>                              <span class="p">,</span> <span class="n">CProxy_ALECG</span>
<a name="line-102"></a>                              <span class="p">,</span> <span class="n">CProxy_FV</span> <span class="o">&gt;</span><span class="p">;</span>
<a name="line-103"></a>
<a name="line-104"></a>  <span class="k">public</span><span class="o">:</span>
<a name="line-105"></a>    <span class="c1">//! Variant type listing all chare element proxy types</span>
<a name="line-106"></a>    <span class="k">using</span> <span class="n">ProxyElem</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span> <span class="n">CProxy_DiagCG</span><span class="o">::</span><span class="n">element_t</span>
<a name="line-107"></a>                                  <span class="p">,</span> <span class="n">CProxy_DG</span><span class="o">::</span><span class="n">element_t</span>
<a name="line-108"></a>                                  <span class="p">,</span> <span class="n">CProxy_ALECG</span><span class="o">::</span><span class="n">element_t</span>
<a name="line-109"></a>                                  <span class="p">,</span> <span class="n">CProxy_FV</span><span class="o">::</span><span class="n">element_t</span> <span class="o">&gt;</span><span class="p">;</span>
<a name="line-110"></a>
<a name="line-111"></a>    <span class="c1">//! Empty constructor for Charm++</span>
<a name="line-112"></a>    <span class="k">explicit</span> <span class="nf">Scheme</span><span class="p">()</span> <span class="p">{}</span>
<a name="line-113"></a>
<a name="line-114"></a>    <span class="c1">//! Constructor</span>
<a name="line-115"></a>    <span class="c1">//! \param[in] scheme Discretization scheme</span>
<a name="line-116"></a>    <span class="c1">//! \param[in] ale True if enable ALE</span>
<a name="line-117"></a>    <span class="c1">//! \param[in] linearsolver True if enable a linear solver</span>
<a name="line-118"></a>    <span class="c1">//! \details Based on the input enum we create at least two empty chare</span>
<a name="line-119"></a>    <span class="c1">//!   arrays: (1) discproxy which contains common functionality and data for</span>
<a name="line-120"></a>    <span class="c1">//!   all discretizations, and (2) proxy, which have functionality and data</span>
<a name="line-121"></a>    <span class="c1">//!   specific to a given discretization. Note that proxy is bound (in</span>
<a name="line-122"></a>    <span class="c1">//!   migration behavior and properties) to discproxy.</span>
<a name="line-123"></a>    <span class="c1">//! \note There may be other bound proxy arrays created depending on the</span>
<a name="line-124"></a>    <span class="c1">//!   specific discretization configured by the enum.</span>
<a name="line-125"></a>    <span class="k">explicit</span> <span class="nf">Scheme</span><span class="p">(</span> <span class="n">ctr</span><span class="o">::</span><span class="n">SchemeType</span> <span class="n">scheme</span><span class="p">,</span>
<a name="line-126"></a>                     <span class="kt">bool</span> <span class="n">ale</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
<a name="line-127"></a>                     <span class="kt">bool</span> <span class="n">linearsolver</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
<a name="line-128"></a>                     <span class="n">tk</span><span class="o">::</span><span class="n">Centering</span> <span class="n">centering</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">Centering</span><span class="o">::</span><span class="n">NODE</span> <span class="p">)</span> <span class="o">:</span>
<a name="line-129"></a>      <span class="n">discproxy</span><span class="p">(</span> <span class="n">CProxy_Discretization</span><span class="o">::</span><span class="n">ckNew</span><span class="p">()</span> <span class="p">)</span>
<a name="line-130"></a>    <span class="p">{</span>
<a name="line-131"></a>      <span class="n">bound</span><span class="p">.</span><span class="n">bindTo</span><span class="p">(</span> <span class="n">discproxy</span> <span class="p">);</span>
<a name="line-132"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">scheme</span> <span class="o">==</span> <span class="n">ctr</span><span class="o">::</span><span class="n">SchemeType</span><span class="o">::</span><span class="n">DiagCG</span><span class="p">)</span> <span class="p">{</span>
<a name="line-133"></a>        <span class="n">proxy</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">CProxy_DiagCG</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">CProxy_DiagCG</span><span class="o">::</span><span class="n">ckNew</span><span class="p">(</span><span class="n">bound</span><span class="p">)</span> <span class="p">);</span>
<a name="line-134"></a>        <span class="n">fctproxy</span> <span class="o">=</span> <span class="n">CProxy_DistFCT</span><span class="o">::</span><span class="n">ckNew</span><span class="p">(</span><span class="n">bound</span><span class="p">);</span>
<a name="line-135"></a>      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scheme</span> <span class="o">==</span> <span class="n">ctr</span><span class="o">::</span><span class="n">SchemeType</span><span class="o">::</span><span class="n">DG</span> <span class="o">||</span>
<a name="line-136"></a>                 <span class="n">scheme</span> <span class="o">==</span> <span class="n">ctr</span><span class="o">::</span><span class="n">SchemeType</span><span class="o">::</span><span class="n">P0P1</span> <span class="o">||</span>
<a name="line-137"></a>                 <span class="n">scheme</span> <span class="o">==</span> <span class="n">ctr</span><span class="o">::</span><span class="n">SchemeType</span><span class="o">::</span><span class="n">DGP1</span> <span class="o">||</span>
<a name="line-138"></a>                 <span class="n">scheme</span> <span class="o">==</span> <span class="n">ctr</span><span class="o">::</span><span class="n">SchemeType</span><span class="o">::</span><span class="n">DGP2</span> <span class="o">||</span>
<a name="line-139"></a>                 <span class="n">scheme</span> <span class="o">==</span> <span class="n">ctr</span><span class="o">::</span><span class="n">SchemeType</span><span class="o">::</span><span class="n">PDG</span><span class="p">)</span>
<a name="line-140"></a>      <span class="p">{</span>
<a name="line-141"></a>        <span class="n">proxy</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">CProxy_DG</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">CProxy_DG</span><span class="o">::</span><span class="n">ckNew</span><span class="p">(</span><span class="n">bound</span><span class="p">)</span> <span class="p">);</span>
<a name="line-142"></a>      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scheme</span> <span class="o">==</span> <span class="n">ctr</span><span class="o">::</span><span class="n">SchemeType</span><span class="o">::</span><span class="n">ALECG</span><span class="p">)</span> <span class="p">{</span>
<a name="line-143"></a>        <span class="n">proxy</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">CProxy_ALECG</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">CProxy_ALECG</span><span class="o">::</span><span class="n">ckNew</span><span class="p">(</span><span class="n">bound</span><span class="p">)</span> <span class="p">);</span>
<a name="line-144"></a>      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scheme</span> <span class="o">==</span> <span class="n">ctr</span><span class="o">::</span><span class="n">SchemeType</span><span class="o">::</span><span class="n">FV</span><span class="p">)</span> <span class="p">{</span>
<a name="line-145"></a>        <span class="n">proxy</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">CProxy_FV</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">CProxy_FV</span><span class="o">::</span><span class="n">ckNew</span><span class="p">(</span><span class="n">bound</span><span class="p">)</span> <span class="p">);</span>
<a name="line-146"></a>      <span class="p">}</span> <span class="k">else</span> <span class="n">Throw</span><span class="p">(</span> <span class="s">&quot;Unknown discretization scheme&quot;</span> <span class="p">);</span>
<a name="line-147"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">ale</span><span class="p">)</span> <span class="n">aleproxy</span> <span class="o">=</span> <span class="n">CProxy_ALE</span><span class="o">::</span><span class="n">ckNew</span><span class="p">(</span><span class="n">bound</span><span class="p">);</span>
<a name="line-148"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">linearsolver</span><span class="p">)</span>
<a name="line-149"></a>        <span class="n">conjugategradientsproxy</span> <span class="o">=</span> <span class="n">tk</span><span class="o">::</span><span class="n">CProxy_ConjugateGradients</span><span class="o">::</span><span class="n">ckNew</span><span class="p">(</span><span class="n">bound</span><span class="p">);</span>
<a name="line-150"></a>      <span class="k">if</span> <span class="p">(</span><span class="n">centering</span> <span class="o">==</span> <span class="n">tk</span><span class="o">::</span><span class="n">Centering</span><span class="o">::</span><span class="n">ELEM</span><span class="p">)</span>
<a name="line-151"></a>        <span class="n">ghostsproxy</span> <span class="o">=</span> <span class="n">CProxy_Ghosts</span><span class="o">::</span><span class="n">ckNew</span><span class="p">(</span><span class="n">bound</span><span class="p">);</span>
<a name="line-152"></a>    <span class="p">}</span>
<a name="line-153"></a>
<a name="line-154"></a>    <span class="c1">//! Entry method tags for specific Scheme classes to use with bcast()</span>
<a name="line-155"></a>    <span class="k">struct</span> <span class="nc">setup</span> <span class="p">{};</span>
<a name="line-156"></a>    <span class="k">struct</span> <span class="nc">box</span> <span class="p">{};</span>
<a name="line-157"></a>    <span class="k">struct</span> <span class="nc">advance</span> <span class="p">{};</span>
<a name="line-158"></a>    <span class="k">struct</span> <span class="nc">resized</span> <span class="p">{};</span>
<a name="line-159"></a>    <span class="k">struct</span> <span class="nc">resizeComm</span> <span class="p">{};</span>
<a name="line-160"></a>    <span class="k">struct</span> <span class="nc">refine</span> <span class="p">{};</span>
<a name="line-161"></a>    <span class="k">struct</span> <span class="nc">lhs</span> <span class="p">{};</span>
<a name="line-162"></a>    <span class="k">struct</span> <span class="nc">nodeNeighSetup</span> <span class="p">{};</span>
<a name="line-163"></a>    <span class="k">struct</span> <span class="nc">diag</span> <span class="p">{};</span>
<a name="line-164"></a>    <span class="k">struct</span> <span class="nc">evalLB</span> <span class="p">{};</span>
<a name="line-165"></a>    <span class="k">struct</span> <span class="nc">doneInserting</span> <span class="p">{};</span>
<a name="line-166"></a>    <span class="c1">//! Issue broadcast to Scheme entry method</span>
<a name="line-167"></a>    <span class="c1">//! \tparam Fn Function tag identifying the entry method to call</span>
<a name="line-168"></a>    <span class="c1">//! \tparam Args Types of arguments to pass to entry method</span>
<a name="line-169"></a>    <span class="c1">//! \param[in] args Arguments to member function entry method to be called</span>
<a name="line-170"></a>    <span class="c1">//! \details This function issues a broadcast to a member function entry</span>
<a name="line-171"></a>    <span class="c1">//!   method of the Scheme chare array (the child of Discretization) and is</span>
<a name="line-172"></a>    <span class="c1">//!   thus equivalent to proxy.Fn(...).</span>
<a name="line-173"></a>    <span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">Fn</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<a name="line-174"></a>    <span class="kt">void</span> <span class="n">bcast</span><span class="p">(</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-175"></a><span class="hll">      <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span> <span class="p">){</span><span class="error2">&lt;--- Parameter 'p' can be declared with const</span>
</span><a name="line-176"></a>          <span class="k">if</span> <span class="nf">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">setup</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-177"></a>            <span class="n">p</span><span class="p">.</span><span class="n">setup</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
<a name="line-178"></a>          <span class="k">if</span> <span class="nf">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">box</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-179"></a>            <span class="n">p</span><span class="p">.</span><span class="n">box</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
<a name="line-180"></a>          <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">advance</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-181"></a>            <span class="n">p</span><span class="p">.</span><span class="n">advance</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
<a name="line-182"></a>          <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">resized</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-183"></a>            <span class="n">p</span><span class="p">.</span><span class="n">resized</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
<a name="line-184"></a>          <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">resizeComm</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-185"></a>            <span class="n">p</span><span class="p">.</span><span class="n">resizeComm</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
<a name="line-186"></a>          <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">refine</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-187"></a>            <span class="n">p</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
<a name="line-188"></a>          <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">lhs</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-189"></a>            <span class="n">p</span><span class="p">.</span><span class="n">lhs</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
<a name="line-190"></a>          <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">nodeNeighSetup</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-191"></a>            <span class="n">p</span><span class="p">.</span><span class="n">nodeNeighSetup</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
<a name="line-192"></a>          <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">diag</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-193"></a>            <span class="n">p</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
<a name="line-194"></a>          <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">evalLB</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-195"></a>            <span class="n">p</span><span class="p">.</span><span class="n">evalLB</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
<a name="line-196"></a>          <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">doneInserting</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-197"></a>            <span class="n">p</span><span class="p">.</span><span class="n">doneInserting</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span> <span class="n">Args</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">args</span> <span class="p">)...</span> <span class="p">);</span>
<a name="line-198"></a>        <span class="p">},</span> <span class="n">proxy</span> <span class="p">);</span>
<a name="line-199"></a>    <span class="p">}</span>
<a name="line-200"></a>
<a name="line-201"></a>    <span class="c1">//! Function tags for specific Scheme classes to use with ckLocal()</span>
<a name="line-202"></a>    <span class="k">struct</span> <span class="nc">resizePostAMR</span> <span class="p">{};</span>
<a name="line-203"></a>    <span class="k">struct</span> <span class="nc">extractFieldOutput</span> <span class="p">{};</span>
<a name="line-204"></a>    <span class="k">struct</span> <span class="nc">solution</span> <span class="p">{};</span>
<a name="line-205"></a>    <span class="c1">//! Call Scheme function via Charm++ chare array element&#39;s ckLocal()</span>
<a name="line-206"></a>    <span class="c1">//! \tparam Fn Function tag identifying the function to call</span>
<a name="line-207"></a>    <span class="c1">//! \tparam Args Types of arguments to pass to function</span>
<a name="line-208"></a>    <span class="c1">//! \param[in] x Chare array element index</span>
<a name="line-209"></a>    <span class="c1">//! \param[in] args Arguments to member function function to be called</span>
<a name="line-210"></a>    <span class="c1">//! \details This function calls a member function via Charm++&#39;s ckLocal()</span>
<a name="line-211"></a>    <span class="c1">//!    behind the element proxy configured, indexed by the array index x.</span>
<a name="line-212"></a>    <span class="c1">//!    Since the call is behind ckLocal(), the member function does not have</span>
<a name="line-213"></a>    <span class="c1">//!    to be a Charm++ entry method.</span>
<a name="line-214"></a>    <span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">Fn</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<a name="line-215"></a>    <span class="k">auto</span> <span class="n">ckLocal</span><span class="p">(</span> <span class="k">const</span> <span class="n">CkArrayIndex1D</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<a name="line-216"></a>      <span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span> <span class="n">x</span> <span class="p">);</span>
<a name="line-217"></a>      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span> <span class="p">){</span>
<a name="line-218"></a>          <span class="k">if</span> <span class="nf">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">resizePostAMR</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-219"></a>            <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">ckLocal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">resizePostAMR</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...</span> <span class="p">);</span>
<a name="line-220"></a>          <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">extractFieldOutput</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-221"></a>            <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">ckLocal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">extractFieldOutput</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<a name="line-222"></a>          <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">solution</span> <span class="o">&gt;</span> <span class="p">)</span>
<a name="line-223"></a>            <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">ckLocal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">solution</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...</span> <span class="p">);</span>
<a name="line-224"></a>        <span class="p">},</span> <span class="n">e</span> <span class="p">);</span>
<a name="line-225"></a>    <span class="p">}</span>
<a name="line-226"></a>
<a name="line-227"></a>    <span class="c1">//! Function to call the insert entry method of an element proxy</span>
<a name="line-228"></a>    <span class="c1">//! \param[in] x Chare array element index</span>
<a name="line-229"></a>    <span class="c1">//! \param[in] args Arguments to member function (entry method) to be called</span>
<a name="line-230"></a>    <span class="c1">//! \details This function calls the insert member function of a chare array</span>
<a name="line-231"></a>    <span class="c1">//!   element proxy and thus equivalent to proxy[x].insert(...), using the</span>
<a name="line-232"></a>    <span class="c1">//!   last argument as default.</span>
<a name="line-233"></a>    <span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span> <span class="o">&gt;</span>
<a name="line-234"></a>    <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span> <span class="k">const</span> <span class="n">CkArrayIndex1D</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="p">{</span>
<a name="line-235"></a>      <span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">element</span><span class="p">(</span> <span class="n">x</span> <span class="p">);</span>
<a name="line-236"></a><span class="hll">      <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span> <span class="p">){</span> <span class="n">p</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span> <span class="p">},</span> <span class="n">e</span> <span class="p">);</span><span class="error2">&lt;--- Parameter 'p' can be declared with const</span>
</span><a name="line-237"></a>    <span class="p">}</span>
<a name="line-238"></a>
<a name="line-239"></a>    <span class="c1">//! Get reference to discretization proxy</span>
<a name="line-240"></a>    <span class="c1">//! \return Discretization Charm++ chare array proxy</span>
<a name="line-241"></a>    <span class="n">CProxy_Discretization</span><span class="o">&amp;</span> <span class="n">disc</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">discproxy</span><span class="p">;</span> <span class="p">}</span>
<a name="line-242"></a>
<a name="line-243"></a>    <span class="c1">//! Get reference to DistFCT proxy</span>
<a name="line-244"></a>    <span class="c1">//! \return DistFCT Charm++ chare array proxy</span>
<a name="line-245"></a>    <span class="n">CProxy_DistFCT</span><span class="o">&amp;</span> <span class="n">fct</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fctproxy</span><span class="p">;</span> <span class="p">}</span>
<a name="line-246"></a>
<a name="line-247"></a>    <span class="c1">//! Get reference to ALE proxy</span>
<a name="line-248"></a>    <span class="c1">//! \return ALE Charm++ chare array proxy</span>
<a name="line-249"></a>    <span class="n">CProxy_ALE</span><span class="o">&amp;</span> <span class="n">ale</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">aleproxy</span><span class="p">;</span> <span class="p">}</span>
<a name="line-250"></a>
<a name="line-251"></a>    <span class="c1">//! Get reference to ConjugateGradients proxy</span>
<a name="line-252"></a>    <span class="c1">//! \return ConjugateGradients Charm++ chare array proxy</span>
<a name="line-253"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">CProxy_ConjugateGradients</span><span class="o">&amp;</span> <span class="n">conjugategradients</span><span class="p">()</span> <span class="k">noexcept</span>
<a name="line-254"></a>    <span class="p">{</span> <span class="k">return</span> <span class="n">conjugategradientsproxy</span><span class="p">;</span> <span class="p">}</span>
<a name="line-255"></a>
<a name="line-256"></a>    <span class="c1">//! Get reference to Ghosts proxy</span>
<a name="line-257"></a>    <span class="c1">//! \return Ghosts Charm++ chare array proxy</span>
<a name="line-258"></a>    <span class="n">CProxy_Ghosts</span><span class="o">&amp;</span> <span class="n">ghosts</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ghostsproxy</span><span class="p">;</span> <span class="p">}</span>
<a name="line-259"></a>
<a name="line-260"></a>    <span class="c1">//! Get reference to scheme proxy</span>
<a name="line-261"></a>    <span class="c1">//! Get reference to scheme proxy</span>
<a name="line-262"></a>    <span class="c1">//! \return Variant storing Charm++ chare array proxy configured</span>
<a name="line-263"></a>    <span class="k">const</span> <span class="n">Proxy</span><span class="o">&amp;</span> <span class="n">getProxy</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">proxy</span><span class="p">;</span> <span class="p">}</span>
<a name="line-264"></a>
<a name="line-265"></a>    <span class="c1">//! Query underlying proxy type</span>
<a name="line-266"></a>    <span class="c1">//! \return Zero-based index into the set of types of Proxy</span>
<a name="line-267"></a>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">proxy</span><span class="p">.</span><span class="n">index</span><span class="p">();</span> <span class="p">}</span>
<a name="line-268"></a>
<a name="line-269"></a>    <span class="c1">//! Query underlying proxy element type</span>
<a name="line-270"></a>    <span class="c1">//! \return Zero-based index that can be used, e.g., indexing into the set</span>
<a name="line-271"></a>    <span class="c1">//!   of types of ProxyElem</span>
<a name="line-272"></a>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">index_element</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">element</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">index</span><span class="p">();</span> <span class="p">}</span>
<a name="line-273"></a>
<a name="line-274"></a>    <span class="c1">//! Charm++ array options accessor for binding external proxies</span>
<a name="line-275"></a>    <span class="c1">//! \return Charm++ array options object reference</span>
<a name="line-276"></a>    <span class="k">const</span> <span class="n">CkArrayOptions</span><span class="o">&amp;</span> <span class="n">arrayoptions</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bound</span><span class="p">;</span> <span class="p">}</span>
<a name="line-277"></a>
<a name="line-278"></a>    <span class="cm">/** @name Charm++ pack/unpack serializer member functions */</span>
<a name="line-279"></a>    <span class="c1">///@{</span>
<a name="line-280"></a>    <span class="c1">//! \brief Pack/Unpack serialize member function</span>
<a name="line-281"></a>    <span class="c1">//! \param[in,out] p Charm++&#39;s PUP::er serializer object reference</span>
<a name="line-282"></a><span class="hll">    <span class="kt">void</span> <span class="n">pup</span><span class="p">(</span> <span class="n">PUP</span><span class="o">::</span><span class="n">er</span> <span class="o">&amp;</span><span class="n">p</span> <span class="p">)</span> <span class="p">{</span><span class="error2">&lt;--- Parameter 'p' can be declared with const</span>
</span><a name="line-283"></a>      <span class="n">p</span> <span class="o">|</span> <span class="n">proxy</span><span class="p">;</span>
<a name="line-284"></a>      <span class="n">p</span> <span class="o">|</span> <span class="n">discproxy</span><span class="p">;</span>
<a name="line-285"></a>      <span class="n">p</span> <span class="o">|</span> <span class="n">fctproxy</span><span class="p">;</span>
<a name="line-286"></a>      <span class="n">p</span> <span class="o">|</span> <span class="n">aleproxy</span><span class="p">;</span>
<a name="line-287"></a>      <span class="n">p</span> <span class="o">|</span> <span class="n">conjugategradientsproxy</span><span class="p">;</span>
<a name="line-288"></a>      <span class="n">p</span> <span class="o">|</span> <span class="n">ghostsproxy</span><span class="p">;</span>
<a name="line-289"></a>      <span class="n">p</span> <span class="o">|</span> <span class="n">bound</span><span class="p">;</span>
<a name="line-290"></a>    <span class="p">}</span>
<a name="line-291"></a>    <span class="c1">//! \brief Pack/Unpack serialize operator|</span>
<a name="line-292"></a>    <span class="c1">//! \param[in,out] p Charm++&#39;s PUP::er serializer object reference</span>
<a name="line-293"></a>    <span class="c1">//! \param[in,out] s Scheme object reference</span>
<a name="line-294"></a>    <span class="k">friend</span> <span class="kt">void</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span> <span class="n">PUP</span><span class="o">::</span><span class="n">er</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="n">Scheme</span><span class="o">&amp;</span> <span class="n">s</span> <span class="p">)</span> <span class="p">{</span> <span class="n">s</span><span class="p">.</span><span class="n">pup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="p">}</span>
<a name="line-295"></a>    <span class="c1">//@}</span>
<a name="line-296"></a>
<a name="line-297"></a>  <span class="k">private</span><span class="o">:</span>
<a name="line-298"></a>    <span class="c1">//! Variant storing one proxy to which this class is configured for</span>
<a name="line-299"></a>    <span class="n">Proxy</span> <span class="n">proxy</span><span class="p">;</span>
<a name="line-300"></a>    <span class="c1">//! Charm++ proxy to data and code common to all discretizations</span>
<a name="line-301"></a>    <span class="n">CProxy_Discretization</span> <span class="n">discproxy</span><span class="p">;</span>
<a name="line-302"></a>    <span class="c1">//! Charm++ proxy to flux-corrected transport (FCT) driver class</span>
<a name="line-303"></a>    <span class="n">CProxy_DistFCT</span> <span class="n">fctproxy</span><span class="p">;</span>
<a name="line-304"></a>    <span class="c1">//! Charm++ proxy to ALE class</span>
<a name="line-305"></a>    <span class="n">CProxy_ALE</span> <span class="n">aleproxy</span><span class="p">;</span>
<a name="line-306"></a>    <span class="c1">//! Charm++ proxy to conjugate gradients linear solver class</span>
<a name="line-307"></a>    <span class="n">tk</span><span class="o">::</span><span class="n">CProxy_ConjugateGradients</span> <span class="n">conjugategradientsproxy</span><span class="p">;</span>
<a name="line-308"></a>    <span class="c1">//! Charm++ proxy to Ghosts class</span>
<a name="line-309"></a>    <span class="n">CProxy_Ghosts</span> <span class="n">ghostsproxy</span><span class="p">;</span>
<a name="line-310"></a>    <span class="c1">//! Charm++ array options for binding chares</span>
<a name="line-311"></a>    <span class="n">CkArrayOptions</span> <span class="n">bound</span><span class="p">;</span>
<a name="line-312"></a>
<a name="line-313"></a>    <span class="c1">//! Function dereferencing operator[] of chare proxy inside variant</span>
<a name="line-314"></a>    <span class="c1">//! \param[in] x Chare array element index</span>
<a name="line-315"></a>    <span class="c1">//! \return Chare array element proxy as a variant, defined by ProxyElem</span>
<a name="line-316"></a>    <span class="c1">//! \details The returning element proxy is a variant, depending on the</span>
<a name="line-317"></a>    <span class="c1">//!   input proxy.</span>
<a name="line-318"></a>    <span class="n">ProxyElem</span> <span class="nf">element</span><span class="p">(</span> <span class="k">const</span> <span class="n">CkArrayIndex1D</span><span class="o">&amp;</span> <span class="n">x</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<a name="line-319"></a>      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span> <span class="p">){</span>
<a name="line-320"></a>               <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">ProxyElem</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">);</span> <span class="p">},</span> <span class="n">proxy</span> <span class="p">);</span>
<a name="line-321"></a>    <span class="p">}</span>
<a name="line-322"></a><span class="p">};</span>
<a name="line-323"></a>
<a name="line-324"></a><span class="p">}</span> <span class="c1">// inciter::</span>
<a name="line-325"></a>
<a name="line-326"></a><span class="cp">#endif </span><span class="c1">// Scheme_h</span>
</pre></div>
</td></tr></table>
      </div> <!-- /.wrapper -->
    </div>
    <div id="footer" class="footer">
      <p>
        Cppcheck 2.3 - a tool for static C/C++ code analysis<br>
        <br>
        Internet: <a href="http://cppcheck.net">http://cppcheck.net</a><br>
        IRC: <a href="irc://irc.freenode.net/cppcheck">irc://irc.freenode.net/cppcheck</a><br>
      </p>
    </div>
  </body>
</html>
